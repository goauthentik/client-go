/*
authentik

Making authentication simple.

API version: 2024.6.3
Contact: hello@goauthentik.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// PropertymappingsApiService PropertymappingsApi service
type PropertymappingsApiService service

type ApiPropertymappingsAllDestroyRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsAllDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PropertymappingsAllDestroyExecute(r)
}

/*
PropertymappingsAllDestroy Method for PropertymappingsAllDestroy

PropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Property Mapping.
	@return ApiPropertymappingsAllDestroyRequest
*/
func (a *PropertymappingsApiService) PropertymappingsAllDestroy(ctx context.Context, pmUuid string) ApiPropertymappingsAllDestroyRequest {
	return ApiPropertymappingsAllDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsApiService) PropertymappingsAllDestroyExecute(r ApiPropertymappingsAllDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsAllDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/all/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsAllListRequest struct {
	ctx           context.Context
	ApiService    *PropertymappingsApiService
	managed       *[]string
	managedIsnull *bool
	name          *string
	ordering      *string
	page          *int32
	pageSize      *int32
	search        *string
}

func (r ApiPropertymappingsAllListRequest) Managed(managed []string) ApiPropertymappingsAllListRequest {
	r.managed = &managed
	return r
}

func (r ApiPropertymappingsAllListRequest) ManagedIsnull(managedIsnull bool) ApiPropertymappingsAllListRequest {
	r.managedIsnull = &managedIsnull
	return r
}

func (r ApiPropertymappingsAllListRequest) Name(name string) ApiPropertymappingsAllListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsAllListRequest) Ordering(ordering string) ApiPropertymappingsAllListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsAllListRequest) Page(page int32) ApiPropertymappingsAllListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsAllListRequest) PageSize(pageSize int32) ApiPropertymappingsAllListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiPropertymappingsAllListRequest) Search(search string) ApiPropertymappingsAllListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsAllListRequest) Execute() (*PaginatedPropertyMappingList, *http.Response, error) {
	return r.ApiService.PropertymappingsAllListExecute(r)
}

/*
PropertymappingsAllList Method for PropertymappingsAllList

PropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsAllListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsAllList(ctx context.Context) ApiPropertymappingsAllListRequest {
	return ApiPropertymappingsAllListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedPropertyMappingList
func (a *PropertymappingsApiService) PropertymappingsAllListExecute(r ApiPropertymappingsAllListRequest) (*PaginatedPropertyMappingList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedPropertyMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsAllList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/all/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.managed != nil {
		t := *r.managed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("managed", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("managed", parameterToString(t, "multi"))
		}
	}
	if r.managedIsnull != nil {
		localVarQueryParams.Add("managed__isnull", parameterToString(*r.managedIsnull, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsAllRetrieveRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsAllRetrieveRequest) Execute() (*PropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsAllRetrieveExecute(r)
}

/*
PropertymappingsAllRetrieve Method for PropertymappingsAllRetrieve

PropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Property Mapping.
	@return ApiPropertymappingsAllRetrieveRequest
*/
func (a *PropertymappingsApiService) PropertymappingsAllRetrieve(ctx context.Context, pmUuid string) ApiPropertymappingsAllRetrieveRequest {
	return ApiPropertymappingsAllRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return PropertyMapping
func (a *PropertymappingsApiService) PropertymappingsAllRetrieveExecute(r ApiPropertymappingsAllRetrieveRequest) (*PropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsAllRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/all/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsAllTestCreateRequest struct {
	ctx                        context.Context
	ApiService                 *PropertymappingsApiService
	pmUuid                     string
	formatResult               *bool
	propertyMappingTestRequest *PropertyMappingTestRequest
}

func (r ApiPropertymappingsAllTestCreateRequest) FormatResult(formatResult bool) ApiPropertymappingsAllTestCreateRequest {
	r.formatResult = &formatResult
	return r
}

func (r ApiPropertymappingsAllTestCreateRequest) PropertyMappingTestRequest(propertyMappingTestRequest PropertyMappingTestRequest) ApiPropertymappingsAllTestCreateRequest {
	r.propertyMappingTestRequest = &propertyMappingTestRequest
	return r
}

func (r ApiPropertymappingsAllTestCreateRequest) Execute() (*PropertyMappingTestResult, *http.Response, error) {
	return r.ApiService.PropertymappingsAllTestCreateExecute(r)
}

/*
PropertymappingsAllTestCreate Method for PropertymappingsAllTestCreate

Test Property Mapping

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Property Mapping.
	@return ApiPropertymappingsAllTestCreateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsAllTestCreate(ctx context.Context, pmUuid string) ApiPropertymappingsAllTestCreateRequest {
	return ApiPropertymappingsAllTestCreateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return PropertyMappingTestResult
func (a *PropertymappingsApiService) PropertymappingsAllTestCreateExecute(r ApiPropertymappingsAllTestCreateRequest) (*PropertyMappingTestResult, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PropertyMappingTestResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsAllTestCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/all/{pm_uuid}/test/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.formatResult != nil {
		localVarQueryParams.Add("format_result", parameterToString(*r.formatResult, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.propertyMappingTestRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsAllTypesListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
}

func (r ApiPropertymappingsAllTypesListRequest) Execute() ([]TypeCreate, *http.Response, error) {
	return r.ApiService.PropertymappingsAllTypesListExecute(r)
}

/*
PropertymappingsAllTypesList Method for PropertymappingsAllTypesList

Get all creatable types

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsAllTypesListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsAllTypesList(ctx context.Context) ApiPropertymappingsAllTypesListRequest {
	return ApiPropertymappingsAllTypesListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []TypeCreate
func (a *PropertymappingsApiService) PropertymappingsAllTypesListExecute(r ApiPropertymappingsAllTypesListRequest) ([]TypeCreate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []TypeCreate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsAllTypesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/all/types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsAllUsedByListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsAllUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.PropertymappingsAllUsedByListExecute(r)
}

/*
PropertymappingsAllUsedByList Method for PropertymappingsAllUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Property Mapping.
	@return ApiPropertymappingsAllUsedByListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsAllUsedByList(ctx context.Context, pmUuid string) ApiPropertymappingsAllUsedByListRequest {
	return ApiPropertymappingsAllUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *PropertymappingsApiService) PropertymappingsAllUsedByListExecute(r ApiPropertymappingsAllUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsAllUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/all/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsNotificationCreateRequest struct {
	ctx                               context.Context
	ApiService                        *PropertymappingsApiService
	notificationWebhookMappingRequest *NotificationWebhookMappingRequest
}

func (r ApiPropertymappingsNotificationCreateRequest) NotificationWebhookMappingRequest(notificationWebhookMappingRequest NotificationWebhookMappingRequest) ApiPropertymappingsNotificationCreateRequest {
	r.notificationWebhookMappingRequest = &notificationWebhookMappingRequest
	return r
}

func (r ApiPropertymappingsNotificationCreateRequest) Execute() (*NotificationWebhookMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsNotificationCreateExecute(r)
}

/*
PropertymappingsNotificationCreate Method for PropertymappingsNotificationCreate

NotificationWebhookMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsNotificationCreateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsNotificationCreate(ctx context.Context) ApiPropertymappingsNotificationCreateRequest {
	return ApiPropertymappingsNotificationCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return NotificationWebhookMapping
func (a *PropertymappingsApiService) PropertymappingsNotificationCreateExecute(r ApiPropertymappingsNotificationCreateRequest) (*NotificationWebhookMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NotificationWebhookMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsNotificationCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/notification/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.notificationWebhookMappingRequest == nil {
		return localVarReturnValue, nil, reportError("notificationWebhookMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.notificationWebhookMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsNotificationDestroyRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsNotificationDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PropertymappingsNotificationDestroyExecute(r)
}

/*
PropertymappingsNotificationDestroy Method for PropertymappingsNotificationDestroy

NotificationWebhookMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Webhook Mapping.
	@return ApiPropertymappingsNotificationDestroyRequest
*/
func (a *PropertymappingsApiService) PropertymappingsNotificationDestroy(ctx context.Context, pmUuid string) ApiPropertymappingsNotificationDestroyRequest {
	return ApiPropertymappingsNotificationDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsApiService) PropertymappingsNotificationDestroyExecute(r ApiPropertymappingsNotificationDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsNotificationDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/notification/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsNotificationListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	name       *string
	ordering   *string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiPropertymappingsNotificationListRequest) Name(name string) ApiPropertymappingsNotificationListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsNotificationListRequest) Ordering(ordering string) ApiPropertymappingsNotificationListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsNotificationListRequest) Page(page int32) ApiPropertymappingsNotificationListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsNotificationListRequest) PageSize(pageSize int32) ApiPropertymappingsNotificationListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiPropertymappingsNotificationListRequest) Search(search string) ApiPropertymappingsNotificationListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsNotificationListRequest) Execute() (*PaginatedNotificationWebhookMappingList, *http.Response, error) {
	return r.ApiService.PropertymappingsNotificationListExecute(r)
}

/*
PropertymappingsNotificationList Method for PropertymappingsNotificationList

NotificationWebhookMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsNotificationListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsNotificationList(ctx context.Context) ApiPropertymappingsNotificationListRequest {
	return ApiPropertymappingsNotificationListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedNotificationWebhookMappingList
func (a *PropertymappingsApiService) PropertymappingsNotificationListExecute(r ApiPropertymappingsNotificationListRequest) (*PaginatedNotificationWebhookMappingList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedNotificationWebhookMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsNotificationList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/notification/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsNotificationPartialUpdateRequest struct {
	ctx                                      context.Context
	ApiService                               *PropertymappingsApiService
	pmUuid                                   string
	patchedNotificationWebhookMappingRequest *PatchedNotificationWebhookMappingRequest
}

func (r ApiPropertymappingsNotificationPartialUpdateRequest) PatchedNotificationWebhookMappingRequest(patchedNotificationWebhookMappingRequest PatchedNotificationWebhookMappingRequest) ApiPropertymappingsNotificationPartialUpdateRequest {
	r.patchedNotificationWebhookMappingRequest = &patchedNotificationWebhookMappingRequest
	return r
}

func (r ApiPropertymappingsNotificationPartialUpdateRequest) Execute() (*NotificationWebhookMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsNotificationPartialUpdateExecute(r)
}

/*
PropertymappingsNotificationPartialUpdate Method for PropertymappingsNotificationPartialUpdate

NotificationWebhookMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Webhook Mapping.
	@return ApiPropertymappingsNotificationPartialUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsNotificationPartialUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsNotificationPartialUpdateRequest {
	return ApiPropertymappingsNotificationPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return NotificationWebhookMapping
func (a *PropertymappingsApiService) PropertymappingsNotificationPartialUpdateExecute(r ApiPropertymappingsNotificationPartialUpdateRequest) (*NotificationWebhookMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NotificationWebhookMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsNotificationPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/notification/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedNotificationWebhookMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsNotificationRetrieveRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsNotificationRetrieveRequest) Execute() (*NotificationWebhookMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsNotificationRetrieveExecute(r)
}

/*
PropertymappingsNotificationRetrieve Method for PropertymappingsNotificationRetrieve

NotificationWebhookMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Webhook Mapping.
	@return ApiPropertymappingsNotificationRetrieveRequest
*/
func (a *PropertymappingsApiService) PropertymappingsNotificationRetrieve(ctx context.Context, pmUuid string) ApiPropertymappingsNotificationRetrieveRequest {
	return ApiPropertymappingsNotificationRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return NotificationWebhookMapping
func (a *PropertymappingsApiService) PropertymappingsNotificationRetrieveExecute(r ApiPropertymappingsNotificationRetrieveRequest) (*NotificationWebhookMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NotificationWebhookMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsNotificationRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/notification/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsNotificationUpdateRequest struct {
	ctx                               context.Context
	ApiService                        *PropertymappingsApiService
	pmUuid                            string
	notificationWebhookMappingRequest *NotificationWebhookMappingRequest
}

func (r ApiPropertymappingsNotificationUpdateRequest) NotificationWebhookMappingRequest(notificationWebhookMappingRequest NotificationWebhookMappingRequest) ApiPropertymappingsNotificationUpdateRequest {
	r.notificationWebhookMappingRequest = &notificationWebhookMappingRequest
	return r
}

func (r ApiPropertymappingsNotificationUpdateRequest) Execute() (*NotificationWebhookMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsNotificationUpdateExecute(r)
}

/*
PropertymappingsNotificationUpdate Method for PropertymappingsNotificationUpdate

NotificationWebhookMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Webhook Mapping.
	@return ApiPropertymappingsNotificationUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsNotificationUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsNotificationUpdateRequest {
	return ApiPropertymappingsNotificationUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return NotificationWebhookMapping
func (a *PropertymappingsApiService) PropertymappingsNotificationUpdateExecute(r ApiPropertymappingsNotificationUpdateRequest) (*NotificationWebhookMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NotificationWebhookMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsNotificationUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/notification/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.notificationWebhookMappingRequest == nil {
		return localVarReturnValue, nil, reportError("notificationWebhookMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.notificationWebhookMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsNotificationUsedByListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsNotificationUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.PropertymappingsNotificationUsedByListExecute(r)
}

/*
PropertymappingsNotificationUsedByList Method for PropertymappingsNotificationUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Webhook Mapping.
	@return ApiPropertymappingsNotificationUsedByListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsNotificationUsedByList(ctx context.Context, pmUuid string) ApiPropertymappingsNotificationUsedByListRequest {
	return ApiPropertymappingsNotificationUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *PropertymappingsApiService) PropertymappingsNotificationUsedByListExecute(r ApiPropertymappingsNotificationUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsNotificationUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/notification/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderGoogleWorkspaceCreateRequest struct {
	ctx                                   context.Context
	ApiService                            *PropertymappingsApiService
	googleWorkspaceProviderMappingRequest *GoogleWorkspaceProviderMappingRequest
}

func (r ApiPropertymappingsProviderGoogleWorkspaceCreateRequest) GoogleWorkspaceProviderMappingRequest(googleWorkspaceProviderMappingRequest GoogleWorkspaceProviderMappingRequest) ApiPropertymappingsProviderGoogleWorkspaceCreateRequest {
	r.googleWorkspaceProviderMappingRequest = &googleWorkspaceProviderMappingRequest
	return r
}

func (r ApiPropertymappingsProviderGoogleWorkspaceCreateRequest) Execute() (*GoogleWorkspaceProviderMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderGoogleWorkspaceCreateExecute(r)
}

/*
PropertymappingsProviderGoogleWorkspaceCreate Method for PropertymappingsProviderGoogleWorkspaceCreate

GoogleWorkspaceProviderMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsProviderGoogleWorkspaceCreateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsProviderGoogleWorkspaceCreate(ctx context.Context) ApiPropertymappingsProviderGoogleWorkspaceCreateRequest {
	return ApiPropertymappingsProviderGoogleWorkspaceCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GoogleWorkspaceProviderMapping
func (a *PropertymappingsApiService) PropertymappingsProviderGoogleWorkspaceCreateExecute(r ApiPropertymappingsProviderGoogleWorkspaceCreateRequest) (*GoogleWorkspaceProviderMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GoogleWorkspaceProviderMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsProviderGoogleWorkspaceCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/google_workspace/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.googleWorkspaceProviderMappingRequest == nil {
		return localVarReturnValue, nil, reportError("googleWorkspaceProviderMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.googleWorkspaceProviderMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderGoogleWorkspaceDestroyRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsProviderGoogleWorkspaceDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PropertymappingsProviderGoogleWorkspaceDestroyExecute(r)
}

/*
PropertymappingsProviderGoogleWorkspaceDestroy Method for PropertymappingsProviderGoogleWorkspaceDestroy

GoogleWorkspaceProviderMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Google Workspace Provider Mapping.
	@return ApiPropertymappingsProviderGoogleWorkspaceDestroyRequest
*/
func (a *PropertymappingsApiService) PropertymappingsProviderGoogleWorkspaceDestroy(ctx context.Context, pmUuid string) ApiPropertymappingsProviderGoogleWorkspaceDestroyRequest {
	return ApiPropertymappingsProviderGoogleWorkspaceDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsApiService) PropertymappingsProviderGoogleWorkspaceDestroyExecute(r ApiPropertymappingsProviderGoogleWorkspaceDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsProviderGoogleWorkspaceDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/google_workspace/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderGoogleWorkspaceListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	expression *string
	managed    *[]string
	name       *string
	ordering   *string
	page       *int32
	pageSize   *int32
	pmUuid     *string
	search     *string
}

func (r ApiPropertymappingsProviderGoogleWorkspaceListRequest) Expression(expression string) ApiPropertymappingsProviderGoogleWorkspaceListRequest {
	r.expression = &expression
	return r
}

func (r ApiPropertymappingsProviderGoogleWorkspaceListRequest) Managed(managed []string) ApiPropertymappingsProviderGoogleWorkspaceListRequest {
	r.managed = &managed
	return r
}

func (r ApiPropertymappingsProviderGoogleWorkspaceListRequest) Name(name string) ApiPropertymappingsProviderGoogleWorkspaceListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsProviderGoogleWorkspaceListRequest) Ordering(ordering string) ApiPropertymappingsProviderGoogleWorkspaceListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsProviderGoogleWorkspaceListRequest) Page(page int32) ApiPropertymappingsProviderGoogleWorkspaceListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsProviderGoogleWorkspaceListRequest) PageSize(pageSize int32) ApiPropertymappingsProviderGoogleWorkspaceListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiPropertymappingsProviderGoogleWorkspaceListRequest) PmUuid(pmUuid string) ApiPropertymappingsProviderGoogleWorkspaceListRequest {
	r.pmUuid = &pmUuid
	return r
}

// A search term.
func (r ApiPropertymappingsProviderGoogleWorkspaceListRequest) Search(search string) ApiPropertymappingsProviderGoogleWorkspaceListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsProviderGoogleWorkspaceListRequest) Execute() (*PaginatedGoogleWorkspaceProviderMappingList, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderGoogleWorkspaceListExecute(r)
}

/*
PropertymappingsProviderGoogleWorkspaceList Method for PropertymappingsProviderGoogleWorkspaceList

GoogleWorkspaceProviderMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsProviderGoogleWorkspaceListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsProviderGoogleWorkspaceList(ctx context.Context) ApiPropertymappingsProviderGoogleWorkspaceListRequest {
	return ApiPropertymappingsProviderGoogleWorkspaceListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedGoogleWorkspaceProviderMappingList
func (a *PropertymappingsApiService) PropertymappingsProviderGoogleWorkspaceListExecute(r ApiPropertymappingsProviderGoogleWorkspaceListRequest) (*PaginatedGoogleWorkspaceProviderMappingList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedGoogleWorkspaceProviderMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsProviderGoogleWorkspaceList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/google_workspace/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.expression != nil {
		localVarQueryParams.Add("expression", parameterToString(*r.expression, ""))
	}
	if r.managed != nil {
		t := *r.managed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("managed", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("managed", parameterToString(t, "multi"))
		}
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pmUuid != nil {
		localVarQueryParams.Add("pm_uuid", parameterToString(*r.pmUuid, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderGoogleWorkspacePartialUpdateRequest struct {
	ctx                                          context.Context
	ApiService                                   *PropertymappingsApiService
	pmUuid                                       string
	patchedGoogleWorkspaceProviderMappingRequest *PatchedGoogleWorkspaceProviderMappingRequest
}

func (r ApiPropertymappingsProviderGoogleWorkspacePartialUpdateRequest) PatchedGoogleWorkspaceProviderMappingRequest(patchedGoogleWorkspaceProviderMappingRequest PatchedGoogleWorkspaceProviderMappingRequest) ApiPropertymappingsProviderGoogleWorkspacePartialUpdateRequest {
	r.patchedGoogleWorkspaceProviderMappingRequest = &patchedGoogleWorkspaceProviderMappingRequest
	return r
}

func (r ApiPropertymappingsProviderGoogleWorkspacePartialUpdateRequest) Execute() (*GoogleWorkspaceProviderMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderGoogleWorkspacePartialUpdateExecute(r)
}

/*
PropertymappingsProviderGoogleWorkspacePartialUpdate Method for PropertymappingsProviderGoogleWorkspacePartialUpdate

GoogleWorkspaceProviderMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Google Workspace Provider Mapping.
	@return ApiPropertymappingsProviderGoogleWorkspacePartialUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsProviderGoogleWorkspacePartialUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsProviderGoogleWorkspacePartialUpdateRequest {
	return ApiPropertymappingsProviderGoogleWorkspacePartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return GoogleWorkspaceProviderMapping
func (a *PropertymappingsApiService) PropertymappingsProviderGoogleWorkspacePartialUpdateExecute(r ApiPropertymappingsProviderGoogleWorkspacePartialUpdateRequest) (*GoogleWorkspaceProviderMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GoogleWorkspaceProviderMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsProviderGoogleWorkspacePartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/google_workspace/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedGoogleWorkspaceProviderMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderGoogleWorkspaceRetrieveRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsProviderGoogleWorkspaceRetrieveRequest) Execute() (*GoogleWorkspaceProviderMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderGoogleWorkspaceRetrieveExecute(r)
}

/*
PropertymappingsProviderGoogleWorkspaceRetrieve Method for PropertymappingsProviderGoogleWorkspaceRetrieve

GoogleWorkspaceProviderMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Google Workspace Provider Mapping.
	@return ApiPropertymappingsProviderGoogleWorkspaceRetrieveRequest
*/
func (a *PropertymappingsApiService) PropertymappingsProviderGoogleWorkspaceRetrieve(ctx context.Context, pmUuid string) ApiPropertymappingsProviderGoogleWorkspaceRetrieveRequest {
	return ApiPropertymappingsProviderGoogleWorkspaceRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return GoogleWorkspaceProviderMapping
func (a *PropertymappingsApiService) PropertymappingsProviderGoogleWorkspaceRetrieveExecute(r ApiPropertymappingsProviderGoogleWorkspaceRetrieveRequest) (*GoogleWorkspaceProviderMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GoogleWorkspaceProviderMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsProviderGoogleWorkspaceRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/google_workspace/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderGoogleWorkspaceUpdateRequest struct {
	ctx                                   context.Context
	ApiService                            *PropertymappingsApiService
	pmUuid                                string
	googleWorkspaceProviderMappingRequest *GoogleWorkspaceProviderMappingRequest
}

func (r ApiPropertymappingsProviderGoogleWorkspaceUpdateRequest) GoogleWorkspaceProviderMappingRequest(googleWorkspaceProviderMappingRequest GoogleWorkspaceProviderMappingRequest) ApiPropertymappingsProviderGoogleWorkspaceUpdateRequest {
	r.googleWorkspaceProviderMappingRequest = &googleWorkspaceProviderMappingRequest
	return r
}

func (r ApiPropertymappingsProviderGoogleWorkspaceUpdateRequest) Execute() (*GoogleWorkspaceProviderMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderGoogleWorkspaceUpdateExecute(r)
}

/*
PropertymappingsProviderGoogleWorkspaceUpdate Method for PropertymappingsProviderGoogleWorkspaceUpdate

GoogleWorkspaceProviderMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Google Workspace Provider Mapping.
	@return ApiPropertymappingsProviderGoogleWorkspaceUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsProviderGoogleWorkspaceUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsProviderGoogleWorkspaceUpdateRequest {
	return ApiPropertymappingsProviderGoogleWorkspaceUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return GoogleWorkspaceProviderMapping
func (a *PropertymappingsApiService) PropertymappingsProviderGoogleWorkspaceUpdateExecute(r ApiPropertymappingsProviderGoogleWorkspaceUpdateRequest) (*GoogleWorkspaceProviderMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GoogleWorkspaceProviderMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsProviderGoogleWorkspaceUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/google_workspace/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.googleWorkspaceProviderMappingRequest == nil {
		return localVarReturnValue, nil, reportError("googleWorkspaceProviderMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.googleWorkspaceProviderMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderGoogleWorkspaceUsedByListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsProviderGoogleWorkspaceUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderGoogleWorkspaceUsedByListExecute(r)
}

/*
PropertymappingsProviderGoogleWorkspaceUsedByList Method for PropertymappingsProviderGoogleWorkspaceUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Google Workspace Provider Mapping.
	@return ApiPropertymappingsProviderGoogleWorkspaceUsedByListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsProviderGoogleWorkspaceUsedByList(ctx context.Context, pmUuid string) ApiPropertymappingsProviderGoogleWorkspaceUsedByListRequest {
	return ApiPropertymappingsProviderGoogleWorkspaceUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *PropertymappingsApiService) PropertymappingsProviderGoogleWorkspaceUsedByListExecute(r ApiPropertymappingsProviderGoogleWorkspaceUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsProviderGoogleWorkspaceUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/google_workspace/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderMicrosoftEntraCreateRequest struct {
	ctx                                  context.Context
	ApiService                           *PropertymappingsApiService
	microsoftEntraProviderMappingRequest *MicrosoftEntraProviderMappingRequest
}

func (r ApiPropertymappingsProviderMicrosoftEntraCreateRequest) MicrosoftEntraProviderMappingRequest(microsoftEntraProviderMappingRequest MicrosoftEntraProviderMappingRequest) ApiPropertymappingsProviderMicrosoftEntraCreateRequest {
	r.microsoftEntraProviderMappingRequest = &microsoftEntraProviderMappingRequest
	return r
}

func (r ApiPropertymappingsProviderMicrosoftEntraCreateRequest) Execute() (*MicrosoftEntraProviderMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderMicrosoftEntraCreateExecute(r)
}

/*
PropertymappingsProviderMicrosoftEntraCreate Method for PropertymappingsProviderMicrosoftEntraCreate

MicrosoftEntraProviderMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsProviderMicrosoftEntraCreateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsProviderMicrosoftEntraCreate(ctx context.Context) ApiPropertymappingsProviderMicrosoftEntraCreateRequest {
	return ApiPropertymappingsProviderMicrosoftEntraCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MicrosoftEntraProviderMapping
func (a *PropertymappingsApiService) PropertymappingsProviderMicrosoftEntraCreateExecute(r ApiPropertymappingsProviderMicrosoftEntraCreateRequest) (*MicrosoftEntraProviderMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MicrosoftEntraProviderMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsProviderMicrosoftEntraCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/microsoft_entra/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.microsoftEntraProviderMappingRequest == nil {
		return localVarReturnValue, nil, reportError("microsoftEntraProviderMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftEntraProviderMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderMicrosoftEntraDestroyRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsProviderMicrosoftEntraDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PropertymappingsProviderMicrosoftEntraDestroyExecute(r)
}

/*
PropertymappingsProviderMicrosoftEntraDestroy Method for PropertymappingsProviderMicrosoftEntraDestroy

MicrosoftEntraProviderMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Microsoft Entra Provider Mapping.
	@return ApiPropertymappingsProviderMicrosoftEntraDestroyRequest
*/
func (a *PropertymappingsApiService) PropertymappingsProviderMicrosoftEntraDestroy(ctx context.Context, pmUuid string) ApiPropertymappingsProviderMicrosoftEntraDestroyRequest {
	return ApiPropertymappingsProviderMicrosoftEntraDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsApiService) PropertymappingsProviderMicrosoftEntraDestroyExecute(r ApiPropertymappingsProviderMicrosoftEntraDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsProviderMicrosoftEntraDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/microsoft_entra/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderMicrosoftEntraListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	expression *string
	managed    *[]string
	name       *string
	ordering   *string
	page       *int32
	pageSize   *int32
	pmUuid     *string
	search     *string
}

func (r ApiPropertymappingsProviderMicrosoftEntraListRequest) Expression(expression string) ApiPropertymappingsProviderMicrosoftEntraListRequest {
	r.expression = &expression
	return r
}

func (r ApiPropertymappingsProviderMicrosoftEntraListRequest) Managed(managed []string) ApiPropertymappingsProviderMicrosoftEntraListRequest {
	r.managed = &managed
	return r
}

func (r ApiPropertymappingsProviderMicrosoftEntraListRequest) Name(name string) ApiPropertymappingsProviderMicrosoftEntraListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsProviderMicrosoftEntraListRequest) Ordering(ordering string) ApiPropertymappingsProviderMicrosoftEntraListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsProviderMicrosoftEntraListRequest) Page(page int32) ApiPropertymappingsProviderMicrosoftEntraListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsProviderMicrosoftEntraListRequest) PageSize(pageSize int32) ApiPropertymappingsProviderMicrosoftEntraListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiPropertymappingsProviderMicrosoftEntraListRequest) PmUuid(pmUuid string) ApiPropertymappingsProviderMicrosoftEntraListRequest {
	r.pmUuid = &pmUuid
	return r
}

// A search term.
func (r ApiPropertymappingsProviderMicrosoftEntraListRequest) Search(search string) ApiPropertymappingsProviderMicrosoftEntraListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsProviderMicrosoftEntraListRequest) Execute() (*PaginatedMicrosoftEntraProviderMappingList, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderMicrosoftEntraListExecute(r)
}

/*
PropertymappingsProviderMicrosoftEntraList Method for PropertymappingsProviderMicrosoftEntraList

MicrosoftEntraProviderMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsProviderMicrosoftEntraListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsProviderMicrosoftEntraList(ctx context.Context) ApiPropertymappingsProviderMicrosoftEntraListRequest {
	return ApiPropertymappingsProviderMicrosoftEntraListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedMicrosoftEntraProviderMappingList
func (a *PropertymappingsApiService) PropertymappingsProviderMicrosoftEntraListExecute(r ApiPropertymappingsProviderMicrosoftEntraListRequest) (*PaginatedMicrosoftEntraProviderMappingList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedMicrosoftEntraProviderMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsProviderMicrosoftEntraList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/microsoft_entra/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.expression != nil {
		localVarQueryParams.Add("expression", parameterToString(*r.expression, ""))
	}
	if r.managed != nil {
		t := *r.managed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("managed", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("managed", parameterToString(t, "multi"))
		}
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pmUuid != nil {
		localVarQueryParams.Add("pm_uuid", parameterToString(*r.pmUuid, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderMicrosoftEntraPartialUpdateRequest struct {
	ctx                                         context.Context
	ApiService                                  *PropertymappingsApiService
	pmUuid                                      string
	patchedMicrosoftEntraProviderMappingRequest *PatchedMicrosoftEntraProviderMappingRequest
}

func (r ApiPropertymappingsProviderMicrosoftEntraPartialUpdateRequest) PatchedMicrosoftEntraProviderMappingRequest(patchedMicrosoftEntraProviderMappingRequest PatchedMicrosoftEntraProviderMappingRequest) ApiPropertymappingsProviderMicrosoftEntraPartialUpdateRequest {
	r.patchedMicrosoftEntraProviderMappingRequest = &patchedMicrosoftEntraProviderMappingRequest
	return r
}

func (r ApiPropertymappingsProviderMicrosoftEntraPartialUpdateRequest) Execute() (*MicrosoftEntraProviderMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderMicrosoftEntraPartialUpdateExecute(r)
}

/*
PropertymappingsProviderMicrosoftEntraPartialUpdate Method for PropertymappingsProviderMicrosoftEntraPartialUpdate

MicrosoftEntraProviderMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Microsoft Entra Provider Mapping.
	@return ApiPropertymappingsProviderMicrosoftEntraPartialUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsProviderMicrosoftEntraPartialUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsProviderMicrosoftEntraPartialUpdateRequest {
	return ApiPropertymappingsProviderMicrosoftEntraPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return MicrosoftEntraProviderMapping
func (a *PropertymappingsApiService) PropertymappingsProviderMicrosoftEntraPartialUpdateExecute(r ApiPropertymappingsProviderMicrosoftEntraPartialUpdateRequest) (*MicrosoftEntraProviderMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MicrosoftEntraProviderMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsProviderMicrosoftEntraPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/microsoft_entra/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedMicrosoftEntraProviderMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderMicrosoftEntraRetrieveRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsProviderMicrosoftEntraRetrieveRequest) Execute() (*MicrosoftEntraProviderMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderMicrosoftEntraRetrieveExecute(r)
}

/*
PropertymappingsProviderMicrosoftEntraRetrieve Method for PropertymappingsProviderMicrosoftEntraRetrieve

MicrosoftEntraProviderMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Microsoft Entra Provider Mapping.
	@return ApiPropertymappingsProviderMicrosoftEntraRetrieveRequest
*/
func (a *PropertymappingsApiService) PropertymappingsProviderMicrosoftEntraRetrieve(ctx context.Context, pmUuid string) ApiPropertymappingsProviderMicrosoftEntraRetrieveRequest {
	return ApiPropertymappingsProviderMicrosoftEntraRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return MicrosoftEntraProviderMapping
func (a *PropertymappingsApiService) PropertymappingsProviderMicrosoftEntraRetrieveExecute(r ApiPropertymappingsProviderMicrosoftEntraRetrieveRequest) (*MicrosoftEntraProviderMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MicrosoftEntraProviderMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsProviderMicrosoftEntraRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/microsoft_entra/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderMicrosoftEntraUpdateRequest struct {
	ctx                                  context.Context
	ApiService                           *PropertymappingsApiService
	pmUuid                               string
	microsoftEntraProviderMappingRequest *MicrosoftEntraProviderMappingRequest
}

func (r ApiPropertymappingsProviderMicrosoftEntraUpdateRequest) MicrosoftEntraProviderMappingRequest(microsoftEntraProviderMappingRequest MicrosoftEntraProviderMappingRequest) ApiPropertymappingsProviderMicrosoftEntraUpdateRequest {
	r.microsoftEntraProviderMappingRequest = &microsoftEntraProviderMappingRequest
	return r
}

func (r ApiPropertymappingsProviderMicrosoftEntraUpdateRequest) Execute() (*MicrosoftEntraProviderMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderMicrosoftEntraUpdateExecute(r)
}

/*
PropertymappingsProviderMicrosoftEntraUpdate Method for PropertymappingsProviderMicrosoftEntraUpdate

MicrosoftEntraProviderMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Microsoft Entra Provider Mapping.
	@return ApiPropertymappingsProviderMicrosoftEntraUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsProviderMicrosoftEntraUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsProviderMicrosoftEntraUpdateRequest {
	return ApiPropertymappingsProviderMicrosoftEntraUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return MicrosoftEntraProviderMapping
func (a *PropertymappingsApiService) PropertymappingsProviderMicrosoftEntraUpdateExecute(r ApiPropertymappingsProviderMicrosoftEntraUpdateRequest) (*MicrosoftEntraProviderMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MicrosoftEntraProviderMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsProviderMicrosoftEntraUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/microsoft_entra/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.microsoftEntraProviderMappingRequest == nil {
		return localVarReturnValue, nil, reportError("microsoftEntraProviderMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftEntraProviderMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderMicrosoftEntraUsedByListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsProviderMicrosoftEntraUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderMicrosoftEntraUsedByListExecute(r)
}

/*
PropertymappingsProviderMicrosoftEntraUsedByList Method for PropertymappingsProviderMicrosoftEntraUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Microsoft Entra Provider Mapping.
	@return ApiPropertymappingsProviderMicrosoftEntraUsedByListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsProviderMicrosoftEntraUsedByList(ctx context.Context, pmUuid string) ApiPropertymappingsProviderMicrosoftEntraUsedByListRequest {
	return ApiPropertymappingsProviderMicrosoftEntraUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *PropertymappingsApiService) PropertymappingsProviderMicrosoftEntraUsedByListExecute(r ApiPropertymappingsProviderMicrosoftEntraUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsProviderMicrosoftEntraUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/microsoft_entra/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsRacCreateRequest struct {
	ctx                       context.Context
	ApiService                *PropertymappingsApiService
	rACPropertyMappingRequest *RACPropertyMappingRequest
}

func (r ApiPropertymappingsRacCreateRequest) RACPropertyMappingRequest(rACPropertyMappingRequest RACPropertyMappingRequest) ApiPropertymappingsRacCreateRequest {
	r.rACPropertyMappingRequest = &rACPropertyMappingRequest
	return r
}

func (r ApiPropertymappingsRacCreateRequest) Execute() (*RACPropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsRacCreateExecute(r)
}

/*
PropertymappingsRacCreate Method for PropertymappingsRacCreate

RACPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsRacCreateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsRacCreate(ctx context.Context) ApiPropertymappingsRacCreateRequest {
	return ApiPropertymappingsRacCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return RACPropertyMapping
func (a *PropertymappingsApiService) PropertymappingsRacCreateExecute(r ApiPropertymappingsRacCreateRequest) (*RACPropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RACPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsRacCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/rac/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rACPropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("rACPropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rACPropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsRacDestroyRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsRacDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PropertymappingsRacDestroyExecute(r)
}

/*
PropertymappingsRacDestroy Method for PropertymappingsRacDestroy

RACPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this RAC Property Mapping.
	@return ApiPropertymappingsRacDestroyRequest
*/
func (a *PropertymappingsApiService) PropertymappingsRacDestroy(ctx context.Context, pmUuid string) ApiPropertymappingsRacDestroyRequest {
	return ApiPropertymappingsRacDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsApiService) PropertymappingsRacDestroyExecute(r ApiPropertymappingsRacDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsRacDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/rac/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsRacListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	managed    *[]string
	name       *string
	ordering   *string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiPropertymappingsRacListRequest) Managed(managed []string) ApiPropertymappingsRacListRequest {
	r.managed = &managed
	return r
}

func (r ApiPropertymappingsRacListRequest) Name(name string) ApiPropertymappingsRacListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsRacListRequest) Ordering(ordering string) ApiPropertymappingsRacListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsRacListRequest) Page(page int32) ApiPropertymappingsRacListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsRacListRequest) PageSize(pageSize int32) ApiPropertymappingsRacListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiPropertymappingsRacListRequest) Search(search string) ApiPropertymappingsRacListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsRacListRequest) Execute() (*PaginatedRACPropertyMappingList, *http.Response, error) {
	return r.ApiService.PropertymappingsRacListExecute(r)
}

/*
PropertymappingsRacList Method for PropertymappingsRacList

RACPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsRacListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsRacList(ctx context.Context) ApiPropertymappingsRacListRequest {
	return ApiPropertymappingsRacListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedRACPropertyMappingList
func (a *PropertymappingsApiService) PropertymappingsRacListExecute(r ApiPropertymappingsRacListRequest) (*PaginatedRACPropertyMappingList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedRACPropertyMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsRacList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/rac/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.managed != nil {
		t := *r.managed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("managed", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("managed", parameterToString(t, "multi"))
		}
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsRacPartialUpdateRequest struct {
	ctx                              context.Context
	ApiService                       *PropertymappingsApiService
	pmUuid                           string
	patchedRACPropertyMappingRequest *PatchedRACPropertyMappingRequest
}

func (r ApiPropertymappingsRacPartialUpdateRequest) PatchedRACPropertyMappingRequest(patchedRACPropertyMappingRequest PatchedRACPropertyMappingRequest) ApiPropertymappingsRacPartialUpdateRequest {
	r.patchedRACPropertyMappingRequest = &patchedRACPropertyMappingRequest
	return r
}

func (r ApiPropertymappingsRacPartialUpdateRequest) Execute() (*RACPropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsRacPartialUpdateExecute(r)
}

/*
PropertymappingsRacPartialUpdate Method for PropertymappingsRacPartialUpdate

RACPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this RAC Property Mapping.
	@return ApiPropertymappingsRacPartialUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsRacPartialUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsRacPartialUpdateRequest {
	return ApiPropertymappingsRacPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return RACPropertyMapping
func (a *PropertymappingsApiService) PropertymappingsRacPartialUpdateExecute(r ApiPropertymappingsRacPartialUpdateRequest) (*RACPropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RACPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsRacPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/rac/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedRACPropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsRacRetrieveRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsRacRetrieveRequest) Execute() (*RACPropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsRacRetrieveExecute(r)
}

/*
PropertymappingsRacRetrieve Method for PropertymappingsRacRetrieve

RACPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this RAC Property Mapping.
	@return ApiPropertymappingsRacRetrieveRequest
*/
func (a *PropertymappingsApiService) PropertymappingsRacRetrieve(ctx context.Context, pmUuid string) ApiPropertymappingsRacRetrieveRequest {
	return ApiPropertymappingsRacRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return RACPropertyMapping
func (a *PropertymappingsApiService) PropertymappingsRacRetrieveExecute(r ApiPropertymappingsRacRetrieveRequest) (*RACPropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RACPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsRacRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/rac/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsRacUpdateRequest struct {
	ctx                       context.Context
	ApiService                *PropertymappingsApiService
	pmUuid                    string
	rACPropertyMappingRequest *RACPropertyMappingRequest
}

func (r ApiPropertymappingsRacUpdateRequest) RACPropertyMappingRequest(rACPropertyMappingRequest RACPropertyMappingRequest) ApiPropertymappingsRacUpdateRequest {
	r.rACPropertyMappingRequest = &rACPropertyMappingRequest
	return r
}

func (r ApiPropertymappingsRacUpdateRequest) Execute() (*RACPropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsRacUpdateExecute(r)
}

/*
PropertymappingsRacUpdate Method for PropertymappingsRacUpdate

RACPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this RAC Property Mapping.
	@return ApiPropertymappingsRacUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsRacUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsRacUpdateRequest {
	return ApiPropertymappingsRacUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return RACPropertyMapping
func (a *PropertymappingsApiService) PropertymappingsRacUpdateExecute(r ApiPropertymappingsRacUpdateRequest) (*RACPropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RACPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsRacUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/rac/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rACPropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("rACPropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rACPropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsRacUsedByListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsRacUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.PropertymappingsRacUsedByListExecute(r)
}

/*
PropertymappingsRacUsedByList Method for PropertymappingsRacUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this RAC Property Mapping.
	@return ApiPropertymappingsRacUsedByListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsRacUsedByList(ctx context.Context, pmUuid string) ApiPropertymappingsRacUsedByListRequest {
	return ApiPropertymappingsRacUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *PropertymappingsApiService) PropertymappingsRacUsedByListExecute(r ApiPropertymappingsRacUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsRacUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/rac/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsRadiusCreateRequest struct {
	ctx                                  context.Context
	ApiService                           *PropertymappingsApiService
	radiusProviderPropertyMappingRequest *RadiusProviderPropertyMappingRequest
}

func (r ApiPropertymappingsRadiusCreateRequest) RadiusProviderPropertyMappingRequest(radiusProviderPropertyMappingRequest RadiusProviderPropertyMappingRequest) ApiPropertymappingsRadiusCreateRequest {
	r.radiusProviderPropertyMappingRequest = &radiusProviderPropertyMappingRequest
	return r
}

func (r ApiPropertymappingsRadiusCreateRequest) Execute() (*RadiusProviderPropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsRadiusCreateExecute(r)
}

/*
PropertymappingsRadiusCreate Method for PropertymappingsRadiusCreate

RadiusProviderPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsRadiusCreateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsRadiusCreate(ctx context.Context) ApiPropertymappingsRadiusCreateRequest {
	return ApiPropertymappingsRadiusCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return RadiusProviderPropertyMapping
func (a *PropertymappingsApiService) PropertymappingsRadiusCreateExecute(r ApiPropertymappingsRadiusCreateRequest) (*RadiusProviderPropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RadiusProviderPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsRadiusCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/radius/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.radiusProviderPropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("radiusProviderPropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.radiusProviderPropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsRadiusDestroyRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsRadiusDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PropertymappingsRadiusDestroyExecute(r)
}

/*
PropertymappingsRadiusDestroy Method for PropertymappingsRadiusDestroy

RadiusProviderPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Radius Property Mapping.
	@return ApiPropertymappingsRadiusDestroyRequest
*/
func (a *PropertymappingsApiService) PropertymappingsRadiusDestroy(ctx context.Context, pmUuid string) ApiPropertymappingsRadiusDestroyRequest {
	return ApiPropertymappingsRadiusDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsApiService) PropertymappingsRadiusDestroyExecute(r ApiPropertymappingsRadiusDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsRadiusDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/radius/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsRadiusListRequest struct {
	ctx           context.Context
	ApiService    *PropertymappingsApiService
	managed       *[]string
	managedIsnull *bool
	name          *string
	ordering      *string
	page          *int32
	pageSize      *int32
	search        *string
}

func (r ApiPropertymappingsRadiusListRequest) Managed(managed []string) ApiPropertymappingsRadiusListRequest {
	r.managed = &managed
	return r
}

func (r ApiPropertymappingsRadiusListRequest) ManagedIsnull(managedIsnull bool) ApiPropertymappingsRadiusListRequest {
	r.managedIsnull = &managedIsnull
	return r
}

func (r ApiPropertymappingsRadiusListRequest) Name(name string) ApiPropertymappingsRadiusListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsRadiusListRequest) Ordering(ordering string) ApiPropertymappingsRadiusListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsRadiusListRequest) Page(page int32) ApiPropertymappingsRadiusListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsRadiusListRequest) PageSize(pageSize int32) ApiPropertymappingsRadiusListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiPropertymappingsRadiusListRequest) Search(search string) ApiPropertymappingsRadiusListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsRadiusListRequest) Execute() (*PaginatedRadiusProviderPropertyMappingList, *http.Response, error) {
	return r.ApiService.PropertymappingsRadiusListExecute(r)
}

/*
PropertymappingsRadiusList Method for PropertymappingsRadiusList

RadiusProviderPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsRadiusListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsRadiusList(ctx context.Context) ApiPropertymappingsRadiusListRequest {
	return ApiPropertymappingsRadiusListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedRadiusProviderPropertyMappingList
func (a *PropertymappingsApiService) PropertymappingsRadiusListExecute(r ApiPropertymappingsRadiusListRequest) (*PaginatedRadiusProviderPropertyMappingList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedRadiusProviderPropertyMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsRadiusList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/radius/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.managed != nil {
		t := *r.managed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("managed", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("managed", parameterToString(t, "multi"))
		}
	}
	if r.managedIsnull != nil {
		localVarQueryParams.Add("managed__isnull", parameterToString(*r.managedIsnull, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsRadiusPartialUpdateRequest struct {
	ctx                                         context.Context
	ApiService                                  *PropertymappingsApiService
	pmUuid                                      string
	patchedRadiusProviderPropertyMappingRequest *PatchedRadiusProviderPropertyMappingRequest
}

func (r ApiPropertymappingsRadiusPartialUpdateRequest) PatchedRadiusProviderPropertyMappingRequest(patchedRadiusProviderPropertyMappingRequest PatchedRadiusProviderPropertyMappingRequest) ApiPropertymappingsRadiusPartialUpdateRequest {
	r.patchedRadiusProviderPropertyMappingRequest = &patchedRadiusProviderPropertyMappingRequest
	return r
}

func (r ApiPropertymappingsRadiusPartialUpdateRequest) Execute() (*RadiusProviderPropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsRadiusPartialUpdateExecute(r)
}

/*
PropertymappingsRadiusPartialUpdate Method for PropertymappingsRadiusPartialUpdate

RadiusProviderPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Radius Property Mapping.
	@return ApiPropertymappingsRadiusPartialUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsRadiusPartialUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsRadiusPartialUpdateRequest {
	return ApiPropertymappingsRadiusPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return RadiusProviderPropertyMapping
func (a *PropertymappingsApiService) PropertymappingsRadiusPartialUpdateExecute(r ApiPropertymappingsRadiusPartialUpdateRequest) (*RadiusProviderPropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RadiusProviderPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsRadiusPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/radius/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedRadiusProviderPropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsRadiusRetrieveRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsRadiusRetrieveRequest) Execute() (*RadiusProviderPropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsRadiusRetrieveExecute(r)
}

/*
PropertymappingsRadiusRetrieve Method for PropertymappingsRadiusRetrieve

RadiusProviderPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Radius Property Mapping.
	@return ApiPropertymappingsRadiusRetrieveRequest
*/
func (a *PropertymappingsApiService) PropertymappingsRadiusRetrieve(ctx context.Context, pmUuid string) ApiPropertymappingsRadiusRetrieveRequest {
	return ApiPropertymappingsRadiusRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return RadiusProviderPropertyMapping
func (a *PropertymappingsApiService) PropertymappingsRadiusRetrieveExecute(r ApiPropertymappingsRadiusRetrieveRequest) (*RadiusProviderPropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RadiusProviderPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsRadiusRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/radius/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsRadiusUpdateRequest struct {
	ctx                                  context.Context
	ApiService                           *PropertymappingsApiService
	pmUuid                               string
	radiusProviderPropertyMappingRequest *RadiusProviderPropertyMappingRequest
}

func (r ApiPropertymappingsRadiusUpdateRequest) RadiusProviderPropertyMappingRequest(radiusProviderPropertyMappingRequest RadiusProviderPropertyMappingRequest) ApiPropertymappingsRadiusUpdateRequest {
	r.radiusProviderPropertyMappingRequest = &radiusProviderPropertyMappingRequest
	return r
}

func (r ApiPropertymappingsRadiusUpdateRequest) Execute() (*RadiusProviderPropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsRadiusUpdateExecute(r)
}

/*
PropertymappingsRadiusUpdate Method for PropertymappingsRadiusUpdate

RadiusProviderPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Radius Property Mapping.
	@return ApiPropertymappingsRadiusUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsRadiusUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsRadiusUpdateRequest {
	return ApiPropertymappingsRadiusUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return RadiusProviderPropertyMapping
func (a *PropertymappingsApiService) PropertymappingsRadiusUpdateExecute(r ApiPropertymappingsRadiusUpdateRequest) (*RadiusProviderPropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RadiusProviderPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsRadiusUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/radius/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.radiusProviderPropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("radiusProviderPropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.radiusProviderPropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsRadiusUsedByListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsRadiusUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.PropertymappingsRadiusUsedByListExecute(r)
}

/*
PropertymappingsRadiusUsedByList Method for PropertymappingsRadiusUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Radius Property Mapping.
	@return ApiPropertymappingsRadiusUsedByListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsRadiusUsedByList(ctx context.Context, pmUuid string) ApiPropertymappingsRadiusUsedByListRequest {
	return ApiPropertymappingsRadiusUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *PropertymappingsApiService) PropertymappingsRadiusUsedByListExecute(r ApiPropertymappingsRadiusUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsRadiusUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/radius/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSamlCreateRequest struct {
	ctx                        context.Context
	ApiService                 *PropertymappingsApiService
	sAMLPropertyMappingRequest *SAMLPropertyMappingRequest
}

func (r ApiPropertymappingsSamlCreateRequest) SAMLPropertyMappingRequest(sAMLPropertyMappingRequest SAMLPropertyMappingRequest) ApiPropertymappingsSamlCreateRequest {
	r.sAMLPropertyMappingRequest = &sAMLPropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSamlCreateRequest) Execute() (*SAMLPropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSamlCreateExecute(r)
}

/*
PropertymappingsSamlCreate Method for PropertymappingsSamlCreate

SAMLPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsSamlCreateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSamlCreate(ctx context.Context) ApiPropertymappingsSamlCreateRequest {
	return ApiPropertymappingsSamlCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SAMLPropertyMapping
func (a *PropertymappingsApiService) PropertymappingsSamlCreateExecute(r ApiPropertymappingsSamlCreateRequest) (*SAMLPropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SAMLPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSamlCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/saml/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sAMLPropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("sAMLPropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sAMLPropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSamlDestroyRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsSamlDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PropertymappingsSamlDestroyExecute(r)
}

/*
PropertymappingsSamlDestroy Method for PropertymappingsSamlDestroy

SAMLPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SAML Property Mapping.
	@return ApiPropertymappingsSamlDestroyRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSamlDestroy(ctx context.Context, pmUuid string) ApiPropertymappingsSamlDestroyRequest {
	return ApiPropertymappingsSamlDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsApiService) PropertymappingsSamlDestroyExecute(r ApiPropertymappingsSamlDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSamlDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/saml/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsSamlListRequest struct {
	ctx           context.Context
	ApiService    *PropertymappingsApiService
	friendlyName  *string
	managed       *[]string
	managedIsnull *bool
	name          *string
	ordering      *string
	page          *int32
	pageSize      *int32
	samlName      *string
	search        *string
}

func (r ApiPropertymappingsSamlListRequest) FriendlyName(friendlyName string) ApiPropertymappingsSamlListRequest {
	r.friendlyName = &friendlyName
	return r
}

func (r ApiPropertymappingsSamlListRequest) Managed(managed []string) ApiPropertymappingsSamlListRequest {
	r.managed = &managed
	return r
}

func (r ApiPropertymappingsSamlListRequest) ManagedIsnull(managedIsnull bool) ApiPropertymappingsSamlListRequest {
	r.managedIsnull = &managedIsnull
	return r
}

func (r ApiPropertymappingsSamlListRequest) Name(name string) ApiPropertymappingsSamlListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsSamlListRequest) Ordering(ordering string) ApiPropertymappingsSamlListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsSamlListRequest) Page(page int32) ApiPropertymappingsSamlListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsSamlListRequest) PageSize(pageSize int32) ApiPropertymappingsSamlListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiPropertymappingsSamlListRequest) SamlName(samlName string) ApiPropertymappingsSamlListRequest {
	r.samlName = &samlName
	return r
}

// A search term.
func (r ApiPropertymappingsSamlListRequest) Search(search string) ApiPropertymappingsSamlListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsSamlListRequest) Execute() (*PaginatedSAMLPropertyMappingList, *http.Response, error) {
	return r.ApiService.PropertymappingsSamlListExecute(r)
}

/*
PropertymappingsSamlList Method for PropertymappingsSamlList

SAMLPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsSamlListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSamlList(ctx context.Context) ApiPropertymappingsSamlListRequest {
	return ApiPropertymappingsSamlListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedSAMLPropertyMappingList
func (a *PropertymappingsApiService) PropertymappingsSamlListExecute(r ApiPropertymappingsSamlListRequest) (*PaginatedSAMLPropertyMappingList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedSAMLPropertyMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSamlList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/saml/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.friendlyName != nil {
		localVarQueryParams.Add("friendly_name", parameterToString(*r.friendlyName, ""))
	}
	if r.managed != nil {
		t := *r.managed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("managed", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("managed", parameterToString(t, "multi"))
		}
	}
	if r.managedIsnull != nil {
		localVarQueryParams.Add("managed__isnull", parameterToString(*r.managedIsnull, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.samlName != nil {
		localVarQueryParams.Add("saml_name", parameterToString(*r.samlName, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSamlPartialUpdateRequest struct {
	ctx                               context.Context
	ApiService                        *PropertymappingsApiService
	pmUuid                            string
	patchedSAMLPropertyMappingRequest *PatchedSAMLPropertyMappingRequest
}

func (r ApiPropertymappingsSamlPartialUpdateRequest) PatchedSAMLPropertyMappingRequest(patchedSAMLPropertyMappingRequest PatchedSAMLPropertyMappingRequest) ApiPropertymappingsSamlPartialUpdateRequest {
	r.patchedSAMLPropertyMappingRequest = &patchedSAMLPropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSamlPartialUpdateRequest) Execute() (*SAMLPropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSamlPartialUpdateExecute(r)
}

/*
PropertymappingsSamlPartialUpdate Method for PropertymappingsSamlPartialUpdate

SAMLPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SAML Property Mapping.
	@return ApiPropertymappingsSamlPartialUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSamlPartialUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsSamlPartialUpdateRequest {
	return ApiPropertymappingsSamlPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return SAMLPropertyMapping
func (a *PropertymappingsApiService) PropertymappingsSamlPartialUpdateExecute(r ApiPropertymappingsSamlPartialUpdateRequest) (*SAMLPropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SAMLPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSamlPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/saml/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedSAMLPropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSamlRetrieveRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsSamlRetrieveRequest) Execute() (*SAMLPropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSamlRetrieveExecute(r)
}

/*
PropertymappingsSamlRetrieve Method for PropertymappingsSamlRetrieve

SAMLPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SAML Property Mapping.
	@return ApiPropertymappingsSamlRetrieveRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSamlRetrieve(ctx context.Context, pmUuid string) ApiPropertymappingsSamlRetrieveRequest {
	return ApiPropertymappingsSamlRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return SAMLPropertyMapping
func (a *PropertymappingsApiService) PropertymappingsSamlRetrieveExecute(r ApiPropertymappingsSamlRetrieveRequest) (*SAMLPropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SAMLPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSamlRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/saml/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSamlUpdateRequest struct {
	ctx                        context.Context
	ApiService                 *PropertymappingsApiService
	pmUuid                     string
	sAMLPropertyMappingRequest *SAMLPropertyMappingRequest
}

func (r ApiPropertymappingsSamlUpdateRequest) SAMLPropertyMappingRequest(sAMLPropertyMappingRequest SAMLPropertyMappingRequest) ApiPropertymappingsSamlUpdateRequest {
	r.sAMLPropertyMappingRequest = &sAMLPropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSamlUpdateRequest) Execute() (*SAMLPropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSamlUpdateExecute(r)
}

/*
PropertymappingsSamlUpdate Method for PropertymappingsSamlUpdate

SAMLPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SAML Property Mapping.
	@return ApiPropertymappingsSamlUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSamlUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsSamlUpdateRequest {
	return ApiPropertymappingsSamlUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return SAMLPropertyMapping
func (a *PropertymappingsApiService) PropertymappingsSamlUpdateExecute(r ApiPropertymappingsSamlUpdateRequest) (*SAMLPropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SAMLPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSamlUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/saml/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sAMLPropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("sAMLPropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sAMLPropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSamlUsedByListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsSamlUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.PropertymappingsSamlUsedByListExecute(r)
}

/*
PropertymappingsSamlUsedByList Method for PropertymappingsSamlUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SAML Property Mapping.
	@return ApiPropertymappingsSamlUsedByListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSamlUsedByList(ctx context.Context, pmUuid string) ApiPropertymappingsSamlUsedByListRequest {
	return ApiPropertymappingsSamlUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *PropertymappingsApiService) PropertymappingsSamlUsedByListExecute(r ApiPropertymappingsSamlUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSamlUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/saml/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsScimCreateRequest struct {
	ctx                context.Context
	ApiService         *PropertymappingsApiService
	sCIMMappingRequest *SCIMMappingRequest
}

func (r ApiPropertymappingsScimCreateRequest) SCIMMappingRequest(sCIMMappingRequest SCIMMappingRequest) ApiPropertymappingsScimCreateRequest {
	r.sCIMMappingRequest = &sCIMMappingRequest
	return r
}

func (r ApiPropertymappingsScimCreateRequest) Execute() (*SCIMMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsScimCreateExecute(r)
}

/*
PropertymappingsScimCreate Method for PropertymappingsScimCreate

SCIMMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsScimCreateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsScimCreate(ctx context.Context) ApiPropertymappingsScimCreateRequest {
	return ApiPropertymappingsScimCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SCIMMapping
func (a *PropertymappingsApiService) PropertymappingsScimCreateExecute(r ApiPropertymappingsScimCreateRequest) (*SCIMMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SCIMMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsScimCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/scim/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sCIMMappingRequest == nil {
		return localVarReturnValue, nil, reportError("sCIMMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sCIMMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsScimDestroyRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsScimDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PropertymappingsScimDestroyExecute(r)
}

/*
PropertymappingsScimDestroy Method for PropertymappingsScimDestroy

SCIMMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SCIM Mapping.
	@return ApiPropertymappingsScimDestroyRequest
*/
func (a *PropertymappingsApiService) PropertymappingsScimDestroy(ctx context.Context, pmUuid string) ApiPropertymappingsScimDestroyRequest {
	return ApiPropertymappingsScimDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsApiService) PropertymappingsScimDestroyExecute(r ApiPropertymappingsScimDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsScimDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/scim/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsScimListRequest struct {
	ctx           context.Context
	ApiService    *PropertymappingsApiService
	managed       *[]string
	managedIsnull *bool
	name          *string
	ordering      *string
	page          *int32
	pageSize      *int32
	search        *string
}

func (r ApiPropertymappingsScimListRequest) Managed(managed []string) ApiPropertymappingsScimListRequest {
	r.managed = &managed
	return r
}

func (r ApiPropertymappingsScimListRequest) ManagedIsnull(managedIsnull bool) ApiPropertymappingsScimListRequest {
	r.managedIsnull = &managedIsnull
	return r
}

func (r ApiPropertymappingsScimListRequest) Name(name string) ApiPropertymappingsScimListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsScimListRequest) Ordering(ordering string) ApiPropertymappingsScimListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsScimListRequest) Page(page int32) ApiPropertymappingsScimListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsScimListRequest) PageSize(pageSize int32) ApiPropertymappingsScimListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiPropertymappingsScimListRequest) Search(search string) ApiPropertymappingsScimListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsScimListRequest) Execute() (*PaginatedSCIMMappingList, *http.Response, error) {
	return r.ApiService.PropertymappingsScimListExecute(r)
}

/*
PropertymappingsScimList Method for PropertymappingsScimList

SCIMMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsScimListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsScimList(ctx context.Context) ApiPropertymappingsScimListRequest {
	return ApiPropertymappingsScimListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedSCIMMappingList
func (a *PropertymappingsApiService) PropertymappingsScimListExecute(r ApiPropertymappingsScimListRequest) (*PaginatedSCIMMappingList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedSCIMMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsScimList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/scim/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.managed != nil {
		t := *r.managed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("managed", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("managed", parameterToString(t, "multi"))
		}
	}
	if r.managedIsnull != nil {
		localVarQueryParams.Add("managed__isnull", parameterToString(*r.managedIsnull, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsScimPartialUpdateRequest struct {
	ctx                       context.Context
	ApiService                *PropertymappingsApiService
	pmUuid                    string
	patchedSCIMMappingRequest *PatchedSCIMMappingRequest
}

func (r ApiPropertymappingsScimPartialUpdateRequest) PatchedSCIMMappingRequest(patchedSCIMMappingRequest PatchedSCIMMappingRequest) ApiPropertymappingsScimPartialUpdateRequest {
	r.patchedSCIMMappingRequest = &patchedSCIMMappingRequest
	return r
}

func (r ApiPropertymappingsScimPartialUpdateRequest) Execute() (*SCIMMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsScimPartialUpdateExecute(r)
}

/*
PropertymappingsScimPartialUpdate Method for PropertymappingsScimPartialUpdate

SCIMMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SCIM Mapping.
	@return ApiPropertymappingsScimPartialUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsScimPartialUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsScimPartialUpdateRequest {
	return ApiPropertymappingsScimPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return SCIMMapping
func (a *PropertymappingsApiService) PropertymappingsScimPartialUpdateExecute(r ApiPropertymappingsScimPartialUpdateRequest) (*SCIMMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SCIMMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsScimPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/scim/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedSCIMMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsScimRetrieveRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsScimRetrieveRequest) Execute() (*SCIMMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsScimRetrieveExecute(r)
}

/*
PropertymappingsScimRetrieve Method for PropertymappingsScimRetrieve

SCIMMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SCIM Mapping.
	@return ApiPropertymappingsScimRetrieveRequest
*/
func (a *PropertymappingsApiService) PropertymappingsScimRetrieve(ctx context.Context, pmUuid string) ApiPropertymappingsScimRetrieveRequest {
	return ApiPropertymappingsScimRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return SCIMMapping
func (a *PropertymappingsApiService) PropertymappingsScimRetrieveExecute(r ApiPropertymappingsScimRetrieveRequest) (*SCIMMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SCIMMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsScimRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/scim/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsScimUpdateRequest struct {
	ctx                context.Context
	ApiService         *PropertymappingsApiService
	pmUuid             string
	sCIMMappingRequest *SCIMMappingRequest
}

func (r ApiPropertymappingsScimUpdateRequest) SCIMMappingRequest(sCIMMappingRequest SCIMMappingRequest) ApiPropertymappingsScimUpdateRequest {
	r.sCIMMappingRequest = &sCIMMappingRequest
	return r
}

func (r ApiPropertymappingsScimUpdateRequest) Execute() (*SCIMMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsScimUpdateExecute(r)
}

/*
PropertymappingsScimUpdate Method for PropertymappingsScimUpdate

SCIMMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SCIM Mapping.
	@return ApiPropertymappingsScimUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsScimUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsScimUpdateRequest {
	return ApiPropertymappingsScimUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return SCIMMapping
func (a *PropertymappingsApiService) PropertymappingsScimUpdateExecute(r ApiPropertymappingsScimUpdateRequest) (*SCIMMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SCIMMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsScimUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/scim/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sCIMMappingRequest == nil {
		return localVarReturnValue, nil, reportError("sCIMMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sCIMMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsScimUsedByListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsScimUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.PropertymappingsScimUsedByListExecute(r)
}

/*
PropertymappingsScimUsedByList Method for PropertymappingsScimUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SCIM Mapping.
	@return ApiPropertymappingsScimUsedByListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsScimUsedByList(ctx context.Context, pmUuid string) ApiPropertymappingsScimUsedByListRequest {
	return ApiPropertymappingsScimUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *PropertymappingsApiService) PropertymappingsScimUsedByListExecute(r ApiPropertymappingsScimUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsScimUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/scim/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsScopeCreateRequest struct {
	ctx                 context.Context
	ApiService          *PropertymappingsApiService
	scopeMappingRequest *ScopeMappingRequest
}

func (r ApiPropertymappingsScopeCreateRequest) ScopeMappingRequest(scopeMappingRequest ScopeMappingRequest) ApiPropertymappingsScopeCreateRequest {
	r.scopeMappingRequest = &scopeMappingRequest
	return r
}

func (r ApiPropertymappingsScopeCreateRequest) Execute() (*ScopeMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsScopeCreateExecute(r)
}

/*
PropertymappingsScopeCreate Method for PropertymappingsScopeCreate

ScopeMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsScopeCreateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsScopeCreate(ctx context.Context) ApiPropertymappingsScopeCreateRequest {
	return ApiPropertymappingsScopeCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ScopeMapping
func (a *PropertymappingsApiService) PropertymappingsScopeCreateExecute(r ApiPropertymappingsScopeCreateRequest) (*ScopeMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ScopeMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsScopeCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/scope/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.scopeMappingRequest == nil {
		return localVarReturnValue, nil, reportError("scopeMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.scopeMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsScopeDestroyRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsScopeDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PropertymappingsScopeDestroyExecute(r)
}

/*
PropertymappingsScopeDestroy Method for PropertymappingsScopeDestroy

ScopeMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Scope Mapping.
	@return ApiPropertymappingsScopeDestroyRequest
*/
func (a *PropertymappingsApiService) PropertymappingsScopeDestroy(ctx context.Context, pmUuid string) ApiPropertymappingsScopeDestroyRequest {
	return ApiPropertymappingsScopeDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsApiService) PropertymappingsScopeDestroyExecute(r ApiPropertymappingsScopeDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsScopeDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/scope/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsScopeListRequest struct {
	ctx           context.Context
	ApiService    *PropertymappingsApiService
	managed       *[]string
	managedIsnull *bool
	name          *string
	ordering      *string
	page          *int32
	pageSize      *int32
	scopeName     *string
	search        *string
}

func (r ApiPropertymappingsScopeListRequest) Managed(managed []string) ApiPropertymappingsScopeListRequest {
	r.managed = &managed
	return r
}

func (r ApiPropertymappingsScopeListRequest) ManagedIsnull(managedIsnull bool) ApiPropertymappingsScopeListRequest {
	r.managedIsnull = &managedIsnull
	return r
}

func (r ApiPropertymappingsScopeListRequest) Name(name string) ApiPropertymappingsScopeListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsScopeListRequest) Ordering(ordering string) ApiPropertymappingsScopeListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsScopeListRequest) Page(page int32) ApiPropertymappingsScopeListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsScopeListRequest) PageSize(pageSize int32) ApiPropertymappingsScopeListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiPropertymappingsScopeListRequest) ScopeName(scopeName string) ApiPropertymappingsScopeListRequest {
	r.scopeName = &scopeName
	return r
}

// A search term.
func (r ApiPropertymappingsScopeListRequest) Search(search string) ApiPropertymappingsScopeListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsScopeListRequest) Execute() (*PaginatedScopeMappingList, *http.Response, error) {
	return r.ApiService.PropertymappingsScopeListExecute(r)
}

/*
PropertymappingsScopeList Method for PropertymappingsScopeList

ScopeMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsScopeListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsScopeList(ctx context.Context) ApiPropertymappingsScopeListRequest {
	return ApiPropertymappingsScopeListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedScopeMappingList
func (a *PropertymappingsApiService) PropertymappingsScopeListExecute(r ApiPropertymappingsScopeListRequest) (*PaginatedScopeMappingList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedScopeMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsScopeList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/scope/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.managed != nil {
		t := *r.managed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("managed", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("managed", parameterToString(t, "multi"))
		}
	}
	if r.managedIsnull != nil {
		localVarQueryParams.Add("managed__isnull", parameterToString(*r.managedIsnull, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.scopeName != nil {
		localVarQueryParams.Add("scope_name", parameterToString(*r.scopeName, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsScopePartialUpdateRequest struct {
	ctx                        context.Context
	ApiService                 *PropertymappingsApiService
	pmUuid                     string
	patchedScopeMappingRequest *PatchedScopeMappingRequest
}

func (r ApiPropertymappingsScopePartialUpdateRequest) PatchedScopeMappingRequest(patchedScopeMappingRequest PatchedScopeMappingRequest) ApiPropertymappingsScopePartialUpdateRequest {
	r.patchedScopeMappingRequest = &patchedScopeMappingRequest
	return r
}

func (r ApiPropertymappingsScopePartialUpdateRequest) Execute() (*ScopeMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsScopePartialUpdateExecute(r)
}

/*
PropertymappingsScopePartialUpdate Method for PropertymappingsScopePartialUpdate

ScopeMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Scope Mapping.
	@return ApiPropertymappingsScopePartialUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsScopePartialUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsScopePartialUpdateRequest {
	return ApiPropertymappingsScopePartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return ScopeMapping
func (a *PropertymappingsApiService) PropertymappingsScopePartialUpdateExecute(r ApiPropertymappingsScopePartialUpdateRequest) (*ScopeMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ScopeMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsScopePartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/scope/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedScopeMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsScopeRetrieveRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsScopeRetrieveRequest) Execute() (*ScopeMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsScopeRetrieveExecute(r)
}

/*
PropertymappingsScopeRetrieve Method for PropertymappingsScopeRetrieve

ScopeMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Scope Mapping.
	@return ApiPropertymappingsScopeRetrieveRequest
*/
func (a *PropertymappingsApiService) PropertymappingsScopeRetrieve(ctx context.Context, pmUuid string) ApiPropertymappingsScopeRetrieveRequest {
	return ApiPropertymappingsScopeRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return ScopeMapping
func (a *PropertymappingsApiService) PropertymappingsScopeRetrieveExecute(r ApiPropertymappingsScopeRetrieveRequest) (*ScopeMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ScopeMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsScopeRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/scope/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsScopeUpdateRequest struct {
	ctx                 context.Context
	ApiService          *PropertymappingsApiService
	pmUuid              string
	scopeMappingRequest *ScopeMappingRequest
}

func (r ApiPropertymappingsScopeUpdateRequest) ScopeMappingRequest(scopeMappingRequest ScopeMappingRequest) ApiPropertymappingsScopeUpdateRequest {
	r.scopeMappingRequest = &scopeMappingRequest
	return r
}

func (r ApiPropertymappingsScopeUpdateRequest) Execute() (*ScopeMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsScopeUpdateExecute(r)
}

/*
PropertymappingsScopeUpdate Method for PropertymappingsScopeUpdate

ScopeMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Scope Mapping.
	@return ApiPropertymappingsScopeUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsScopeUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsScopeUpdateRequest {
	return ApiPropertymappingsScopeUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return ScopeMapping
func (a *PropertymappingsApiService) PropertymappingsScopeUpdateExecute(r ApiPropertymappingsScopeUpdateRequest) (*ScopeMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ScopeMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsScopeUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/scope/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.scopeMappingRequest == nil {
		return localVarReturnValue, nil, reportError("scopeMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.scopeMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsScopeUsedByListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsScopeUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.PropertymappingsScopeUsedByListExecute(r)
}

/*
PropertymappingsScopeUsedByList Method for PropertymappingsScopeUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Scope Mapping.
	@return ApiPropertymappingsScopeUsedByListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsScopeUsedByList(ctx context.Context, pmUuid string) ApiPropertymappingsScopeUsedByListRequest {
	return ApiPropertymappingsScopeUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *PropertymappingsApiService) PropertymappingsScopeUsedByListExecute(r ApiPropertymappingsScopeUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsScopeUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/scope/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceLdapCreateRequest struct {
	ctx                              context.Context
	ApiService                       *PropertymappingsApiService
	lDAPSourcePropertyMappingRequest *LDAPSourcePropertyMappingRequest
}

func (r ApiPropertymappingsSourceLdapCreateRequest) LDAPSourcePropertyMappingRequest(lDAPSourcePropertyMappingRequest LDAPSourcePropertyMappingRequest) ApiPropertymappingsSourceLdapCreateRequest {
	r.lDAPSourcePropertyMappingRequest = &lDAPSourcePropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSourceLdapCreateRequest) Execute() (*LDAPSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceLdapCreateExecute(r)
}

/*
PropertymappingsSourceLdapCreate Method for PropertymappingsSourceLdapCreate

LDAP PropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsSourceLdapCreateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSourceLdapCreate(ctx context.Context) ApiPropertymappingsSourceLdapCreateRequest {
	return ApiPropertymappingsSourceLdapCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return LDAPSourcePropertyMapping
func (a *PropertymappingsApiService) PropertymappingsSourceLdapCreateExecute(r ApiPropertymappingsSourceLdapCreateRequest) (*LDAPSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LDAPSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSourceLdapCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/ldap/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.lDAPSourcePropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("lDAPSourcePropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.lDAPSourcePropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceLdapDestroyRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsSourceLdapDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PropertymappingsSourceLdapDestroyExecute(r)
}

/*
PropertymappingsSourceLdapDestroy Method for PropertymappingsSourceLdapDestroy

LDAP PropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this LDAP Source Property Mapping.
	@return ApiPropertymappingsSourceLdapDestroyRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSourceLdapDestroy(ctx context.Context, pmUuid string) ApiPropertymappingsSourceLdapDestroyRequest {
	return ApiPropertymappingsSourceLdapDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsApiService) PropertymappingsSourceLdapDestroyExecute(r ApiPropertymappingsSourceLdapDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSourceLdapDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/ldap/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceLdapListRequest struct {
	ctx           context.Context
	ApiService    *PropertymappingsApiService
	managed       *[]string
	managedIsnull *bool
	name          *string
	ordering      *string
	page          *int32
	pageSize      *int32
	search        *string
}

func (r ApiPropertymappingsSourceLdapListRequest) Managed(managed []string) ApiPropertymappingsSourceLdapListRequest {
	r.managed = &managed
	return r
}

func (r ApiPropertymappingsSourceLdapListRequest) ManagedIsnull(managedIsnull bool) ApiPropertymappingsSourceLdapListRequest {
	r.managedIsnull = &managedIsnull
	return r
}

func (r ApiPropertymappingsSourceLdapListRequest) Name(name string) ApiPropertymappingsSourceLdapListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsSourceLdapListRequest) Ordering(ordering string) ApiPropertymappingsSourceLdapListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsSourceLdapListRequest) Page(page int32) ApiPropertymappingsSourceLdapListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsSourceLdapListRequest) PageSize(pageSize int32) ApiPropertymappingsSourceLdapListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiPropertymappingsSourceLdapListRequest) Search(search string) ApiPropertymappingsSourceLdapListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsSourceLdapListRequest) Execute() (*PaginatedLDAPSourcePropertyMappingList, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceLdapListExecute(r)
}

/*
PropertymappingsSourceLdapList Method for PropertymappingsSourceLdapList

LDAP PropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsSourceLdapListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSourceLdapList(ctx context.Context) ApiPropertymappingsSourceLdapListRequest {
	return ApiPropertymappingsSourceLdapListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedLDAPSourcePropertyMappingList
func (a *PropertymappingsApiService) PropertymappingsSourceLdapListExecute(r ApiPropertymappingsSourceLdapListRequest) (*PaginatedLDAPSourcePropertyMappingList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedLDAPSourcePropertyMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSourceLdapList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/ldap/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.managed != nil {
		t := *r.managed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("managed", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("managed", parameterToString(t, "multi"))
		}
	}
	if r.managedIsnull != nil {
		localVarQueryParams.Add("managed__isnull", parameterToString(*r.managedIsnull, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceLdapPartialUpdateRequest struct {
	ctx                                     context.Context
	ApiService                              *PropertymappingsApiService
	pmUuid                                  string
	patchedLDAPSourcePropertyMappingRequest *PatchedLDAPSourcePropertyMappingRequest
}

func (r ApiPropertymappingsSourceLdapPartialUpdateRequest) PatchedLDAPSourcePropertyMappingRequest(patchedLDAPSourcePropertyMappingRequest PatchedLDAPSourcePropertyMappingRequest) ApiPropertymappingsSourceLdapPartialUpdateRequest {
	r.patchedLDAPSourcePropertyMappingRequest = &patchedLDAPSourcePropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSourceLdapPartialUpdateRequest) Execute() (*LDAPSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceLdapPartialUpdateExecute(r)
}

/*
PropertymappingsSourceLdapPartialUpdate Method for PropertymappingsSourceLdapPartialUpdate

LDAP PropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this LDAP Source Property Mapping.
	@return ApiPropertymappingsSourceLdapPartialUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSourceLdapPartialUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsSourceLdapPartialUpdateRequest {
	return ApiPropertymappingsSourceLdapPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return LDAPSourcePropertyMapping
func (a *PropertymappingsApiService) PropertymappingsSourceLdapPartialUpdateExecute(r ApiPropertymappingsSourceLdapPartialUpdateRequest) (*LDAPSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LDAPSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSourceLdapPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/ldap/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedLDAPSourcePropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceLdapRetrieveRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsSourceLdapRetrieveRequest) Execute() (*LDAPSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceLdapRetrieveExecute(r)
}

/*
PropertymappingsSourceLdapRetrieve Method for PropertymappingsSourceLdapRetrieve

LDAP PropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this LDAP Source Property Mapping.
	@return ApiPropertymappingsSourceLdapRetrieveRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSourceLdapRetrieve(ctx context.Context, pmUuid string) ApiPropertymappingsSourceLdapRetrieveRequest {
	return ApiPropertymappingsSourceLdapRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return LDAPSourcePropertyMapping
func (a *PropertymappingsApiService) PropertymappingsSourceLdapRetrieveExecute(r ApiPropertymappingsSourceLdapRetrieveRequest) (*LDAPSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LDAPSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSourceLdapRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/ldap/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceLdapUpdateRequest struct {
	ctx                              context.Context
	ApiService                       *PropertymappingsApiService
	pmUuid                           string
	lDAPSourcePropertyMappingRequest *LDAPSourcePropertyMappingRequest
}

func (r ApiPropertymappingsSourceLdapUpdateRequest) LDAPSourcePropertyMappingRequest(lDAPSourcePropertyMappingRequest LDAPSourcePropertyMappingRequest) ApiPropertymappingsSourceLdapUpdateRequest {
	r.lDAPSourcePropertyMappingRequest = &lDAPSourcePropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSourceLdapUpdateRequest) Execute() (*LDAPSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceLdapUpdateExecute(r)
}

/*
PropertymappingsSourceLdapUpdate Method for PropertymappingsSourceLdapUpdate

LDAP PropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this LDAP Source Property Mapping.
	@return ApiPropertymappingsSourceLdapUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSourceLdapUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsSourceLdapUpdateRequest {
	return ApiPropertymappingsSourceLdapUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return LDAPSourcePropertyMapping
func (a *PropertymappingsApiService) PropertymappingsSourceLdapUpdateExecute(r ApiPropertymappingsSourceLdapUpdateRequest) (*LDAPSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LDAPSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSourceLdapUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/ldap/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.lDAPSourcePropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("lDAPSourcePropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.lDAPSourcePropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceLdapUsedByListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsSourceLdapUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceLdapUsedByListExecute(r)
}

/*
PropertymappingsSourceLdapUsedByList Method for PropertymappingsSourceLdapUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this LDAP Source Property Mapping.
	@return ApiPropertymappingsSourceLdapUsedByListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSourceLdapUsedByList(ctx context.Context, pmUuid string) ApiPropertymappingsSourceLdapUsedByListRequest {
	return ApiPropertymappingsSourceLdapUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *PropertymappingsApiService) PropertymappingsSourceLdapUsedByListExecute(r ApiPropertymappingsSourceLdapUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSourceLdapUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/ldap/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceOauthCreateRequest struct {
	ctx                               context.Context
	ApiService                        *PropertymappingsApiService
	oAuthSourcePropertyMappingRequest *OAuthSourcePropertyMappingRequest
}

func (r ApiPropertymappingsSourceOauthCreateRequest) OAuthSourcePropertyMappingRequest(oAuthSourcePropertyMappingRequest OAuthSourcePropertyMappingRequest) ApiPropertymappingsSourceOauthCreateRequest {
	r.oAuthSourcePropertyMappingRequest = &oAuthSourcePropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSourceOauthCreateRequest) Execute() (*OAuthSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceOauthCreateExecute(r)
}

/*
PropertymappingsSourceOauthCreate Method for PropertymappingsSourceOauthCreate

OAuthSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsSourceOauthCreateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSourceOauthCreate(ctx context.Context) ApiPropertymappingsSourceOauthCreateRequest {
	return ApiPropertymappingsSourceOauthCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return OAuthSourcePropertyMapping
func (a *PropertymappingsApiService) PropertymappingsSourceOauthCreateExecute(r ApiPropertymappingsSourceOauthCreateRequest) (*OAuthSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OAuthSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSourceOauthCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/oauth/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.oAuthSourcePropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("oAuthSourcePropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.oAuthSourcePropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceOauthDestroyRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsSourceOauthDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PropertymappingsSourceOauthDestroyExecute(r)
}

/*
PropertymappingsSourceOauthDestroy Method for PropertymappingsSourceOauthDestroy

OAuthSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this OAuth Source Property Mapping.
	@return ApiPropertymappingsSourceOauthDestroyRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSourceOauthDestroy(ctx context.Context, pmUuid string) ApiPropertymappingsSourceOauthDestroyRequest {
	return ApiPropertymappingsSourceOauthDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsApiService) PropertymappingsSourceOauthDestroyExecute(r ApiPropertymappingsSourceOauthDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSourceOauthDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/oauth/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceOauthListRequest struct {
	ctx           context.Context
	ApiService    *PropertymappingsApiService
	managed       *[]string
	managedIsnull *bool
	name          *string
	ordering      *string
	page          *int32
	pageSize      *int32
	search        *string
}

func (r ApiPropertymappingsSourceOauthListRequest) Managed(managed []string) ApiPropertymappingsSourceOauthListRequest {
	r.managed = &managed
	return r
}

func (r ApiPropertymappingsSourceOauthListRequest) ManagedIsnull(managedIsnull bool) ApiPropertymappingsSourceOauthListRequest {
	r.managedIsnull = &managedIsnull
	return r
}

func (r ApiPropertymappingsSourceOauthListRequest) Name(name string) ApiPropertymappingsSourceOauthListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsSourceOauthListRequest) Ordering(ordering string) ApiPropertymappingsSourceOauthListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsSourceOauthListRequest) Page(page int32) ApiPropertymappingsSourceOauthListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsSourceOauthListRequest) PageSize(pageSize int32) ApiPropertymappingsSourceOauthListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiPropertymappingsSourceOauthListRequest) Search(search string) ApiPropertymappingsSourceOauthListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsSourceOauthListRequest) Execute() (*PaginatedOAuthSourcePropertyMappingList, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceOauthListExecute(r)
}

/*
PropertymappingsSourceOauthList Method for PropertymappingsSourceOauthList

OAuthSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsSourceOauthListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSourceOauthList(ctx context.Context) ApiPropertymappingsSourceOauthListRequest {
	return ApiPropertymappingsSourceOauthListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedOAuthSourcePropertyMappingList
func (a *PropertymappingsApiService) PropertymappingsSourceOauthListExecute(r ApiPropertymappingsSourceOauthListRequest) (*PaginatedOAuthSourcePropertyMappingList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedOAuthSourcePropertyMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSourceOauthList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/oauth/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.managed != nil {
		t := *r.managed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("managed", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("managed", parameterToString(t, "multi"))
		}
	}
	if r.managedIsnull != nil {
		localVarQueryParams.Add("managed__isnull", parameterToString(*r.managedIsnull, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceOauthPartialUpdateRequest struct {
	ctx                                      context.Context
	ApiService                               *PropertymappingsApiService
	pmUuid                                   string
	patchedOAuthSourcePropertyMappingRequest *PatchedOAuthSourcePropertyMappingRequest
}

func (r ApiPropertymappingsSourceOauthPartialUpdateRequest) PatchedOAuthSourcePropertyMappingRequest(patchedOAuthSourcePropertyMappingRequest PatchedOAuthSourcePropertyMappingRequest) ApiPropertymappingsSourceOauthPartialUpdateRequest {
	r.patchedOAuthSourcePropertyMappingRequest = &patchedOAuthSourcePropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSourceOauthPartialUpdateRequest) Execute() (*OAuthSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceOauthPartialUpdateExecute(r)
}

/*
PropertymappingsSourceOauthPartialUpdate Method for PropertymappingsSourceOauthPartialUpdate

OAuthSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this OAuth Source Property Mapping.
	@return ApiPropertymappingsSourceOauthPartialUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSourceOauthPartialUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsSourceOauthPartialUpdateRequest {
	return ApiPropertymappingsSourceOauthPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return OAuthSourcePropertyMapping
func (a *PropertymappingsApiService) PropertymappingsSourceOauthPartialUpdateExecute(r ApiPropertymappingsSourceOauthPartialUpdateRequest) (*OAuthSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OAuthSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSourceOauthPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/oauth/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedOAuthSourcePropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceOauthRetrieveRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsSourceOauthRetrieveRequest) Execute() (*OAuthSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceOauthRetrieveExecute(r)
}

/*
PropertymappingsSourceOauthRetrieve Method for PropertymappingsSourceOauthRetrieve

OAuthSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this OAuth Source Property Mapping.
	@return ApiPropertymappingsSourceOauthRetrieveRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSourceOauthRetrieve(ctx context.Context, pmUuid string) ApiPropertymappingsSourceOauthRetrieveRequest {
	return ApiPropertymappingsSourceOauthRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return OAuthSourcePropertyMapping
func (a *PropertymappingsApiService) PropertymappingsSourceOauthRetrieveExecute(r ApiPropertymappingsSourceOauthRetrieveRequest) (*OAuthSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OAuthSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSourceOauthRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/oauth/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceOauthUpdateRequest struct {
	ctx                               context.Context
	ApiService                        *PropertymappingsApiService
	pmUuid                            string
	oAuthSourcePropertyMappingRequest *OAuthSourcePropertyMappingRequest
}

func (r ApiPropertymappingsSourceOauthUpdateRequest) OAuthSourcePropertyMappingRequest(oAuthSourcePropertyMappingRequest OAuthSourcePropertyMappingRequest) ApiPropertymappingsSourceOauthUpdateRequest {
	r.oAuthSourcePropertyMappingRequest = &oAuthSourcePropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSourceOauthUpdateRequest) Execute() (*OAuthSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceOauthUpdateExecute(r)
}

/*
PropertymappingsSourceOauthUpdate Method for PropertymappingsSourceOauthUpdate

OAuthSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this OAuth Source Property Mapping.
	@return ApiPropertymappingsSourceOauthUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSourceOauthUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsSourceOauthUpdateRequest {
	return ApiPropertymappingsSourceOauthUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return OAuthSourcePropertyMapping
func (a *PropertymappingsApiService) PropertymappingsSourceOauthUpdateExecute(r ApiPropertymappingsSourceOauthUpdateRequest) (*OAuthSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OAuthSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSourceOauthUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/oauth/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.oAuthSourcePropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("oAuthSourcePropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.oAuthSourcePropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceOauthUsedByListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsSourceOauthUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceOauthUsedByListExecute(r)
}

/*
PropertymappingsSourceOauthUsedByList Method for PropertymappingsSourceOauthUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this OAuth Source Property Mapping.
	@return ApiPropertymappingsSourceOauthUsedByListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSourceOauthUsedByList(ctx context.Context, pmUuid string) ApiPropertymappingsSourceOauthUsedByListRequest {
	return ApiPropertymappingsSourceOauthUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *PropertymappingsApiService) PropertymappingsSourceOauthUsedByListExecute(r ApiPropertymappingsSourceOauthUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSourceOauthUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/oauth/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceSamlCreateRequest struct {
	ctx                              context.Context
	ApiService                       *PropertymappingsApiService
	sAMLSourcePropertyMappingRequest *SAMLSourcePropertyMappingRequest
}

func (r ApiPropertymappingsSourceSamlCreateRequest) SAMLSourcePropertyMappingRequest(sAMLSourcePropertyMappingRequest SAMLSourcePropertyMappingRequest) ApiPropertymappingsSourceSamlCreateRequest {
	r.sAMLSourcePropertyMappingRequest = &sAMLSourcePropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSourceSamlCreateRequest) Execute() (*SAMLSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceSamlCreateExecute(r)
}

/*
PropertymappingsSourceSamlCreate Method for PropertymappingsSourceSamlCreate

SAMLSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsSourceSamlCreateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSourceSamlCreate(ctx context.Context) ApiPropertymappingsSourceSamlCreateRequest {
	return ApiPropertymappingsSourceSamlCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SAMLSourcePropertyMapping
func (a *PropertymappingsApiService) PropertymappingsSourceSamlCreateExecute(r ApiPropertymappingsSourceSamlCreateRequest) (*SAMLSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SAMLSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSourceSamlCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/saml/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sAMLSourcePropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("sAMLSourcePropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sAMLSourcePropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceSamlDestroyRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsSourceSamlDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PropertymappingsSourceSamlDestroyExecute(r)
}

/*
PropertymappingsSourceSamlDestroy Method for PropertymappingsSourceSamlDestroy

SAMLSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SAML Source Property Mapping.
	@return ApiPropertymappingsSourceSamlDestroyRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSourceSamlDestroy(ctx context.Context, pmUuid string) ApiPropertymappingsSourceSamlDestroyRequest {
	return ApiPropertymappingsSourceSamlDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsApiService) PropertymappingsSourceSamlDestroyExecute(r ApiPropertymappingsSourceSamlDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSourceSamlDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/saml/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceSamlListRequest struct {
	ctx           context.Context
	ApiService    *PropertymappingsApiService
	managed       *[]string
	managedIsnull *bool
	name          *string
	ordering      *string
	page          *int32
	pageSize      *int32
	search        *string
}

func (r ApiPropertymappingsSourceSamlListRequest) Managed(managed []string) ApiPropertymappingsSourceSamlListRequest {
	r.managed = &managed
	return r
}

func (r ApiPropertymappingsSourceSamlListRequest) ManagedIsnull(managedIsnull bool) ApiPropertymappingsSourceSamlListRequest {
	r.managedIsnull = &managedIsnull
	return r
}

func (r ApiPropertymappingsSourceSamlListRequest) Name(name string) ApiPropertymappingsSourceSamlListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsSourceSamlListRequest) Ordering(ordering string) ApiPropertymappingsSourceSamlListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsSourceSamlListRequest) Page(page int32) ApiPropertymappingsSourceSamlListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsSourceSamlListRequest) PageSize(pageSize int32) ApiPropertymappingsSourceSamlListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiPropertymappingsSourceSamlListRequest) Search(search string) ApiPropertymappingsSourceSamlListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsSourceSamlListRequest) Execute() (*PaginatedSAMLSourcePropertyMappingList, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceSamlListExecute(r)
}

/*
PropertymappingsSourceSamlList Method for PropertymappingsSourceSamlList

SAMLSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsSourceSamlListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSourceSamlList(ctx context.Context) ApiPropertymappingsSourceSamlListRequest {
	return ApiPropertymappingsSourceSamlListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedSAMLSourcePropertyMappingList
func (a *PropertymappingsApiService) PropertymappingsSourceSamlListExecute(r ApiPropertymappingsSourceSamlListRequest) (*PaginatedSAMLSourcePropertyMappingList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedSAMLSourcePropertyMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSourceSamlList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/saml/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.managed != nil {
		t := *r.managed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("managed", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("managed", parameterToString(t, "multi"))
		}
	}
	if r.managedIsnull != nil {
		localVarQueryParams.Add("managed__isnull", parameterToString(*r.managedIsnull, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceSamlPartialUpdateRequest struct {
	ctx                                     context.Context
	ApiService                              *PropertymappingsApiService
	pmUuid                                  string
	patchedSAMLSourcePropertyMappingRequest *PatchedSAMLSourcePropertyMappingRequest
}

func (r ApiPropertymappingsSourceSamlPartialUpdateRequest) PatchedSAMLSourcePropertyMappingRequest(patchedSAMLSourcePropertyMappingRequest PatchedSAMLSourcePropertyMappingRequest) ApiPropertymappingsSourceSamlPartialUpdateRequest {
	r.patchedSAMLSourcePropertyMappingRequest = &patchedSAMLSourcePropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSourceSamlPartialUpdateRequest) Execute() (*SAMLSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceSamlPartialUpdateExecute(r)
}

/*
PropertymappingsSourceSamlPartialUpdate Method for PropertymappingsSourceSamlPartialUpdate

SAMLSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SAML Source Property Mapping.
	@return ApiPropertymappingsSourceSamlPartialUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSourceSamlPartialUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsSourceSamlPartialUpdateRequest {
	return ApiPropertymappingsSourceSamlPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return SAMLSourcePropertyMapping
func (a *PropertymappingsApiService) PropertymappingsSourceSamlPartialUpdateExecute(r ApiPropertymappingsSourceSamlPartialUpdateRequest) (*SAMLSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SAMLSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSourceSamlPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/saml/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedSAMLSourcePropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceSamlRetrieveRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsSourceSamlRetrieveRequest) Execute() (*SAMLSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceSamlRetrieveExecute(r)
}

/*
PropertymappingsSourceSamlRetrieve Method for PropertymappingsSourceSamlRetrieve

SAMLSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SAML Source Property Mapping.
	@return ApiPropertymappingsSourceSamlRetrieveRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSourceSamlRetrieve(ctx context.Context, pmUuid string) ApiPropertymappingsSourceSamlRetrieveRequest {
	return ApiPropertymappingsSourceSamlRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return SAMLSourcePropertyMapping
func (a *PropertymappingsApiService) PropertymappingsSourceSamlRetrieveExecute(r ApiPropertymappingsSourceSamlRetrieveRequest) (*SAMLSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SAMLSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSourceSamlRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/saml/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceSamlUpdateRequest struct {
	ctx                              context.Context
	ApiService                       *PropertymappingsApiService
	pmUuid                           string
	sAMLSourcePropertyMappingRequest *SAMLSourcePropertyMappingRequest
}

func (r ApiPropertymappingsSourceSamlUpdateRequest) SAMLSourcePropertyMappingRequest(sAMLSourcePropertyMappingRequest SAMLSourcePropertyMappingRequest) ApiPropertymappingsSourceSamlUpdateRequest {
	r.sAMLSourcePropertyMappingRequest = &sAMLSourcePropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSourceSamlUpdateRequest) Execute() (*SAMLSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceSamlUpdateExecute(r)
}

/*
PropertymappingsSourceSamlUpdate Method for PropertymappingsSourceSamlUpdate

SAMLSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SAML Source Property Mapping.
	@return ApiPropertymappingsSourceSamlUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSourceSamlUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsSourceSamlUpdateRequest {
	return ApiPropertymappingsSourceSamlUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return SAMLSourcePropertyMapping
func (a *PropertymappingsApiService) PropertymappingsSourceSamlUpdateExecute(r ApiPropertymappingsSourceSamlUpdateRequest) (*SAMLSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SAMLSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSourceSamlUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/saml/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sAMLSourcePropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("sAMLSourcePropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sAMLSourcePropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceSamlUsedByListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsSourceSamlUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceSamlUsedByListExecute(r)
}

/*
PropertymappingsSourceSamlUsedByList Method for PropertymappingsSourceSamlUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SAML Source Property Mapping.
	@return ApiPropertymappingsSourceSamlUsedByListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSourceSamlUsedByList(ctx context.Context, pmUuid string) ApiPropertymappingsSourceSamlUsedByListRequest {
	return ApiPropertymappingsSourceSamlUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *PropertymappingsApiService) PropertymappingsSourceSamlUsedByListExecute(r ApiPropertymappingsSourceSamlUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSourceSamlUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/saml/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceScimCreateRequest struct {
	ctx                              context.Context
	ApiService                       *PropertymappingsApiService
	sCIMSourcePropertyMappingRequest *SCIMSourcePropertyMappingRequest
}

func (r ApiPropertymappingsSourceScimCreateRequest) SCIMSourcePropertyMappingRequest(sCIMSourcePropertyMappingRequest SCIMSourcePropertyMappingRequest) ApiPropertymappingsSourceScimCreateRequest {
	r.sCIMSourcePropertyMappingRequest = &sCIMSourcePropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSourceScimCreateRequest) Execute() (*SCIMSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceScimCreateExecute(r)
}

/*
PropertymappingsSourceScimCreate Method for PropertymappingsSourceScimCreate

SCIMSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsSourceScimCreateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSourceScimCreate(ctx context.Context) ApiPropertymappingsSourceScimCreateRequest {
	return ApiPropertymappingsSourceScimCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SCIMSourcePropertyMapping
func (a *PropertymappingsApiService) PropertymappingsSourceScimCreateExecute(r ApiPropertymappingsSourceScimCreateRequest) (*SCIMSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SCIMSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSourceScimCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/scim/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sCIMSourcePropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("sCIMSourcePropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sCIMSourcePropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceScimDestroyRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsSourceScimDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PropertymappingsSourceScimDestroyExecute(r)
}

/*
PropertymappingsSourceScimDestroy Method for PropertymappingsSourceScimDestroy

SCIMSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SCIM Source Property Mapping.
	@return ApiPropertymappingsSourceScimDestroyRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSourceScimDestroy(ctx context.Context, pmUuid string) ApiPropertymappingsSourceScimDestroyRequest {
	return ApiPropertymappingsSourceScimDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsApiService) PropertymappingsSourceScimDestroyExecute(r ApiPropertymappingsSourceScimDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSourceScimDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/scim/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceScimListRequest struct {
	ctx           context.Context
	ApiService    *PropertymappingsApiService
	managed       *[]string
	managedIsnull *bool
	name          *string
	ordering      *string
	page          *int32
	pageSize      *int32
	search        *string
}

func (r ApiPropertymappingsSourceScimListRequest) Managed(managed []string) ApiPropertymappingsSourceScimListRequest {
	r.managed = &managed
	return r
}

func (r ApiPropertymappingsSourceScimListRequest) ManagedIsnull(managedIsnull bool) ApiPropertymappingsSourceScimListRequest {
	r.managedIsnull = &managedIsnull
	return r
}

func (r ApiPropertymappingsSourceScimListRequest) Name(name string) ApiPropertymappingsSourceScimListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsSourceScimListRequest) Ordering(ordering string) ApiPropertymappingsSourceScimListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsSourceScimListRequest) Page(page int32) ApiPropertymappingsSourceScimListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsSourceScimListRequest) PageSize(pageSize int32) ApiPropertymappingsSourceScimListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiPropertymappingsSourceScimListRequest) Search(search string) ApiPropertymappingsSourceScimListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsSourceScimListRequest) Execute() (*PaginatedSCIMSourcePropertyMappingList, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceScimListExecute(r)
}

/*
PropertymappingsSourceScimList Method for PropertymappingsSourceScimList

SCIMSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsSourceScimListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSourceScimList(ctx context.Context) ApiPropertymappingsSourceScimListRequest {
	return ApiPropertymappingsSourceScimListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedSCIMSourcePropertyMappingList
func (a *PropertymappingsApiService) PropertymappingsSourceScimListExecute(r ApiPropertymappingsSourceScimListRequest) (*PaginatedSCIMSourcePropertyMappingList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedSCIMSourcePropertyMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSourceScimList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/scim/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.managed != nil {
		t := *r.managed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("managed", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("managed", parameterToString(t, "multi"))
		}
	}
	if r.managedIsnull != nil {
		localVarQueryParams.Add("managed__isnull", parameterToString(*r.managedIsnull, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceScimPartialUpdateRequest struct {
	ctx                                     context.Context
	ApiService                              *PropertymappingsApiService
	pmUuid                                  string
	patchedSCIMSourcePropertyMappingRequest *PatchedSCIMSourcePropertyMappingRequest
}

func (r ApiPropertymappingsSourceScimPartialUpdateRequest) PatchedSCIMSourcePropertyMappingRequest(patchedSCIMSourcePropertyMappingRequest PatchedSCIMSourcePropertyMappingRequest) ApiPropertymappingsSourceScimPartialUpdateRequest {
	r.patchedSCIMSourcePropertyMappingRequest = &patchedSCIMSourcePropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSourceScimPartialUpdateRequest) Execute() (*SCIMSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceScimPartialUpdateExecute(r)
}

/*
PropertymappingsSourceScimPartialUpdate Method for PropertymappingsSourceScimPartialUpdate

SCIMSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SCIM Source Property Mapping.
	@return ApiPropertymappingsSourceScimPartialUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSourceScimPartialUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsSourceScimPartialUpdateRequest {
	return ApiPropertymappingsSourceScimPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return SCIMSourcePropertyMapping
func (a *PropertymappingsApiService) PropertymappingsSourceScimPartialUpdateExecute(r ApiPropertymappingsSourceScimPartialUpdateRequest) (*SCIMSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SCIMSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSourceScimPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/scim/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedSCIMSourcePropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceScimRetrieveRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsSourceScimRetrieveRequest) Execute() (*SCIMSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceScimRetrieveExecute(r)
}

/*
PropertymappingsSourceScimRetrieve Method for PropertymappingsSourceScimRetrieve

SCIMSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SCIM Source Property Mapping.
	@return ApiPropertymappingsSourceScimRetrieveRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSourceScimRetrieve(ctx context.Context, pmUuid string) ApiPropertymappingsSourceScimRetrieveRequest {
	return ApiPropertymappingsSourceScimRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return SCIMSourcePropertyMapping
func (a *PropertymappingsApiService) PropertymappingsSourceScimRetrieveExecute(r ApiPropertymappingsSourceScimRetrieveRequest) (*SCIMSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SCIMSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSourceScimRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/scim/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceScimUpdateRequest struct {
	ctx                              context.Context
	ApiService                       *PropertymappingsApiService
	pmUuid                           string
	sCIMSourcePropertyMappingRequest *SCIMSourcePropertyMappingRequest
}

func (r ApiPropertymappingsSourceScimUpdateRequest) SCIMSourcePropertyMappingRequest(sCIMSourcePropertyMappingRequest SCIMSourcePropertyMappingRequest) ApiPropertymappingsSourceScimUpdateRequest {
	r.sCIMSourcePropertyMappingRequest = &sCIMSourcePropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSourceScimUpdateRequest) Execute() (*SCIMSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceScimUpdateExecute(r)
}

/*
PropertymappingsSourceScimUpdate Method for PropertymappingsSourceScimUpdate

SCIMSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SCIM Source Property Mapping.
	@return ApiPropertymappingsSourceScimUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSourceScimUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsSourceScimUpdateRequest {
	return ApiPropertymappingsSourceScimUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return SCIMSourcePropertyMapping
func (a *PropertymappingsApiService) PropertymappingsSourceScimUpdateExecute(r ApiPropertymappingsSourceScimUpdateRequest) (*SCIMSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SCIMSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSourceScimUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/scim/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sCIMSourcePropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("sCIMSourcePropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sCIMSourcePropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceScimUsedByListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsSourceScimUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceScimUsedByListExecute(r)
}

/*
PropertymappingsSourceScimUsedByList Method for PropertymappingsSourceScimUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SCIM Source Property Mapping.
	@return ApiPropertymappingsSourceScimUsedByListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSourceScimUsedByList(ctx context.Context, pmUuid string) ApiPropertymappingsSourceScimUsedByListRequest {
	return ApiPropertymappingsSourceScimUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *PropertymappingsApiService) PropertymappingsSourceScimUsedByListExecute(r ApiPropertymappingsSourceScimUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSourceScimUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/scim/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
