/*
authentik

Making authentication simple.

API version: 2022.3.3
Contact: hello@beryju.org
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"reflect"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// PropertymappingsApiService PropertymappingsApi service
type PropertymappingsApiService service

type ApiPropertymappingsAllDestroyRequest struct {
	ctx        _context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsAllDestroyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PropertymappingsAllDestroyExecute(r)
}

/*
PropertymappingsAllDestroy Method for PropertymappingsAllDestroy

PropertyMapping Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pmUuid A UUID string identifying this Property Mapping.
 @return ApiPropertymappingsAllDestroyRequest
*/
func (a *PropertymappingsApiService) PropertymappingsAllDestroy(ctx _context.Context, pmUuid string) ApiPropertymappingsAllDestroyRequest {
	return ApiPropertymappingsAllDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsApiService) PropertymappingsAllDestroyExecute(r ApiPropertymappingsAllDestroyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsAllDestroy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/all/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", _neturl.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsAllListRequest struct {
	ctx           _context.Context
	ApiService    *PropertymappingsApiService
	managedIsnull *bool
	ordering      *string
	page          *int32
	pageSize      *int32
	search        *string
}

func (r ApiPropertymappingsAllListRequest) ManagedIsnull(managedIsnull bool) ApiPropertymappingsAllListRequest {
	r.managedIsnull = &managedIsnull
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsAllListRequest) Ordering(ordering string) ApiPropertymappingsAllListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsAllListRequest) Page(page int32) ApiPropertymappingsAllListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsAllListRequest) PageSize(pageSize int32) ApiPropertymappingsAllListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiPropertymappingsAllListRequest) Search(search string) ApiPropertymappingsAllListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsAllListRequest) Execute() (PaginatedPropertyMappingList, *_nethttp.Response, error) {
	return r.ApiService.PropertymappingsAllListExecute(r)
}

/*
PropertymappingsAllList Method for PropertymappingsAllList

PropertyMapping Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPropertymappingsAllListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsAllList(ctx _context.Context) ApiPropertymappingsAllListRequest {
	return ApiPropertymappingsAllListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaginatedPropertyMappingList
func (a *PropertymappingsApiService) PropertymappingsAllListExecute(r ApiPropertymappingsAllListRequest) (PaginatedPropertyMappingList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedPropertyMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsAllList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/all/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.managedIsnull != nil {
		localVarQueryParams.Add("managed__isnull", parameterToString(*r.managedIsnull, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsAllRetrieveRequest struct {
	ctx        _context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsAllRetrieveRequest) Execute() (PropertyMapping, *_nethttp.Response, error) {
	return r.ApiService.PropertymappingsAllRetrieveExecute(r)
}

/*
PropertymappingsAllRetrieve Method for PropertymappingsAllRetrieve

PropertyMapping Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pmUuid A UUID string identifying this Property Mapping.
 @return ApiPropertymappingsAllRetrieveRequest
*/
func (a *PropertymappingsApiService) PropertymappingsAllRetrieve(ctx _context.Context, pmUuid string) ApiPropertymappingsAllRetrieveRequest {
	return ApiPropertymappingsAllRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//  @return PropertyMapping
func (a *PropertymappingsApiService) PropertymappingsAllRetrieveExecute(r ApiPropertymappingsAllRetrieveRequest) (PropertyMapping, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsAllRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/all/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", _neturl.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsAllTestCreateRequest struct {
	ctx               _context.Context
	ApiService        *PropertymappingsApiService
	pmUuid            string
	policyTestRequest *PolicyTestRequest
	formatResult      *bool
}

func (r ApiPropertymappingsAllTestCreateRequest) PolicyTestRequest(policyTestRequest PolicyTestRequest) ApiPropertymappingsAllTestCreateRequest {
	r.policyTestRequest = &policyTestRequest
	return r
}
func (r ApiPropertymappingsAllTestCreateRequest) FormatResult(formatResult bool) ApiPropertymappingsAllTestCreateRequest {
	r.formatResult = &formatResult
	return r
}

func (r ApiPropertymappingsAllTestCreateRequest) Execute() (PropertyMappingTestResult, *_nethttp.Response, error) {
	return r.ApiService.PropertymappingsAllTestCreateExecute(r)
}

/*
PropertymappingsAllTestCreate Method for PropertymappingsAllTestCreate

Test Property Mapping

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pmUuid A UUID string identifying this Property Mapping.
 @return ApiPropertymappingsAllTestCreateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsAllTestCreate(ctx _context.Context, pmUuid string) ApiPropertymappingsAllTestCreateRequest {
	return ApiPropertymappingsAllTestCreateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//  @return PropertyMappingTestResult
func (a *PropertymappingsApiService) PropertymappingsAllTestCreateExecute(r ApiPropertymappingsAllTestCreateRequest) (PropertyMappingTestResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PropertyMappingTestResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsAllTestCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/all/{pm_uuid}/test/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", _neturl.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.policyTestRequest == nil {
		return localVarReturnValue, nil, reportError("policyTestRequest is required and must be specified")
	}

	if r.formatResult != nil {
		localVarQueryParams.Add("format_result", parameterToString(*r.formatResult, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.policyTestRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsAllTypesListRequest struct {
	ctx        _context.Context
	ApiService *PropertymappingsApiService
}

func (r ApiPropertymappingsAllTypesListRequest) Execute() ([]TypeCreate, *_nethttp.Response, error) {
	return r.ApiService.PropertymappingsAllTypesListExecute(r)
}

/*
PropertymappingsAllTypesList Method for PropertymappingsAllTypesList

Get all creatable property-mapping types

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPropertymappingsAllTypesListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsAllTypesList(ctx _context.Context) ApiPropertymappingsAllTypesListRequest {
	return ApiPropertymappingsAllTypesListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []TypeCreate
func (a *PropertymappingsApiService) PropertymappingsAllTypesListExecute(r ApiPropertymappingsAllTypesListRequest) ([]TypeCreate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []TypeCreate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsAllTypesList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/all/types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsAllUsedByListRequest struct {
	ctx        _context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsAllUsedByListRequest) Execute() ([]UsedBy, *_nethttp.Response, error) {
	return r.ApiService.PropertymappingsAllUsedByListExecute(r)
}

/*
PropertymappingsAllUsedByList Method for PropertymappingsAllUsedByList

Get a list of all objects that use this object

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pmUuid A UUID string identifying this Property Mapping.
 @return ApiPropertymappingsAllUsedByListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsAllUsedByList(ctx _context.Context, pmUuid string) ApiPropertymappingsAllUsedByListRequest {
	return ApiPropertymappingsAllUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//  @return []UsedBy
func (a *PropertymappingsApiService) PropertymappingsAllUsedByListExecute(r ApiPropertymappingsAllUsedByListRequest) ([]UsedBy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsAllUsedByList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/all/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", _neturl.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsLdapCreateRequest struct {
	ctx                        _context.Context
	ApiService                 *PropertymappingsApiService
	lDAPPropertyMappingRequest *LDAPPropertyMappingRequest
}

func (r ApiPropertymappingsLdapCreateRequest) LDAPPropertyMappingRequest(lDAPPropertyMappingRequest LDAPPropertyMappingRequest) ApiPropertymappingsLdapCreateRequest {
	r.lDAPPropertyMappingRequest = &lDAPPropertyMappingRequest
	return r
}

func (r ApiPropertymappingsLdapCreateRequest) Execute() (LDAPPropertyMapping, *_nethttp.Response, error) {
	return r.ApiService.PropertymappingsLdapCreateExecute(r)
}

/*
PropertymappingsLdapCreate Method for PropertymappingsLdapCreate

LDAP PropertyMapping Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPropertymappingsLdapCreateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsLdapCreate(ctx _context.Context) ApiPropertymappingsLdapCreateRequest {
	return ApiPropertymappingsLdapCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return LDAPPropertyMapping
func (a *PropertymappingsApiService) PropertymappingsLdapCreateExecute(r ApiPropertymappingsLdapCreateRequest) (LDAPPropertyMapping, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LDAPPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsLdapCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/ldap/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.lDAPPropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("lDAPPropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.lDAPPropertyMappingRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsLdapDestroyRequest struct {
	ctx        _context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsLdapDestroyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PropertymappingsLdapDestroyExecute(r)
}

/*
PropertymappingsLdapDestroy Method for PropertymappingsLdapDestroy

LDAP PropertyMapping Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pmUuid A UUID string identifying this LDAP Property Mapping.
 @return ApiPropertymappingsLdapDestroyRequest
*/
func (a *PropertymappingsApiService) PropertymappingsLdapDestroy(ctx _context.Context, pmUuid string) ApiPropertymappingsLdapDestroyRequest {
	return ApiPropertymappingsLdapDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsApiService) PropertymappingsLdapDestroyExecute(r ApiPropertymappingsLdapDestroyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsLdapDestroy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/ldap/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", _neturl.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsLdapListRequest struct {
	ctx         _context.Context
	ApiService  *PropertymappingsApiService
	expression  *string
	managed     *[]string
	name        *string
	objectField *string
	ordering    *string
	page        *int32
	pageSize    *int32
	pmUuid      *string
	search      *string
}

func (r ApiPropertymappingsLdapListRequest) Expression(expression string) ApiPropertymappingsLdapListRequest {
	r.expression = &expression
	return r
}
func (r ApiPropertymappingsLdapListRequest) Managed(managed []string) ApiPropertymappingsLdapListRequest {
	r.managed = &managed
	return r
}
func (r ApiPropertymappingsLdapListRequest) Name(name string) ApiPropertymappingsLdapListRequest {
	r.name = &name
	return r
}
func (r ApiPropertymappingsLdapListRequest) ObjectField(objectField string) ApiPropertymappingsLdapListRequest {
	r.objectField = &objectField
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsLdapListRequest) Ordering(ordering string) ApiPropertymappingsLdapListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsLdapListRequest) Page(page int32) ApiPropertymappingsLdapListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsLdapListRequest) PageSize(pageSize int32) ApiPropertymappingsLdapListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiPropertymappingsLdapListRequest) PmUuid(pmUuid string) ApiPropertymappingsLdapListRequest {
	r.pmUuid = &pmUuid
	return r
}

// A search term.
func (r ApiPropertymappingsLdapListRequest) Search(search string) ApiPropertymappingsLdapListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsLdapListRequest) Execute() (PaginatedLDAPPropertyMappingList, *_nethttp.Response, error) {
	return r.ApiService.PropertymappingsLdapListExecute(r)
}

/*
PropertymappingsLdapList Method for PropertymappingsLdapList

LDAP PropertyMapping Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPropertymappingsLdapListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsLdapList(ctx _context.Context) ApiPropertymappingsLdapListRequest {
	return ApiPropertymappingsLdapListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaginatedLDAPPropertyMappingList
func (a *PropertymappingsApiService) PropertymappingsLdapListExecute(r ApiPropertymappingsLdapListRequest) (PaginatedLDAPPropertyMappingList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedLDAPPropertyMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsLdapList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/ldap/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.expression != nil {
		localVarQueryParams.Add("expression", parameterToString(*r.expression, ""))
	}
	if r.managed != nil {
		t := *r.managed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("managed", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("managed", parameterToString(t, "multi"))
		}
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.objectField != nil {
		localVarQueryParams.Add("object_field", parameterToString(*r.objectField, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pmUuid != nil {
		localVarQueryParams.Add("pm_uuid", parameterToString(*r.pmUuid, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsLdapPartialUpdateRequest struct {
	ctx                               _context.Context
	ApiService                        *PropertymappingsApiService
	pmUuid                            string
	patchedLDAPPropertyMappingRequest *PatchedLDAPPropertyMappingRequest
}

func (r ApiPropertymappingsLdapPartialUpdateRequest) PatchedLDAPPropertyMappingRequest(patchedLDAPPropertyMappingRequest PatchedLDAPPropertyMappingRequest) ApiPropertymappingsLdapPartialUpdateRequest {
	r.patchedLDAPPropertyMappingRequest = &patchedLDAPPropertyMappingRequest
	return r
}

func (r ApiPropertymappingsLdapPartialUpdateRequest) Execute() (LDAPPropertyMapping, *_nethttp.Response, error) {
	return r.ApiService.PropertymappingsLdapPartialUpdateExecute(r)
}

/*
PropertymappingsLdapPartialUpdate Method for PropertymappingsLdapPartialUpdate

LDAP PropertyMapping Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pmUuid A UUID string identifying this LDAP Property Mapping.
 @return ApiPropertymappingsLdapPartialUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsLdapPartialUpdate(ctx _context.Context, pmUuid string) ApiPropertymappingsLdapPartialUpdateRequest {
	return ApiPropertymappingsLdapPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//  @return LDAPPropertyMapping
func (a *PropertymappingsApiService) PropertymappingsLdapPartialUpdateExecute(r ApiPropertymappingsLdapPartialUpdateRequest) (LDAPPropertyMapping, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LDAPPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsLdapPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/ldap/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", _neturl.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedLDAPPropertyMappingRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsLdapRetrieveRequest struct {
	ctx        _context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsLdapRetrieveRequest) Execute() (LDAPPropertyMapping, *_nethttp.Response, error) {
	return r.ApiService.PropertymappingsLdapRetrieveExecute(r)
}

/*
PropertymappingsLdapRetrieve Method for PropertymappingsLdapRetrieve

LDAP PropertyMapping Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pmUuid A UUID string identifying this LDAP Property Mapping.
 @return ApiPropertymappingsLdapRetrieveRequest
*/
func (a *PropertymappingsApiService) PropertymappingsLdapRetrieve(ctx _context.Context, pmUuid string) ApiPropertymappingsLdapRetrieveRequest {
	return ApiPropertymappingsLdapRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//  @return LDAPPropertyMapping
func (a *PropertymappingsApiService) PropertymappingsLdapRetrieveExecute(r ApiPropertymappingsLdapRetrieveRequest) (LDAPPropertyMapping, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LDAPPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsLdapRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/ldap/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", _neturl.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsLdapUpdateRequest struct {
	ctx                        _context.Context
	ApiService                 *PropertymappingsApiService
	pmUuid                     string
	lDAPPropertyMappingRequest *LDAPPropertyMappingRequest
}

func (r ApiPropertymappingsLdapUpdateRequest) LDAPPropertyMappingRequest(lDAPPropertyMappingRequest LDAPPropertyMappingRequest) ApiPropertymappingsLdapUpdateRequest {
	r.lDAPPropertyMappingRequest = &lDAPPropertyMappingRequest
	return r
}

func (r ApiPropertymappingsLdapUpdateRequest) Execute() (LDAPPropertyMapping, *_nethttp.Response, error) {
	return r.ApiService.PropertymappingsLdapUpdateExecute(r)
}

/*
PropertymappingsLdapUpdate Method for PropertymappingsLdapUpdate

LDAP PropertyMapping Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pmUuid A UUID string identifying this LDAP Property Mapping.
 @return ApiPropertymappingsLdapUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsLdapUpdate(ctx _context.Context, pmUuid string) ApiPropertymappingsLdapUpdateRequest {
	return ApiPropertymappingsLdapUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//  @return LDAPPropertyMapping
func (a *PropertymappingsApiService) PropertymappingsLdapUpdateExecute(r ApiPropertymappingsLdapUpdateRequest) (LDAPPropertyMapping, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LDAPPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsLdapUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/ldap/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", _neturl.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.lDAPPropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("lDAPPropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.lDAPPropertyMappingRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsLdapUsedByListRequest struct {
	ctx        _context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsLdapUsedByListRequest) Execute() ([]UsedBy, *_nethttp.Response, error) {
	return r.ApiService.PropertymappingsLdapUsedByListExecute(r)
}

/*
PropertymappingsLdapUsedByList Method for PropertymappingsLdapUsedByList

Get a list of all objects that use this object

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pmUuid A UUID string identifying this LDAP Property Mapping.
 @return ApiPropertymappingsLdapUsedByListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsLdapUsedByList(ctx _context.Context, pmUuid string) ApiPropertymappingsLdapUsedByListRequest {
	return ApiPropertymappingsLdapUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//  @return []UsedBy
func (a *PropertymappingsApiService) PropertymappingsLdapUsedByListExecute(r ApiPropertymappingsLdapUsedByListRequest) ([]UsedBy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsLdapUsedByList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/ldap/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", _neturl.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsNotificationCreateRequest struct {
	ctx                               _context.Context
	ApiService                        *PropertymappingsApiService
	notificationWebhookMappingRequest *NotificationWebhookMappingRequest
}

func (r ApiPropertymappingsNotificationCreateRequest) NotificationWebhookMappingRequest(notificationWebhookMappingRequest NotificationWebhookMappingRequest) ApiPropertymappingsNotificationCreateRequest {
	r.notificationWebhookMappingRequest = &notificationWebhookMappingRequest
	return r
}

func (r ApiPropertymappingsNotificationCreateRequest) Execute() (NotificationWebhookMapping, *_nethttp.Response, error) {
	return r.ApiService.PropertymappingsNotificationCreateExecute(r)
}

/*
PropertymappingsNotificationCreate Method for PropertymappingsNotificationCreate

NotificationWebhookMapping Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPropertymappingsNotificationCreateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsNotificationCreate(ctx _context.Context) ApiPropertymappingsNotificationCreateRequest {
	return ApiPropertymappingsNotificationCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return NotificationWebhookMapping
func (a *PropertymappingsApiService) PropertymappingsNotificationCreateExecute(r ApiPropertymappingsNotificationCreateRequest) (NotificationWebhookMapping, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationWebhookMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsNotificationCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/notification/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.notificationWebhookMappingRequest == nil {
		return localVarReturnValue, nil, reportError("notificationWebhookMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.notificationWebhookMappingRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsNotificationDestroyRequest struct {
	ctx        _context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsNotificationDestroyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PropertymappingsNotificationDestroyExecute(r)
}

/*
PropertymappingsNotificationDestroy Method for PropertymappingsNotificationDestroy

NotificationWebhookMapping Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pmUuid A UUID string identifying this Notification Webhook Mapping.
 @return ApiPropertymappingsNotificationDestroyRequest
*/
func (a *PropertymappingsApiService) PropertymappingsNotificationDestroy(ctx _context.Context, pmUuid string) ApiPropertymappingsNotificationDestroyRequest {
	return ApiPropertymappingsNotificationDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsApiService) PropertymappingsNotificationDestroyExecute(r ApiPropertymappingsNotificationDestroyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsNotificationDestroy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/notification/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", _neturl.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsNotificationListRequest struct {
	ctx        _context.Context
	ApiService *PropertymappingsApiService
	name       *string
	ordering   *string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiPropertymappingsNotificationListRequest) Name(name string) ApiPropertymappingsNotificationListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsNotificationListRequest) Ordering(ordering string) ApiPropertymappingsNotificationListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsNotificationListRequest) Page(page int32) ApiPropertymappingsNotificationListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsNotificationListRequest) PageSize(pageSize int32) ApiPropertymappingsNotificationListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiPropertymappingsNotificationListRequest) Search(search string) ApiPropertymappingsNotificationListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsNotificationListRequest) Execute() (PaginatedNotificationWebhookMappingList, *_nethttp.Response, error) {
	return r.ApiService.PropertymappingsNotificationListExecute(r)
}

/*
PropertymappingsNotificationList Method for PropertymappingsNotificationList

NotificationWebhookMapping Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPropertymappingsNotificationListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsNotificationList(ctx _context.Context) ApiPropertymappingsNotificationListRequest {
	return ApiPropertymappingsNotificationListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaginatedNotificationWebhookMappingList
func (a *PropertymappingsApiService) PropertymappingsNotificationListExecute(r ApiPropertymappingsNotificationListRequest) (PaginatedNotificationWebhookMappingList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedNotificationWebhookMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsNotificationList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/notification/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsNotificationPartialUpdateRequest struct {
	ctx                                      _context.Context
	ApiService                               *PropertymappingsApiService
	pmUuid                                   string
	patchedNotificationWebhookMappingRequest *PatchedNotificationWebhookMappingRequest
}

func (r ApiPropertymappingsNotificationPartialUpdateRequest) PatchedNotificationWebhookMappingRequest(patchedNotificationWebhookMappingRequest PatchedNotificationWebhookMappingRequest) ApiPropertymappingsNotificationPartialUpdateRequest {
	r.patchedNotificationWebhookMappingRequest = &patchedNotificationWebhookMappingRequest
	return r
}

func (r ApiPropertymappingsNotificationPartialUpdateRequest) Execute() (NotificationWebhookMapping, *_nethttp.Response, error) {
	return r.ApiService.PropertymappingsNotificationPartialUpdateExecute(r)
}

/*
PropertymappingsNotificationPartialUpdate Method for PropertymappingsNotificationPartialUpdate

NotificationWebhookMapping Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pmUuid A UUID string identifying this Notification Webhook Mapping.
 @return ApiPropertymappingsNotificationPartialUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsNotificationPartialUpdate(ctx _context.Context, pmUuid string) ApiPropertymappingsNotificationPartialUpdateRequest {
	return ApiPropertymappingsNotificationPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//  @return NotificationWebhookMapping
func (a *PropertymappingsApiService) PropertymappingsNotificationPartialUpdateExecute(r ApiPropertymappingsNotificationPartialUpdateRequest) (NotificationWebhookMapping, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationWebhookMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsNotificationPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/notification/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", _neturl.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedNotificationWebhookMappingRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsNotificationRetrieveRequest struct {
	ctx        _context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsNotificationRetrieveRequest) Execute() (NotificationWebhookMapping, *_nethttp.Response, error) {
	return r.ApiService.PropertymappingsNotificationRetrieveExecute(r)
}

/*
PropertymappingsNotificationRetrieve Method for PropertymappingsNotificationRetrieve

NotificationWebhookMapping Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pmUuid A UUID string identifying this Notification Webhook Mapping.
 @return ApiPropertymappingsNotificationRetrieveRequest
*/
func (a *PropertymappingsApiService) PropertymappingsNotificationRetrieve(ctx _context.Context, pmUuid string) ApiPropertymappingsNotificationRetrieveRequest {
	return ApiPropertymappingsNotificationRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//  @return NotificationWebhookMapping
func (a *PropertymappingsApiService) PropertymappingsNotificationRetrieveExecute(r ApiPropertymappingsNotificationRetrieveRequest) (NotificationWebhookMapping, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationWebhookMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsNotificationRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/notification/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", _neturl.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsNotificationUpdateRequest struct {
	ctx                               _context.Context
	ApiService                        *PropertymappingsApiService
	pmUuid                            string
	notificationWebhookMappingRequest *NotificationWebhookMappingRequest
}

func (r ApiPropertymappingsNotificationUpdateRequest) NotificationWebhookMappingRequest(notificationWebhookMappingRequest NotificationWebhookMappingRequest) ApiPropertymappingsNotificationUpdateRequest {
	r.notificationWebhookMappingRequest = &notificationWebhookMappingRequest
	return r
}

func (r ApiPropertymappingsNotificationUpdateRequest) Execute() (NotificationWebhookMapping, *_nethttp.Response, error) {
	return r.ApiService.PropertymappingsNotificationUpdateExecute(r)
}

/*
PropertymappingsNotificationUpdate Method for PropertymappingsNotificationUpdate

NotificationWebhookMapping Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pmUuid A UUID string identifying this Notification Webhook Mapping.
 @return ApiPropertymappingsNotificationUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsNotificationUpdate(ctx _context.Context, pmUuid string) ApiPropertymappingsNotificationUpdateRequest {
	return ApiPropertymappingsNotificationUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//  @return NotificationWebhookMapping
func (a *PropertymappingsApiService) PropertymappingsNotificationUpdateExecute(r ApiPropertymappingsNotificationUpdateRequest) (NotificationWebhookMapping, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationWebhookMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsNotificationUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/notification/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", _neturl.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.notificationWebhookMappingRequest == nil {
		return localVarReturnValue, nil, reportError("notificationWebhookMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.notificationWebhookMappingRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsNotificationUsedByListRequest struct {
	ctx        _context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsNotificationUsedByListRequest) Execute() ([]UsedBy, *_nethttp.Response, error) {
	return r.ApiService.PropertymappingsNotificationUsedByListExecute(r)
}

/*
PropertymappingsNotificationUsedByList Method for PropertymappingsNotificationUsedByList

Get a list of all objects that use this object

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pmUuid A UUID string identifying this Notification Webhook Mapping.
 @return ApiPropertymappingsNotificationUsedByListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsNotificationUsedByList(ctx _context.Context, pmUuid string) ApiPropertymappingsNotificationUsedByListRequest {
	return ApiPropertymappingsNotificationUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//  @return []UsedBy
func (a *PropertymappingsApiService) PropertymappingsNotificationUsedByListExecute(r ApiPropertymappingsNotificationUsedByListRequest) ([]UsedBy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsNotificationUsedByList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/notification/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", _neturl.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSamlCreateRequest struct {
	ctx                        _context.Context
	ApiService                 *PropertymappingsApiService
	sAMLPropertyMappingRequest *SAMLPropertyMappingRequest
}

func (r ApiPropertymappingsSamlCreateRequest) SAMLPropertyMappingRequest(sAMLPropertyMappingRequest SAMLPropertyMappingRequest) ApiPropertymappingsSamlCreateRequest {
	r.sAMLPropertyMappingRequest = &sAMLPropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSamlCreateRequest) Execute() (SAMLPropertyMapping, *_nethttp.Response, error) {
	return r.ApiService.PropertymappingsSamlCreateExecute(r)
}

/*
PropertymappingsSamlCreate Method for PropertymappingsSamlCreate

SAMLPropertyMapping Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPropertymappingsSamlCreateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSamlCreate(ctx _context.Context) ApiPropertymappingsSamlCreateRequest {
	return ApiPropertymappingsSamlCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return SAMLPropertyMapping
func (a *PropertymappingsApiService) PropertymappingsSamlCreateExecute(r ApiPropertymappingsSamlCreateRequest) (SAMLPropertyMapping, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SAMLPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSamlCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/saml/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.sAMLPropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("sAMLPropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sAMLPropertyMappingRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSamlDestroyRequest struct {
	ctx        _context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsSamlDestroyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PropertymappingsSamlDestroyExecute(r)
}

/*
PropertymappingsSamlDestroy Method for PropertymappingsSamlDestroy

SAMLPropertyMapping Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pmUuid A UUID string identifying this SAML Property Mapping.
 @return ApiPropertymappingsSamlDestroyRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSamlDestroy(ctx _context.Context, pmUuid string) ApiPropertymappingsSamlDestroyRequest {
	return ApiPropertymappingsSamlDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsApiService) PropertymappingsSamlDestroyExecute(r ApiPropertymappingsSamlDestroyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSamlDestroy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/saml/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", _neturl.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsSamlListRequest struct {
	ctx          _context.Context
	ApiService   *PropertymappingsApiService
	expression   *string
	friendlyName *string
	managed      *[]string
	name         *string
	ordering     *string
	page         *int32
	pageSize     *int32
	pmUuid       *string
	samlName     *string
	search       *string
}

func (r ApiPropertymappingsSamlListRequest) Expression(expression string) ApiPropertymappingsSamlListRequest {
	r.expression = &expression
	return r
}
func (r ApiPropertymappingsSamlListRequest) FriendlyName(friendlyName string) ApiPropertymappingsSamlListRequest {
	r.friendlyName = &friendlyName
	return r
}
func (r ApiPropertymappingsSamlListRequest) Managed(managed []string) ApiPropertymappingsSamlListRequest {
	r.managed = &managed
	return r
}
func (r ApiPropertymappingsSamlListRequest) Name(name string) ApiPropertymappingsSamlListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsSamlListRequest) Ordering(ordering string) ApiPropertymappingsSamlListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsSamlListRequest) Page(page int32) ApiPropertymappingsSamlListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsSamlListRequest) PageSize(pageSize int32) ApiPropertymappingsSamlListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiPropertymappingsSamlListRequest) PmUuid(pmUuid string) ApiPropertymappingsSamlListRequest {
	r.pmUuid = &pmUuid
	return r
}
func (r ApiPropertymappingsSamlListRequest) SamlName(samlName string) ApiPropertymappingsSamlListRequest {
	r.samlName = &samlName
	return r
}

// A search term.
func (r ApiPropertymappingsSamlListRequest) Search(search string) ApiPropertymappingsSamlListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsSamlListRequest) Execute() (PaginatedSAMLPropertyMappingList, *_nethttp.Response, error) {
	return r.ApiService.PropertymappingsSamlListExecute(r)
}

/*
PropertymappingsSamlList Method for PropertymappingsSamlList

SAMLPropertyMapping Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPropertymappingsSamlListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSamlList(ctx _context.Context) ApiPropertymappingsSamlListRequest {
	return ApiPropertymappingsSamlListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaginatedSAMLPropertyMappingList
func (a *PropertymappingsApiService) PropertymappingsSamlListExecute(r ApiPropertymappingsSamlListRequest) (PaginatedSAMLPropertyMappingList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedSAMLPropertyMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSamlList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/saml/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.expression != nil {
		localVarQueryParams.Add("expression", parameterToString(*r.expression, ""))
	}
	if r.friendlyName != nil {
		localVarQueryParams.Add("friendly_name", parameterToString(*r.friendlyName, ""))
	}
	if r.managed != nil {
		t := *r.managed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("managed", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("managed", parameterToString(t, "multi"))
		}
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pmUuid != nil {
		localVarQueryParams.Add("pm_uuid", parameterToString(*r.pmUuid, ""))
	}
	if r.samlName != nil {
		localVarQueryParams.Add("saml_name", parameterToString(*r.samlName, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSamlPartialUpdateRequest struct {
	ctx                               _context.Context
	ApiService                        *PropertymappingsApiService
	pmUuid                            string
	patchedSAMLPropertyMappingRequest *PatchedSAMLPropertyMappingRequest
}

func (r ApiPropertymappingsSamlPartialUpdateRequest) PatchedSAMLPropertyMappingRequest(patchedSAMLPropertyMappingRequest PatchedSAMLPropertyMappingRequest) ApiPropertymappingsSamlPartialUpdateRequest {
	r.patchedSAMLPropertyMappingRequest = &patchedSAMLPropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSamlPartialUpdateRequest) Execute() (SAMLPropertyMapping, *_nethttp.Response, error) {
	return r.ApiService.PropertymappingsSamlPartialUpdateExecute(r)
}

/*
PropertymappingsSamlPartialUpdate Method for PropertymappingsSamlPartialUpdate

SAMLPropertyMapping Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pmUuid A UUID string identifying this SAML Property Mapping.
 @return ApiPropertymappingsSamlPartialUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSamlPartialUpdate(ctx _context.Context, pmUuid string) ApiPropertymappingsSamlPartialUpdateRequest {
	return ApiPropertymappingsSamlPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//  @return SAMLPropertyMapping
func (a *PropertymappingsApiService) PropertymappingsSamlPartialUpdateExecute(r ApiPropertymappingsSamlPartialUpdateRequest) (SAMLPropertyMapping, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SAMLPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSamlPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/saml/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", _neturl.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedSAMLPropertyMappingRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSamlRetrieveRequest struct {
	ctx        _context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsSamlRetrieveRequest) Execute() (SAMLPropertyMapping, *_nethttp.Response, error) {
	return r.ApiService.PropertymappingsSamlRetrieveExecute(r)
}

/*
PropertymappingsSamlRetrieve Method for PropertymappingsSamlRetrieve

SAMLPropertyMapping Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pmUuid A UUID string identifying this SAML Property Mapping.
 @return ApiPropertymappingsSamlRetrieveRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSamlRetrieve(ctx _context.Context, pmUuid string) ApiPropertymappingsSamlRetrieveRequest {
	return ApiPropertymappingsSamlRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//  @return SAMLPropertyMapping
func (a *PropertymappingsApiService) PropertymappingsSamlRetrieveExecute(r ApiPropertymappingsSamlRetrieveRequest) (SAMLPropertyMapping, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SAMLPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSamlRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/saml/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", _neturl.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSamlUpdateRequest struct {
	ctx                        _context.Context
	ApiService                 *PropertymappingsApiService
	pmUuid                     string
	sAMLPropertyMappingRequest *SAMLPropertyMappingRequest
}

func (r ApiPropertymappingsSamlUpdateRequest) SAMLPropertyMappingRequest(sAMLPropertyMappingRequest SAMLPropertyMappingRequest) ApiPropertymappingsSamlUpdateRequest {
	r.sAMLPropertyMappingRequest = &sAMLPropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSamlUpdateRequest) Execute() (SAMLPropertyMapping, *_nethttp.Response, error) {
	return r.ApiService.PropertymappingsSamlUpdateExecute(r)
}

/*
PropertymappingsSamlUpdate Method for PropertymappingsSamlUpdate

SAMLPropertyMapping Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pmUuid A UUID string identifying this SAML Property Mapping.
 @return ApiPropertymappingsSamlUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSamlUpdate(ctx _context.Context, pmUuid string) ApiPropertymappingsSamlUpdateRequest {
	return ApiPropertymappingsSamlUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//  @return SAMLPropertyMapping
func (a *PropertymappingsApiService) PropertymappingsSamlUpdateExecute(r ApiPropertymappingsSamlUpdateRequest) (SAMLPropertyMapping, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SAMLPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSamlUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/saml/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", _neturl.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.sAMLPropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("sAMLPropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sAMLPropertyMappingRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSamlUsedByListRequest struct {
	ctx        _context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsSamlUsedByListRequest) Execute() ([]UsedBy, *_nethttp.Response, error) {
	return r.ApiService.PropertymappingsSamlUsedByListExecute(r)
}

/*
PropertymappingsSamlUsedByList Method for PropertymappingsSamlUsedByList

Get a list of all objects that use this object

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pmUuid A UUID string identifying this SAML Property Mapping.
 @return ApiPropertymappingsSamlUsedByListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsSamlUsedByList(ctx _context.Context, pmUuid string) ApiPropertymappingsSamlUsedByListRequest {
	return ApiPropertymappingsSamlUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//  @return []UsedBy
func (a *PropertymappingsApiService) PropertymappingsSamlUsedByListExecute(r ApiPropertymappingsSamlUsedByListRequest) ([]UsedBy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsSamlUsedByList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/saml/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", _neturl.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsScopeCreateRequest struct {
	ctx                 _context.Context
	ApiService          *PropertymappingsApiService
	scopeMappingRequest *ScopeMappingRequest
}

func (r ApiPropertymappingsScopeCreateRequest) ScopeMappingRequest(scopeMappingRequest ScopeMappingRequest) ApiPropertymappingsScopeCreateRequest {
	r.scopeMappingRequest = &scopeMappingRequest
	return r
}

func (r ApiPropertymappingsScopeCreateRequest) Execute() (ScopeMapping, *_nethttp.Response, error) {
	return r.ApiService.PropertymappingsScopeCreateExecute(r)
}

/*
PropertymappingsScopeCreate Method for PropertymappingsScopeCreate

ScopeMapping Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPropertymappingsScopeCreateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsScopeCreate(ctx _context.Context) ApiPropertymappingsScopeCreateRequest {
	return ApiPropertymappingsScopeCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ScopeMapping
func (a *PropertymappingsApiService) PropertymappingsScopeCreateExecute(r ApiPropertymappingsScopeCreateRequest) (ScopeMapping, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ScopeMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsScopeCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/scope/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.scopeMappingRequest == nil {
		return localVarReturnValue, nil, reportError("scopeMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.scopeMappingRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsScopeDestroyRequest struct {
	ctx        _context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsScopeDestroyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PropertymappingsScopeDestroyExecute(r)
}

/*
PropertymappingsScopeDestroy Method for PropertymappingsScopeDestroy

ScopeMapping Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pmUuid A UUID string identifying this Scope Mapping.
 @return ApiPropertymappingsScopeDestroyRequest
*/
func (a *PropertymappingsApiService) PropertymappingsScopeDestroy(ctx _context.Context, pmUuid string) ApiPropertymappingsScopeDestroyRequest {
	return ApiPropertymappingsScopeDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsApiService) PropertymappingsScopeDestroyExecute(r ApiPropertymappingsScopeDestroyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsScopeDestroy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/scope/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", _neturl.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsScopeListRequest struct {
	ctx        _context.Context
	ApiService *PropertymappingsApiService
	managed    *[]string
	name       *string
	ordering   *string
	page       *int32
	pageSize   *int32
	scopeName  *string
	search     *string
}

func (r ApiPropertymappingsScopeListRequest) Managed(managed []string) ApiPropertymappingsScopeListRequest {
	r.managed = &managed
	return r
}
func (r ApiPropertymappingsScopeListRequest) Name(name string) ApiPropertymappingsScopeListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsScopeListRequest) Ordering(ordering string) ApiPropertymappingsScopeListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsScopeListRequest) Page(page int32) ApiPropertymappingsScopeListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsScopeListRequest) PageSize(pageSize int32) ApiPropertymappingsScopeListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiPropertymappingsScopeListRequest) ScopeName(scopeName string) ApiPropertymappingsScopeListRequest {
	r.scopeName = &scopeName
	return r
}

// A search term.
func (r ApiPropertymappingsScopeListRequest) Search(search string) ApiPropertymappingsScopeListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsScopeListRequest) Execute() (PaginatedScopeMappingList, *_nethttp.Response, error) {
	return r.ApiService.PropertymappingsScopeListExecute(r)
}

/*
PropertymappingsScopeList Method for PropertymappingsScopeList

ScopeMapping Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPropertymappingsScopeListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsScopeList(ctx _context.Context) ApiPropertymappingsScopeListRequest {
	return ApiPropertymappingsScopeListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaginatedScopeMappingList
func (a *PropertymappingsApiService) PropertymappingsScopeListExecute(r ApiPropertymappingsScopeListRequest) (PaginatedScopeMappingList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedScopeMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsScopeList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/scope/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.managed != nil {
		t := *r.managed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("managed", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("managed", parameterToString(t, "multi"))
		}
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.scopeName != nil {
		localVarQueryParams.Add("scope_name", parameterToString(*r.scopeName, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsScopePartialUpdateRequest struct {
	ctx                        _context.Context
	ApiService                 *PropertymappingsApiService
	pmUuid                     string
	patchedScopeMappingRequest *PatchedScopeMappingRequest
}

func (r ApiPropertymappingsScopePartialUpdateRequest) PatchedScopeMappingRequest(patchedScopeMappingRequest PatchedScopeMappingRequest) ApiPropertymappingsScopePartialUpdateRequest {
	r.patchedScopeMappingRequest = &patchedScopeMappingRequest
	return r
}

func (r ApiPropertymappingsScopePartialUpdateRequest) Execute() (ScopeMapping, *_nethttp.Response, error) {
	return r.ApiService.PropertymappingsScopePartialUpdateExecute(r)
}

/*
PropertymappingsScopePartialUpdate Method for PropertymappingsScopePartialUpdate

ScopeMapping Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pmUuid A UUID string identifying this Scope Mapping.
 @return ApiPropertymappingsScopePartialUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsScopePartialUpdate(ctx _context.Context, pmUuid string) ApiPropertymappingsScopePartialUpdateRequest {
	return ApiPropertymappingsScopePartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//  @return ScopeMapping
func (a *PropertymappingsApiService) PropertymappingsScopePartialUpdateExecute(r ApiPropertymappingsScopePartialUpdateRequest) (ScopeMapping, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ScopeMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsScopePartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/scope/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", _neturl.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedScopeMappingRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsScopeRetrieveRequest struct {
	ctx        _context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsScopeRetrieveRequest) Execute() (ScopeMapping, *_nethttp.Response, error) {
	return r.ApiService.PropertymappingsScopeRetrieveExecute(r)
}

/*
PropertymappingsScopeRetrieve Method for PropertymappingsScopeRetrieve

ScopeMapping Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pmUuid A UUID string identifying this Scope Mapping.
 @return ApiPropertymappingsScopeRetrieveRequest
*/
func (a *PropertymappingsApiService) PropertymappingsScopeRetrieve(ctx _context.Context, pmUuid string) ApiPropertymappingsScopeRetrieveRequest {
	return ApiPropertymappingsScopeRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//  @return ScopeMapping
func (a *PropertymappingsApiService) PropertymappingsScopeRetrieveExecute(r ApiPropertymappingsScopeRetrieveRequest) (ScopeMapping, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ScopeMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsScopeRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/scope/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", _neturl.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsScopeUpdateRequest struct {
	ctx                 _context.Context
	ApiService          *PropertymappingsApiService
	pmUuid              string
	scopeMappingRequest *ScopeMappingRequest
}

func (r ApiPropertymappingsScopeUpdateRequest) ScopeMappingRequest(scopeMappingRequest ScopeMappingRequest) ApiPropertymappingsScopeUpdateRequest {
	r.scopeMappingRequest = &scopeMappingRequest
	return r
}

func (r ApiPropertymappingsScopeUpdateRequest) Execute() (ScopeMapping, *_nethttp.Response, error) {
	return r.ApiService.PropertymappingsScopeUpdateExecute(r)
}

/*
PropertymappingsScopeUpdate Method for PropertymappingsScopeUpdate

ScopeMapping Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pmUuid A UUID string identifying this Scope Mapping.
 @return ApiPropertymappingsScopeUpdateRequest
*/
func (a *PropertymappingsApiService) PropertymappingsScopeUpdate(ctx _context.Context, pmUuid string) ApiPropertymappingsScopeUpdateRequest {
	return ApiPropertymappingsScopeUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//  @return ScopeMapping
func (a *PropertymappingsApiService) PropertymappingsScopeUpdateExecute(r ApiPropertymappingsScopeUpdateRequest) (ScopeMapping, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ScopeMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsScopeUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/scope/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", _neturl.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.scopeMappingRequest == nil {
		return localVarReturnValue, nil, reportError("scopeMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.scopeMappingRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsScopeUsedByListRequest struct {
	ctx        _context.Context
	ApiService *PropertymappingsApiService
	pmUuid     string
}

func (r ApiPropertymappingsScopeUsedByListRequest) Execute() ([]UsedBy, *_nethttp.Response, error) {
	return r.ApiService.PropertymappingsScopeUsedByListExecute(r)
}

/*
PropertymappingsScopeUsedByList Method for PropertymappingsScopeUsedByList

Get a list of all objects that use this object

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pmUuid A UUID string identifying this Scope Mapping.
 @return ApiPropertymappingsScopeUsedByListRequest
*/
func (a *PropertymappingsApiService) PropertymappingsScopeUsedByList(ctx _context.Context, pmUuid string) ApiPropertymappingsScopeUsedByListRequest {
	return ApiPropertymappingsScopeUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//  @return []UsedBy
func (a *PropertymappingsApiService) PropertymappingsScopeUsedByListExecute(r ApiPropertymappingsScopeUsedByListRequest) ([]UsedBy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsApiService.PropertymappingsScopeUsedByList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/scope/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", _neturl.PathEscape(parameterToString(r.pmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
