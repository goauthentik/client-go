/*
authentik

Making authentication simple.

API version: 2024.10.2
Contact: hello@goauthentik.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// PropertymappingsAPIService PropertymappingsAPI service
type PropertymappingsAPIService service

type ApiPropertymappingsAllDestroyRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsAllDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PropertymappingsAllDestroyExecute(r)
}

/*
PropertymappingsAllDestroy Method for PropertymappingsAllDestroy

PropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Property Mapping.
	@return ApiPropertymappingsAllDestroyRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsAllDestroy(ctx context.Context, pmUuid string) ApiPropertymappingsAllDestroyRequest {
	return ApiPropertymappingsAllDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsAPIService) PropertymappingsAllDestroyExecute(r ApiPropertymappingsAllDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsAllDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/all/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsAllListRequest struct {
	ctx           context.Context
	ApiService    *PropertymappingsAPIService
	managed       *[]string
	managedIsnull *bool
	name          *string
	ordering      *string
	page          *int32
	pageSize      *int32
	search        *string
}

func (r ApiPropertymappingsAllListRequest) Managed(managed []string) ApiPropertymappingsAllListRequest {
	r.managed = &managed
	return r
}

func (r ApiPropertymappingsAllListRequest) ManagedIsnull(managedIsnull bool) ApiPropertymappingsAllListRequest {
	r.managedIsnull = &managedIsnull
	return r
}

func (r ApiPropertymappingsAllListRequest) Name(name string) ApiPropertymappingsAllListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsAllListRequest) Ordering(ordering string) ApiPropertymappingsAllListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsAllListRequest) Page(page int32) ApiPropertymappingsAllListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsAllListRequest) PageSize(pageSize int32) ApiPropertymappingsAllListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiPropertymappingsAllListRequest) Search(search string) ApiPropertymappingsAllListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsAllListRequest) Execute() (*PaginatedPropertyMappingList, *http.Response, error) {
	return r.ApiService.PropertymappingsAllListExecute(r)
}

/*
PropertymappingsAllList Method for PropertymappingsAllList

PropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsAllListRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsAllList(ctx context.Context) ApiPropertymappingsAllListRequest {
	return ApiPropertymappingsAllListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedPropertyMappingList
func (a *PropertymappingsAPIService) PropertymappingsAllListExecute(r ApiPropertymappingsAllListRequest) (*PaginatedPropertyMappingList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedPropertyMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsAllList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/all/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.managed != nil {
		t := *r.managed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "managed", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "managed", t, "form", "multi")
		}
	}
	if r.managedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "managed__isnull", r.managedIsnull, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsAllRetrieveRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsAllRetrieveRequest) Execute() (*PropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsAllRetrieveExecute(r)
}

/*
PropertymappingsAllRetrieve Method for PropertymappingsAllRetrieve

PropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Property Mapping.
	@return ApiPropertymappingsAllRetrieveRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsAllRetrieve(ctx context.Context, pmUuid string) ApiPropertymappingsAllRetrieveRequest {
	return ApiPropertymappingsAllRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return PropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsAllRetrieveExecute(r ApiPropertymappingsAllRetrieveRequest) (*PropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsAllRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/all/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsAllTestCreateRequest struct {
	ctx                        context.Context
	ApiService                 *PropertymappingsAPIService
	pmUuid                     string
	formatResult               *bool
	propertyMappingTestRequest *PropertyMappingTestRequest
}

func (r ApiPropertymappingsAllTestCreateRequest) FormatResult(formatResult bool) ApiPropertymappingsAllTestCreateRequest {
	r.formatResult = &formatResult
	return r
}

func (r ApiPropertymappingsAllTestCreateRequest) PropertyMappingTestRequest(propertyMappingTestRequest PropertyMappingTestRequest) ApiPropertymappingsAllTestCreateRequest {
	r.propertyMappingTestRequest = &propertyMappingTestRequest
	return r
}

func (r ApiPropertymappingsAllTestCreateRequest) Execute() (*PropertyMappingTestResult, *http.Response, error) {
	return r.ApiService.PropertymappingsAllTestCreateExecute(r)
}

/*
PropertymappingsAllTestCreate Method for PropertymappingsAllTestCreate

Test Property Mapping

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Property Mapping.
	@return ApiPropertymappingsAllTestCreateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsAllTestCreate(ctx context.Context, pmUuid string) ApiPropertymappingsAllTestCreateRequest {
	return ApiPropertymappingsAllTestCreateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return PropertyMappingTestResult
func (a *PropertymappingsAPIService) PropertymappingsAllTestCreateExecute(r ApiPropertymappingsAllTestCreateRequest) (*PropertyMappingTestResult, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PropertyMappingTestResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsAllTestCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/all/{pm_uuid}/test/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.formatResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format_result", r.formatResult, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.propertyMappingTestRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsAllTypesListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
}

func (r ApiPropertymappingsAllTypesListRequest) Execute() ([]TypeCreate, *http.Response, error) {
	return r.ApiService.PropertymappingsAllTypesListExecute(r)
}

/*
PropertymappingsAllTypesList Method for PropertymappingsAllTypesList

Get all creatable types

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsAllTypesListRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsAllTypesList(ctx context.Context) ApiPropertymappingsAllTypesListRequest {
	return ApiPropertymappingsAllTypesListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []TypeCreate
func (a *PropertymappingsAPIService) PropertymappingsAllTypesListExecute(r ApiPropertymappingsAllTypesListRequest) ([]TypeCreate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []TypeCreate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsAllTypesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/all/types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsAllUsedByListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsAllUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.PropertymappingsAllUsedByListExecute(r)
}

/*
PropertymappingsAllUsedByList Method for PropertymappingsAllUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Property Mapping.
	@return ApiPropertymappingsAllUsedByListRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsAllUsedByList(ctx context.Context, pmUuid string) ApiPropertymappingsAllUsedByListRequest {
	return ApiPropertymappingsAllUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *PropertymappingsAPIService) PropertymappingsAllUsedByListExecute(r ApiPropertymappingsAllUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsAllUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/all/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsNotificationCreateRequest struct {
	ctx                               context.Context
	ApiService                        *PropertymappingsAPIService
	notificationWebhookMappingRequest *NotificationWebhookMappingRequest
}

func (r ApiPropertymappingsNotificationCreateRequest) NotificationWebhookMappingRequest(notificationWebhookMappingRequest NotificationWebhookMappingRequest) ApiPropertymappingsNotificationCreateRequest {
	r.notificationWebhookMappingRequest = &notificationWebhookMappingRequest
	return r
}

func (r ApiPropertymappingsNotificationCreateRequest) Execute() (*NotificationWebhookMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsNotificationCreateExecute(r)
}

/*
PropertymappingsNotificationCreate Method for PropertymappingsNotificationCreate

NotificationWebhookMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsNotificationCreateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsNotificationCreate(ctx context.Context) ApiPropertymappingsNotificationCreateRequest {
	return ApiPropertymappingsNotificationCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return NotificationWebhookMapping
func (a *PropertymappingsAPIService) PropertymappingsNotificationCreateExecute(r ApiPropertymappingsNotificationCreateRequest) (*NotificationWebhookMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NotificationWebhookMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsNotificationCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/notification/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.notificationWebhookMappingRequest == nil {
		return localVarReturnValue, nil, reportError("notificationWebhookMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.notificationWebhookMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsNotificationDestroyRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsNotificationDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PropertymappingsNotificationDestroyExecute(r)
}

/*
PropertymappingsNotificationDestroy Method for PropertymappingsNotificationDestroy

NotificationWebhookMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Webhook Mapping.
	@return ApiPropertymappingsNotificationDestroyRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsNotificationDestroy(ctx context.Context, pmUuid string) ApiPropertymappingsNotificationDestroyRequest {
	return ApiPropertymappingsNotificationDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsAPIService) PropertymappingsNotificationDestroyExecute(r ApiPropertymappingsNotificationDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsNotificationDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/notification/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsNotificationListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	name       *string
	ordering   *string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiPropertymappingsNotificationListRequest) Name(name string) ApiPropertymappingsNotificationListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsNotificationListRequest) Ordering(ordering string) ApiPropertymappingsNotificationListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsNotificationListRequest) Page(page int32) ApiPropertymappingsNotificationListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsNotificationListRequest) PageSize(pageSize int32) ApiPropertymappingsNotificationListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiPropertymappingsNotificationListRequest) Search(search string) ApiPropertymappingsNotificationListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsNotificationListRequest) Execute() (*PaginatedNotificationWebhookMappingList, *http.Response, error) {
	return r.ApiService.PropertymappingsNotificationListExecute(r)
}

/*
PropertymappingsNotificationList Method for PropertymappingsNotificationList

NotificationWebhookMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsNotificationListRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsNotificationList(ctx context.Context) ApiPropertymappingsNotificationListRequest {
	return ApiPropertymappingsNotificationListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedNotificationWebhookMappingList
func (a *PropertymappingsAPIService) PropertymappingsNotificationListExecute(r ApiPropertymappingsNotificationListRequest) (*PaginatedNotificationWebhookMappingList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedNotificationWebhookMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsNotificationList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/notification/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsNotificationPartialUpdateRequest struct {
	ctx                                      context.Context
	ApiService                               *PropertymappingsAPIService
	pmUuid                                   string
	patchedNotificationWebhookMappingRequest *PatchedNotificationWebhookMappingRequest
}

func (r ApiPropertymappingsNotificationPartialUpdateRequest) PatchedNotificationWebhookMappingRequest(patchedNotificationWebhookMappingRequest PatchedNotificationWebhookMappingRequest) ApiPropertymappingsNotificationPartialUpdateRequest {
	r.patchedNotificationWebhookMappingRequest = &patchedNotificationWebhookMappingRequest
	return r
}

func (r ApiPropertymappingsNotificationPartialUpdateRequest) Execute() (*NotificationWebhookMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsNotificationPartialUpdateExecute(r)
}

/*
PropertymappingsNotificationPartialUpdate Method for PropertymappingsNotificationPartialUpdate

NotificationWebhookMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Webhook Mapping.
	@return ApiPropertymappingsNotificationPartialUpdateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsNotificationPartialUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsNotificationPartialUpdateRequest {
	return ApiPropertymappingsNotificationPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return NotificationWebhookMapping
func (a *PropertymappingsAPIService) PropertymappingsNotificationPartialUpdateExecute(r ApiPropertymappingsNotificationPartialUpdateRequest) (*NotificationWebhookMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NotificationWebhookMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsNotificationPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/notification/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedNotificationWebhookMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsNotificationRetrieveRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsNotificationRetrieveRequest) Execute() (*NotificationWebhookMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsNotificationRetrieveExecute(r)
}

/*
PropertymappingsNotificationRetrieve Method for PropertymappingsNotificationRetrieve

NotificationWebhookMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Webhook Mapping.
	@return ApiPropertymappingsNotificationRetrieveRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsNotificationRetrieve(ctx context.Context, pmUuid string) ApiPropertymappingsNotificationRetrieveRequest {
	return ApiPropertymappingsNotificationRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return NotificationWebhookMapping
func (a *PropertymappingsAPIService) PropertymappingsNotificationRetrieveExecute(r ApiPropertymappingsNotificationRetrieveRequest) (*NotificationWebhookMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NotificationWebhookMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsNotificationRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/notification/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsNotificationUpdateRequest struct {
	ctx                               context.Context
	ApiService                        *PropertymappingsAPIService
	pmUuid                            string
	notificationWebhookMappingRequest *NotificationWebhookMappingRequest
}

func (r ApiPropertymappingsNotificationUpdateRequest) NotificationWebhookMappingRequest(notificationWebhookMappingRequest NotificationWebhookMappingRequest) ApiPropertymappingsNotificationUpdateRequest {
	r.notificationWebhookMappingRequest = &notificationWebhookMappingRequest
	return r
}

func (r ApiPropertymappingsNotificationUpdateRequest) Execute() (*NotificationWebhookMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsNotificationUpdateExecute(r)
}

/*
PropertymappingsNotificationUpdate Method for PropertymappingsNotificationUpdate

NotificationWebhookMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Webhook Mapping.
	@return ApiPropertymappingsNotificationUpdateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsNotificationUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsNotificationUpdateRequest {
	return ApiPropertymappingsNotificationUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return NotificationWebhookMapping
func (a *PropertymappingsAPIService) PropertymappingsNotificationUpdateExecute(r ApiPropertymappingsNotificationUpdateRequest) (*NotificationWebhookMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NotificationWebhookMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsNotificationUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/notification/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.notificationWebhookMappingRequest == nil {
		return localVarReturnValue, nil, reportError("notificationWebhookMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.notificationWebhookMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsNotificationUsedByListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsNotificationUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.PropertymappingsNotificationUsedByListExecute(r)
}

/*
PropertymappingsNotificationUsedByList Method for PropertymappingsNotificationUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Webhook Mapping.
	@return ApiPropertymappingsNotificationUsedByListRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsNotificationUsedByList(ctx context.Context, pmUuid string) ApiPropertymappingsNotificationUsedByListRequest {
	return ApiPropertymappingsNotificationUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *PropertymappingsAPIService) PropertymappingsNotificationUsedByListExecute(r ApiPropertymappingsNotificationUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsNotificationUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/notification/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderGoogleWorkspaceCreateRequest struct {
	ctx                                   context.Context
	ApiService                            *PropertymappingsAPIService
	googleWorkspaceProviderMappingRequest *GoogleWorkspaceProviderMappingRequest
}

func (r ApiPropertymappingsProviderGoogleWorkspaceCreateRequest) GoogleWorkspaceProviderMappingRequest(googleWorkspaceProviderMappingRequest GoogleWorkspaceProviderMappingRequest) ApiPropertymappingsProviderGoogleWorkspaceCreateRequest {
	r.googleWorkspaceProviderMappingRequest = &googleWorkspaceProviderMappingRequest
	return r
}

func (r ApiPropertymappingsProviderGoogleWorkspaceCreateRequest) Execute() (*GoogleWorkspaceProviderMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderGoogleWorkspaceCreateExecute(r)
}

/*
PropertymappingsProviderGoogleWorkspaceCreate Method for PropertymappingsProviderGoogleWorkspaceCreate

GoogleWorkspaceProviderMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsProviderGoogleWorkspaceCreateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderGoogleWorkspaceCreate(ctx context.Context) ApiPropertymappingsProviderGoogleWorkspaceCreateRequest {
	return ApiPropertymappingsProviderGoogleWorkspaceCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GoogleWorkspaceProviderMapping
func (a *PropertymappingsAPIService) PropertymappingsProviderGoogleWorkspaceCreateExecute(r ApiPropertymappingsProviderGoogleWorkspaceCreateRequest) (*GoogleWorkspaceProviderMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GoogleWorkspaceProviderMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderGoogleWorkspaceCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/google_workspace/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.googleWorkspaceProviderMappingRequest == nil {
		return localVarReturnValue, nil, reportError("googleWorkspaceProviderMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.googleWorkspaceProviderMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderGoogleWorkspaceDestroyRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsProviderGoogleWorkspaceDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PropertymappingsProviderGoogleWorkspaceDestroyExecute(r)
}

/*
PropertymappingsProviderGoogleWorkspaceDestroy Method for PropertymappingsProviderGoogleWorkspaceDestroy

GoogleWorkspaceProviderMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Google Workspace Provider Mapping.
	@return ApiPropertymappingsProviderGoogleWorkspaceDestroyRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderGoogleWorkspaceDestroy(ctx context.Context, pmUuid string) ApiPropertymappingsProviderGoogleWorkspaceDestroyRequest {
	return ApiPropertymappingsProviderGoogleWorkspaceDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsAPIService) PropertymappingsProviderGoogleWorkspaceDestroyExecute(r ApiPropertymappingsProviderGoogleWorkspaceDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderGoogleWorkspaceDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/google_workspace/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderGoogleWorkspaceListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	expression *string
	managed    *[]string
	name       *string
	ordering   *string
	page       *int32
	pageSize   *int32
	pmUuid     *string
	search     *string
}

func (r ApiPropertymappingsProviderGoogleWorkspaceListRequest) Expression(expression string) ApiPropertymappingsProviderGoogleWorkspaceListRequest {
	r.expression = &expression
	return r
}

func (r ApiPropertymappingsProviderGoogleWorkspaceListRequest) Managed(managed []string) ApiPropertymappingsProviderGoogleWorkspaceListRequest {
	r.managed = &managed
	return r
}

func (r ApiPropertymappingsProviderGoogleWorkspaceListRequest) Name(name string) ApiPropertymappingsProviderGoogleWorkspaceListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsProviderGoogleWorkspaceListRequest) Ordering(ordering string) ApiPropertymappingsProviderGoogleWorkspaceListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsProviderGoogleWorkspaceListRequest) Page(page int32) ApiPropertymappingsProviderGoogleWorkspaceListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsProviderGoogleWorkspaceListRequest) PageSize(pageSize int32) ApiPropertymappingsProviderGoogleWorkspaceListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiPropertymappingsProviderGoogleWorkspaceListRequest) PmUuid(pmUuid string) ApiPropertymappingsProviderGoogleWorkspaceListRequest {
	r.pmUuid = &pmUuid
	return r
}

// A search term.
func (r ApiPropertymappingsProviderGoogleWorkspaceListRequest) Search(search string) ApiPropertymappingsProviderGoogleWorkspaceListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsProviderGoogleWorkspaceListRequest) Execute() (*PaginatedGoogleWorkspaceProviderMappingList, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderGoogleWorkspaceListExecute(r)
}

/*
PropertymappingsProviderGoogleWorkspaceList Method for PropertymappingsProviderGoogleWorkspaceList

GoogleWorkspaceProviderMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsProviderGoogleWorkspaceListRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderGoogleWorkspaceList(ctx context.Context) ApiPropertymappingsProviderGoogleWorkspaceListRequest {
	return ApiPropertymappingsProviderGoogleWorkspaceListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedGoogleWorkspaceProviderMappingList
func (a *PropertymappingsAPIService) PropertymappingsProviderGoogleWorkspaceListExecute(r ApiPropertymappingsProviderGoogleWorkspaceListRequest) (*PaginatedGoogleWorkspaceProviderMappingList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedGoogleWorkspaceProviderMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderGoogleWorkspaceList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/google_workspace/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.expression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expression", r.expression, "form", "")
	}
	if r.managed != nil {
		t := *r.managed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "managed", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "managed", t, "form", "multi")
		}
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.pmUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pm_uuid", r.pmUuid, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderGoogleWorkspacePartialUpdateRequest struct {
	ctx                                          context.Context
	ApiService                                   *PropertymappingsAPIService
	pmUuid                                       string
	patchedGoogleWorkspaceProviderMappingRequest *PatchedGoogleWorkspaceProviderMappingRequest
}

func (r ApiPropertymappingsProviderGoogleWorkspacePartialUpdateRequest) PatchedGoogleWorkspaceProviderMappingRequest(patchedGoogleWorkspaceProviderMappingRequest PatchedGoogleWorkspaceProviderMappingRequest) ApiPropertymappingsProviderGoogleWorkspacePartialUpdateRequest {
	r.patchedGoogleWorkspaceProviderMappingRequest = &patchedGoogleWorkspaceProviderMappingRequest
	return r
}

func (r ApiPropertymappingsProviderGoogleWorkspacePartialUpdateRequest) Execute() (*GoogleWorkspaceProviderMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderGoogleWorkspacePartialUpdateExecute(r)
}

/*
PropertymappingsProviderGoogleWorkspacePartialUpdate Method for PropertymappingsProviderGoogleWorkspacePartialUpdate

GoogleWorkspaceProviderMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Google Workspace Provider Mapping.
	@return ApiPropertymappingsProviderGoogleWorkspacePartialUpdateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderGoogleWorkspacePartialUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsProviderGoogleWorkspacePartialUpdateRequest {
	return ApiPropertymappingsProviderGoogleWorkspacePartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return GoogleWorkspaceProviderMapping
func (a *PropertymappingsAPIService) PropertymappingsProviderGoogleWorkspacePartialUpdateExecute(r ApiPropertymappingsProviderGoogleWorkspacePartialUpdateRequest) (*GoogleWorkspaceProviderMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GoogleWorkspaceProviderMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderGoogleWorkspacePartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/google_workspace/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedGoogleWorkspaceProviderMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderGoogleWorkspaceRetrieveRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsProviderGoogleWorkspaceRetrieveRequest) Execute() (*GoogleWorkspaceProviderMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderGoogleWorkspaceRetrieveExecute(r)
}

/*
PropertymappingsProviderGoogleWorkspaceRetrieve Method for PropertymappingsProviderGoogleWorkspaceRetrieve

GoogleWorkspaceProviderMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Google Workspace Provider Mapping.
	@return ApiPropertymappingsProviderGoogleWorkspaceRetrieveRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderGoogleWorkspaceRetrieve(ctx context.Context, pmUuid string) ApiPropertymappingsProviderGoogleWorkspaceRetrieveRequest {
	return ApiPropertymappingsProviderGoogleWorkspaceRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return GoogleWorkspaceProviderMapping
func (a *PropertymappingsAPIService) PropertymappingsProviderGoogleWorkspaceRetrieveExecute(r ApiPropertymappingsProviderGoogleWorkspaceRetrieveRequest) (*GoogleWorkspaceProviderMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GoogleWorkspaceProviderMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderGoogleWorkspaceRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/google_workspace/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderGoogleWorkspaceUpdateRequest struct {
	ctx                                   context.Context
	ApiService                            *PropertymappingsAPIService
	pmUuid                                string
	googleWorkspaceProviderMappingRequest *GoogleWorkspaceProviderMappingRequest
}

func (r ApiPropertymappingsProviderGoogleWorkspaceUpdateRequest) GoogleWorkspaceProviderMappingRequest(googleWorkspaceProviderMappingRequest GoogleWorkspaceProviderMappingRequest) ApiPropertymappingsProviderGoogleWorkspaceUpdateRequest {
	r.googleWorkspaceProviderMappingRequest = &googleWorkspaceProviderMappingRequest
	return r
}

func (r ApiPropertymappingsProviderGoogleWorkspaceUpdateRequest) Execute() (*GoogleWorkspaceProviderMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderGoogleWorkspaceUpdateExecute(r)
}

/*
PropertymappingsProviderGoogleWorkspaceUpdate Method for PropertymappingsProviderGoogleWorkspaceUpdate

GoogleWorkspaceProviderMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Google Workspace Provider Mapping.
	@return ApiPropertymappingsProviderGoogleWorkspaceUpdateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderGoogleWorkspaceUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsProviderGoogleWorkspaceUpdateRequest {
	return ApiPropertymappingsProviderGoogleWorkspaceUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return GoogleWorkspaceProviderMapping
func (a *PropertymappingsAPIService) PropertymappingsProviderGoogleWorkspaceUpdateExecute(r ApiPropertymappingsProviderGoogleWorkspaceUpdateRequest) (*GoogleWorkspaceProviderMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GoogleWorkspaceProviderMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderGoogleWorkspaceUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/google_workspace/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.googleWorkspaceProviderMappingRequest == nil {
		return localVarReturnValue, nil, reportError("googleWorkspaceProviderMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.googleWorkspaceProviderMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderGoogleWorkspaceUsedByListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsProviderGoogleWorkspaceUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderGoogleWorkspaceUsedByListExecute(r)
}

/*
PropertymappingsProviderGoogleWorkspaceUsedByList Method for PropertymappingsProviderGoogleWorkspaceUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Google Workspace Provider Mapping.
	@return ApiPropertymappingsProviderGoogleWorkspaceUsedByListRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderGoogleWorkspaceUsedByList(ctx context.Context, pmUuid string) ApiPropertymappingsProviderGoogleWorkspaceUsedByListRequest {
	return ApiPropertymappingsProviderGoogleWorkspaceUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *PropertymappingsAPIService) PropertymappingsProviderGoogleWorkspaceUsedByListExecute(r ApiPropertymappingsProviderGoogleWorkspaceUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderGoogleWorkspaceUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/google_workspace/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderMicrosoftEntraCreateRequest struct {
	ctx                                  context.Context
	ApiService                           *PropertymappingsAPIService
	microsoftEntraProviderMappingRequest *MicrosoftEntraProviderMappingRequest
}

func (r ApiPropertymappingsProviderMicrosoftEntraCreateRequest) MicrosoftEntraProviderMappingRequest(microsoftEntraProviderMappingRequest MicrosoftEntraProviderMappingRequest) ApiPropertymappingsProviderMicrosoftEntraCreateRequest {
	r.microsoftEntraProviderMappingRequest = &microsoftEntraProviderMappingRequest
	return r
}

func (r ApiPropertymappingsProviderMicrosoftEntraCreateRequest) Execute() (*MicrosoftEntraProviderMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderMicrosoftEntraCreateExecute(r)
}

/*
PropertymappingsProviderMicrosoftEntraCreate Method for PropertymappingsProviderMicrosoftEntraCreate

MicrosoftEntraProviderMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsProviderMicrosoftEntraCreateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderMicrosoftEntraCreate(ctx context.Context) ApiPropertymappingsProviderMicrosoftEntraCreateRequest {
	return ApiPropertymappingsProviderMicrosoftEntraCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MicrosoftEntraProviderMapping
func (a *PropertymappingsAPIService) PropertymappingsProviderMicrosoftEntraCreateExecute(r ApiPropertymappingsProviderMicrosoftEntraCreateRequest) (*MicrosoftEntraProviderMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MicrosoftEntraProviderMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderMicrosoftEntraCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/microsoft_entra/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.microsoftEntraProviderMappingRequest == nil {
		return localVarReturnValue, nil, reportError("microsoftEntraProviderMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftEntraProviderMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderMicrosoftEntraDestroyRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsProviderMicrosoftEntraDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PropertymappingsProviderMicrosoftEntraDestroyExecute(r)
}

/*
PropertymappingsProviderMicrosoftEntraDestroy Method for PropertymappingsProviderMicrosoftEntraDestroy

MicrosoftEntraProviderMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Microsoft Entra Provider Mapping.
	@return ApiPropertymappingsProviderMicrosoftEntraDestroyRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderMicrosoftEntraDestroy(ctx context.Context, pmUuid string) ApiPropertymappingsProviderMicrosoftEntraDestroyRequest {
	return ApiPropertymappingsProviderMicrosoftEntraDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsAPIService) PropertymappingsProviderMicrosoftEntraDestroyExecute(r ApiPropertymappingsProviderMicrosoftEntraDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderMicrosoftEntraDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/microsoft_entra/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderMicrosoftEntraListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	expression *string
	managed    *[]string
	name       *string
	ordering   *string
	page       *int32
	pageSize   *int32
	pmUuid     *string
	search     *string
}

func (r ApiPropertymappingsProviderMicrosoftEntraListRequest) Expression(expression string) ApiPropertymappingsProviderMicrosoftEntraListRequest {
	r.expression = &expression
	return r
}

func (r ApiPropertymappingsProviderMicrosoftEntraListRequest) Managed(managed []string) ApiPropertymappingsProviderMicrosoftEntraListRequest {
	r.managed = &managed
	return r
}

func (r ApiPropertymappingsProviderMicrosoftEntraListRequest) Name(name string) ApiPropertymappingsProviderMicrosoftEntraListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsProviderMicrosoftEntraListRequest) Ordering(ordering string) ApiPropertymappingsProviderMicrosoftEntraListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsProviderMicrosoftEntraListRequest) Page(page int32) ApiPropertymappingsProviderMicrosoftEntraListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsProviderMicrosoftEntraListRequest) PageSize(pageSize int32) ApiPropertymappingsProviderMicrosoftEntraListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiPropertymappingsProviderMicrosoftEntraListRequest) PmUuid(pmUuid string) ApiPropertymappingsProviderMicrosoftEntraListRequest {
	r.pmUuid = &pmUuid
	return r
}

// A search term.
func (r ApiPropertymappingsProviderMicrosoftEntraListRequest) Search(search string) ApiPropertymappingsProviderMicrosoftEntraListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsProviderMicrosoftEntraListRequest) Execute() (*PaginatedMicrosoftEntraProviderMappingList, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderMicrosoftEntraListExecute(r)
}

/*
PropertymappingsProviderMicrosoftEntraList Method for PropertymappingsProviderMicrosoftEntraList

MicrosoftEntraProviderMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsProviderMicrosoftEntraListRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderMicrosoftEntraList(ctx context.Context) ApiPropertymappingsProviderMicrosoftEntraListRequest {
	return ApiPropertymappingsProviderMicrosoftEntraListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedMicrosoftEntraProviderMappingList
func (a *PropertymappingsAPIService) PropertymappingsProviderMicrosoftEntraListExecute(r ApiPropertymappingsProviderMicrosoftEntraListRequest) (*PaginatedMicrosoftEntraProviderMappingList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedMicrosoftEntraProviderMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderMicrosoftEntraList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/microsoft_entra/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.expression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expression", r.expression, "form", "")
	}
	if r.managed != nil {
		t := *r.managed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "managed", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "managed", t, "form", "multi")
		}
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.pmUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pm_uuid", r.pmUuid, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderMicrosoftEntraPartialUpdateRequest struct {
	ctx                                         context.Context
	ApiService                                  *PropertymappingsAPIService
	pmUuid                                      string
	patchedMicrosoftEntraProviderMappingRequest *PatchedMicrosoftEntraProviderMappingRequest
}

func (r ApiPropertymappingsProviderMicrosoftEntraPartialUpdateRequest) PatchedMicrosoftEntraProviderMappingRequest(patchedMicrosoftEntraProviderMappingRequest PatchedMicrosoftEntraProviderMappingRequest) ApiPropertymappingsProviderMicrosoftEntraPartialUpdateRequest {
	r.patchedMicrosoftEntraProviderMappingRequest = &patchedMicrosoftEntraProviderMappingRequest
	return r
}

func (r ApiPropertymappingsProviderMicrosoftEntraPartialUpdateRequest) Execute() (*MicrosoftEntraProviderMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderMicrosoftEntraPartialUpdateExecute(r)
}

/*
PropertymappingsProviderMicrosoftEntraPartialUpdate Method for PropertymappingsProviderMicrosoftEntraPartialUpdate

MicrosoftEntraProviderMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Microsoft Entra Provider Mapping.
	@return ApiPropertymappingsProviderMicrosoftEntraPartialUpdateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderMicrosoftEntraPartialUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsProviderMicrosoftEntraPartialUpdateRequest {
	return ApiPropertymappingsProviderMicrosoftEntraPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return MicrosoftEntraProviderMapping
func (a *PropertymappingsAPIService) PropertymappingsProviderMicrosoftEntraPartialUpdateExecute(r ApiPropertymappingsProviderMicrosoftEntraPartialUpdateRequest) (*MicrosoftEntraProviderMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MicrosoftEntraProviderMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderMicrosoftEntraPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/microsoft_entra/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedMicrosoftEntraProviderMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderMicrosoftEntraRetrieveRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsProviderMicrosoftEntraRetrieveRequest) Execute() (*MicrosoftEntraProviderMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderMicrosoftEntraRetrieveExecute(r)
}

/*
PropertymappingsProviderMicrosoftEntraRetrieve Method for PropertymappingsProviderMicrosoftEntraRetrieve

MicrosoftEntraProviderMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Microsoft Entra Provider Mapping.
	@return ApiPropertymappingsProviderMicrosoftEntraRetrieveRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderMicrosoftEntraRetrieve(ctx context.Context, pmUuid string) ApiPropertymappingsProviderMicrosoftEntraRetrieveRequest {
	return ApiPropertymappingsProviderMicrosoftEntraRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return MicrosoftEntraProviderMapping
func (a *PropertymappingsAPIService) PropertymappingsProviderMicrosoftEntraRetrieveExecute(r ApiPropertymappingsProviderMicrosoftEntraRetrieveRequest) (*MicrosoftEntraProviderMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MicrosoftEntraProviderMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderMicrosoftEntraRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/microsoft_entra/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderMicrosoftEntraUpdateRequest struct {
	ctx                                  context.Context
	ApiService                           *PropertymappingsAPIService
	pmUuid                               string
	microsoftEntraProviderMappingRequest *MicrosoftEntraProviderMappingRequest
}

func (r ApiPropertymappingsProviderMicrosoftEntraUpdateRequest) MicrosoftEntraProviderMappingRequest(microsoftEntraProviderMappingRequest MicrosoftEntraProviderMappingRequest) ApiPropertymappingsProviderMicrosoftEntraUpdateRequest {
	r.microsoftEntraProviderMappingRequest = &microsoftEntraProviderMappingRequest
	return r
}

func (r ApiPropertymappingsProviderMicrosoftEntraUpdateRequest) Execute() (*MicrosoftEntraProviderMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderMicrosoftEntraUpdateExecute(r)
}

/*
PropertymappingsProviderMicrosoftEntraUpdate Method for PropertymappingsProviderMicrosoftEntraUpdate

MicrosoftEntraProviderMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Microsoft Entra Provider Mapping.
	@return ApiPropertymappingsProviderMicrosoftEntraUpdateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderMicrosoftEntraUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsProviderMicrosoftEntraUpdateRequest {
	return ApiPropertymappingsProviderMicrosoftEntraUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return MicrosoftEntraProviderMapping
func (a *PropertymappingsAPIService) PropertymappingsProviderMicrosoftEntraUpdateExecute(r ApiPropertymappingsProviderMicrosoftEntraUpdateRequest) (*MicrosoftEntraProviderMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MicrosoftEntraProviderMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderMicrosoftEntraUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/microsoft_entra/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.microsoftEntraProviderMappingRequest == nil {
		return localVarReturnValue, nil, reportError("microsoftEntraProviderMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microsoftEntraProviderMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderMicrosoftEntraUsedByListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsProviderMicrosoftEntraUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderMicrosoftEntraUsedByListExecute(r)
}

/*
PropertymappingsProviderMicrosoftEntraUsedByList Method for PropertymappingsProviderMicrosoftEntraUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Microsoft Entra Provider Mapping.
	@return ApiPropertymappingsProviderMicrosoftEntraUsedByListRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderMicrosoftEntraUsedByList(ctx context.Context, pmUuid string) ApiPropertymappingsProviderMicrosoftEntraUsedByListRequest {
	return ApiPropertymappingsProviderMicrosoftEntraUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *PropertymappingsAPIService) PropertymappingsProviderMicrosoftEntraUsedByListExecute(r ApiPropertymappingsProviderMicrosoftEntraUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderMicrosoftEntraUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/microsoft_entra/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderRacCreateRequest struct {
	ctx                       context.Context
	ApiService                *PropertymappingsAPIService
	rACPropertyMappingRequest *RACPropertyMappingRequest
}

func (r ApiPropertymappingsProviderRacCreateRequest) RACPropertyMappingRequest(rACPropertyMappingRequest RACPropertyMappingRequest) ApiPropertymappingsProviderRacCreateRequest {
	r.rACPropertyMappingRequest = &rACPropertyMappingRequest
	return r
}

func (r ApiPropertymappingsProviderRacCreateRequest) Execute() (*RACPropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderRacCreateExecute(r)
}

/*
PropertymappingsProviderRacCreate Method for PropertymappingsProviderRacCreate

RACPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsProviderRacCreateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderRacCreate(ctx context.Context) ApiPropertymappingsProviderRacCreateRequest {
	return ApiPropertymappingsProviderRacCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return RACPropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsProviderRacCreateExecute(r ApiPropertymappingsProviderRacCreateRequest) (*RACPropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RACPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderRacCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/rac/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rACPropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("rACPropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rACPropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderRacDestroyRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsProviderRacDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PropertymappingsProviderRacDestroyExecute(r)
}

/*
PropertymappingsProviderRacDestroy Method for PropertymappingsProviderRacDestroy

RACPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this RAC Provider Property Mapping.
	@return ApiPropertymappingsProviderRacDestroyRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderRacDestroy(ctx context.Context, pmUuid string) ApiPropertymappingsProviderRacDestroyRequest {
	return ApiPropertymappingsProviderRacDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsAPIService) PropertymappingsProviderRacDestroyExecute(r ApiPropertymappingsProviderRacDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderRacDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/rac/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderRacListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	managed    *[]string
	name       *string
	ordering   *string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiPropertymappingsProviderRacListRequest) Managed(managed []string) ApiPropertymappingsProviderRacListRequest {
	r.managed = &managed
	return r
}

func (r ApiPropertymappingsProviderRacListRequest) Name(name string) ApiPropertymappingsProviderRacListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsProviderRacListRequest) Ordering(ordering string) ApiPropertymappingsProviderRacListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsProviderRacListRequest) Page(page int32) ApiPropertymappingsProviderRacListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsProviderRacListRequest) PageSize(pageSize int32) ApiPropertymappingsProviderRacListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiPropertymappingsProviderRacListRequest) Search(search string) ApiPropertymappingsProviderRacListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsProviderRacListRequest) Execute() (*PaginatedRACPropertyMappingList, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderRacListExecute(r)
}

/*
PropertymappingsProviderRacList Method for PropertymappingsProviderRacList

RACPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsProviderRacListRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderRacList(ctx context.Context) ApiPropertymappingsProviderRacListRequest {
	return ApiPropertymappingsProviderRacListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedRACPropertyMappingList
func (a *PropertymappingsAPIService) PropertymappingsProviderRacListExecute(r ApiPropertymappingsProviderRacListRequest) (*PaginatedRACPropertyMappingList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedRACPropertyMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderRacList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/rac/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.managed != nil {
		t := *r.managed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "managed", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "managed", t, "form", "multi")
		}
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderRacPartialUpdateRequest struct {
	ctx                              context.Context
	ApiService                       *PropertymappingsAPIService
	pmUuid                           string
	patchedRACPropertyMappingRequest *PatchedRACPropertyMappingRequest
}

func (r ApiPropertymappingsProviderRacPartialUpdateRequest) PatchedRACPropertyMappingRequest(patchedRACPropertyMappingRequest PatchedRACPropertyMappingRequest) ApiPropertymappingsProviderRacPartialUpdateRequest {
	r.patchedRACPropertyMappingRequest = &patchedRACPropertyMappingRequest
	return r
}

func (r ApiPropertymappingsProviderRacPartialUpdateRequest) Execute() (*RACPropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderRacPartialUpdateExecute(r)
}

/*
PropertymappingsProviderRacPartialUpdate Method for PropertymappingsProviderRacPartialUpdate

RACPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this RAC Provider Property Mapping.
	@return ApiPropertymappingsProviderRacPartialUpdateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderRacPartialUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsProviderRacPartialUpdateRequest {
	return ApiPropertymappingsProviderRacPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return RACPropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsProviderRacPartialUpdateExecute(r ApiPropertymappingsProviderRacPartialUpdateRequest) (*RACPropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RACPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderRacPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/rac/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedRACPropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderRacRetrieveRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsProviderRacRetrieveRequest) Execute() (*RACPropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderRacRetrieveExecute(r)
}

/*
PropertymappingsProviderRacRetrieve Method for PropertymappingsProviderRacRetrieve

RACPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this RAC Provider Property Mapping.
	@return ApiPropertymappingsProviderRacRetrieveRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderRacRetrieve(ctx context.Context, pmUuid string) ApiPropertymappingsProviderRacRetrieveRequest {
	return ApiPropertymappingsProviderRacRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return RACPropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsProviderRacRetrieveExecute(r ApiPropertymappingsProviderRacRetrieveRequest) (*RACPropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RACPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderRacRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/rac/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderRacUpdateRequest struct {
	ctx                       context.Context
	ApiService                *PropertymappingsAPIService
	pmUuid                    string
	rACPropertyMappingRequest *RACPropertyMappingRequest
}

func (r ApiPropertymappingsProviderRacUpdateRequest) RACPropertyMappingRequest(rACPropertyMappingRequest RACPropertyMappingRequest) ApiPropertymappingsProviderRacUpdateRequest {
	r.rACPropertyMappingRequest = &rACPropertyMappingRequest
	return r
}

func (r ApiPropertymappingsProviderRacUpdateRequest) Execute() (*RACPropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderRacUpdateExecute(r)
}

/*
PropertymappingsProviderRacUpdate Method for PropertymappingsProviderRacUpdate

RACPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this RAC Provider Property Mapping.
	@return ApiPropertymappingsProviderRacUpdateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderRacUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsProviderRacUpdateRequest {
	return ApiPropertymappingsProviderRacUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return RACPropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsProviderRacUpdateExecute(r ApiPropertymappingsProviderRacUpdateRequest) (*RACPropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RACPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderRacUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/rac/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rACPropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("rACPropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rACPropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderRacUsedByListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsProviderRacUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderRacUsedByListExecute(r)
}

/*
PropertymappingsProviderRacUsedByList Method for PropertymappingsProviderRacUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this RAC Provider Property Mapping.
	@return ApiPropertymappingsProviderRacUsedByListRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderRacUsedByList(ctx context.Context, pmUuid string) ApiPropertymappingsProviderRacUsedByListRequest {
	return ApiPropertymappingsProviderRacUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *PropertymappingsAPIService) PropertymappingsProviderRacUsedByListExecute(r ApiPropertymappingsProviderRacUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderRacUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/rac/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderRadiusCreateRequest struct {
	ctx                                  context.Context
	ApiService                           *PropertymappingsAPIService
	radiusProviderPropertyMappingRequest *RadiusProviderPropertyMappingRequest
}

func (r ApiPropertymappingsProviderRadiusCreateRequest) RadiusProviderPropertyMappingRequest(radiusProviderPropertyMappingRequest RadiusProviderPropertyMappingRequest) ApiPropertymappingsProviderRadiusCreateRequest {
	r.radiusProviderPropertyMappingRequest = &radiusProviderPropertyMappingRequest
	return r
}

func (r ApiPropertymappingsProviderRadiusCreateRequest) Execute() (*RadiusProviderPropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderRadiusCreateExecute(r)
}

/*
PropertymappingsProviderRadiusCreate Method for PropertymappingsProviderRadiusCreate

RadiusProviderPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsProviderRadiusCreateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderRadiusCreate(ctx context.Context) ApiPropertymappingsProviderRadiusCreateRequest {
	return ApiPropertymappingsProviderRadiusCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return RadiusProviderPropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsProviderRadiusCreateExecute(r ApiPropertymappingsProviderRadiusCreateRequest) (*RadiusProviderPropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RadiusProviderPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderRadiusCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/radius/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.radiusProviderPropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("radiusProviderPropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.radiusProviderPropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderRadiusDestroyRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsProviderRadiusDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PropertymappingsProviderRadiusDestroyExecute(r)
}

/*
PropertymappingsProviderRadiusDestroy Method for PropertymappingsProviderRadiusDestroy

RadiusProviderPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Radius Provider Property Mapping.
	@return ApiPropertymappingsProviderRadiusDestroyRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderRadiusDestroy(ctx context.Context, pmUuid string) ApiPropertymappingsProviderRadiusDestroyRequest {
	return ApiPropertymappingsProviderRadiusDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsAPIService) PropertymappingsProviderRadiusDestroyExecute(r ApiPropertymappingsProviderRadiusDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderRadiusDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/radius/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderRadiusListRequest struct {
	ctx           context.Context
	ApiService    *PropertymappingsAPIService
	managed       *[]string
	managedIsnull *bool
	name          *string
	ordering      *string
	page          *int32
	pageSize      *int32
	search        *string
}

func (r ApiPropertymappingsProviderRadiusListRequest) Managed(managed []string) ApiPropertymappingsProviderRadiusListRequest {
	r.managed = &managed
	return r
}

func (r ApiPropertymappingsProviderRadiusListRequest) ManagedIsnull(managedIsnull bool) ApiPropertymappingsProviderRadiusListRequest {
	r.managedIsnull = &managedIsnull
	return r
}

func (r ApiPropertymappingsProviderRadiusListRequest) Name(name string) ApiPropertymappingsProviderRadiusListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsProviderRadiusListRequest) Ordering(ordering string) ApiPropertymappingsProviderRadiusListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsProviderRadiusListRequest) Page(page int32) ApiPropertymappingsProviderRadiusListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsProviderRadiusListRequest) PageSize(pageSize int32) ApiPropertymappingsProviderRadiusListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiPropertymappingsProviderRadiusListRequest) Search(search string) ApiPropertymappingsProviderRadiusListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsProviderRadiusListRequest) Execute() (*PaginatedRadiusProviderPropertyMappingList, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderRadiusListExecute(r)
}

/*
PropertymappingsProviderRadiusList Method for PropertymappingsProviderRadiusList

RadiusProviderPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsProviderRadiusListRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderRadiusList(ctx context.Context) ApiPropertymappingsProviderRadiusListRequest {
	return ApiPropertymappingsProviderRadiusListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedRadiusProviderPropertyMappingList
func (a *PropertymappingsAPIService) PropertymappingsProviderRadiusListExecute(r ApiPropertymappingsProviderRadiusListRequest) (*PaginatedRadiusProviderPropertyMappingList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedRadiusProviderPropertyMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderRadiusList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/radius/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.managed != nil {
		t := *r.managed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "managed", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "managed", t, "form", "multi")
		}
	}
	if r.managedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "managed__isnull", r.managedIsnull, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderRadiusPartialUpdateRequest struct {
	ctx                                         context.Context
	ApiService                                  *PropertymappingsAPIService
	pmUuid                                      string
	patchedRadiusProviderPropertyMappingRequest *PatchedRadiusProviderPropertyMappingRequest
}

func (r ApiPropertymappingsProviderRadiusPartialUpdateRequest) PatchedRadiusProviderPropertyMappingRequest(patchedRadiusProviderPropertyMappingRequest PatchedRadiusProviderPropertyMappingRequest) ApiPropertymappingsProviderRadiusPartialUpdateRequest {
	r.patchedRadiusProviderPropertyMappingRequest = &patchedRadiusProviderPropertyMappingRequest
	return r
}

func (r ApiPropertymappingsProviderRadiusPartialUpdateRequest) Execute() (*RadiusProviderPropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderRadiusPartialUpdateExecute(r)
}

/*
PropertymappingsProviderRadiusPartialUpdate Method for PropertymappingsProviderRadiusPartialUpdate

RadiusProviderPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Radius Provider Property Mapping.
	@return ApiPropertymappingsProviderRadiusPartialUpdateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderRadiusPartialUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsProviderRadiusPartialUpdateRequest {
	return ApiPropertymappingsProviderRadiusPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return RadiusProviderPropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsProviderRadiusPartialUpdateExecute(r ApiPropertymappingsProviderRadiusPartialUpdateRequest) (*RadiusProviderPropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RadiusProviderPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderRadiusPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/radius/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedRadiusProviderPropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderRadiusRetrieveRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsProviderRadiusRetrieveRequest) Execute() (*RadiusProviderPropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderRadiusRetrieveExecute(r)
}

/*
PropertymappingsProviderRadiusRetrieve Method for PropertymappingsProviderRadiusRetrieve

RadiusProviderPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Radius Provider Property Mapping.
	@return ApiPropertymappingsProviderRadiusRetrieveRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderRadiusRetrieve(ctx context.Context, pmUuid string) ApiPropertymappingsProviderRadiusRetrieveRequest {
	return ApiPropertymappingsProviderRadiusRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return RadiusProviderPropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsProviderRadiusRetrieveExecute(r ApiPropertymappingsProviderRadiusRetrieveRequest) (*RadiusProviderPropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RadiusProviderPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderRadiusRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/radius/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderRadiusUpdateRequest struct {
	ctx                                  context.Context
	ApiService                           *PropertymappingsAPIService
	pmUuid                               string
	radiusProviderPropertyMappingRequest *RadiusProviderPropertyMappingRequest
}

func (r ApiPropertymappingsProviderRadiusUpdateRequest) RadiusProviderPropertyMappingRequest(radiusProviderPropertyMappingRequest RadiusProviderPropertyMappingRequest) ApiPropertymappingsProviderRadiusUpdateRequest {
	r.radiusProviderPropertyMappingRequest = &radiusProviderPropertyMappingRequest
	return r
}

func (r ApiPropertymappingsProviderRadiusUpdateRequest) Execute() (*RadiusProviderPropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderRadiusUpdateExecute(r)
}

/*
PropertymappingsProviderRadiusUpdate Method for PropertymappingsProviderRadiusUpdate

RadiusProviderPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Radius Provider Property Mapping.
	@return ApiPropertymappingsProviderRadiusUpdateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderRadiusUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsProviderRadiusUpdateRequest {
	return ApiPropertymappingsProviderRadiusUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return RadiusProviderPropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsProviderRadiusUpdateExecute(r ApiPropertymappingsProviderRadiusUpdateRequest) (*RadiusProviderPropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RadiusProviderPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderRadiusUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/radius/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.radiusProviderPropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("radiusProviderPropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.radiusProviderPropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderRadiusUsedByListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsProviderRadiusUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderRadiusUsedByListExecute(r)
}

/*
PropertymappingsProviderRadiusUsedByList Method for PropertymappingsProviderRadiusUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Radius Provider Property Mapping.
	@return ApiPropertymappingsProviderRadiusUsedByListRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderRadiusUsedByList(ctx context.Context, pmUuid string) ApiPropertymappingsProviderRadiusUsedByListRequest {
	return ApiPropertymappingsProviderRadiusUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *PropertymappingsAPIService) PropertymappingsProviderRadiusUsedByListExecute(r ApiPropertymappingsProviderRadiusUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderRadiusUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/radius/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderSamlCreateRequest struct {
	ctx                        context.Context
	ApiService                 *PropertymappingsAPIService
	sAMLPropertyMappingRequest *SAMLPropertyMappingRequest
}

func (r ApiPropertymappingsProviderSamlCreateRequest) SAMLPropertyMappingRequest(sAMLPropertyMappingRequest SAMLPropertyMappingRequest) ApiPropertymappingsProviderSamlCreateRequest {
	r.sAMLPropertyMappingRequest = &sAMLPropertyMappingRequest
	return r
}

func (r ApiPropertymappingsProviderSamlCreateRequest) Execute() (*SAMLPropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderSamlCreateExecute(r)
}

/*
PropertymappingsProviderSamlCreate Method for PropertymappingsProviderSamlCreate

SAMLPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsProviderSamlCreateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderSamlCreate(ctx context.Context) ApiPropertymappingsProviderSamlCreateRequest {
	return ApiPropertymappingsProviderSamlCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SAMLPropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsProviderSamlCreateExecute(r ApiPropertymappingsProviderSamlCreateRequest) (*SAMLPropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SAMLPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderSamlCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/saml/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sAMLPropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("sAMLPropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sAMLPropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderSamlDestroyRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsProviderSamlDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PropertymappingsProviderSamlDestroyExecute(r)
}

/*
PropertymappingsProviderSamlDestroy Method for PropertymappingsProviderSamlDestroy

SAMLPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SAML Provider Property Mapping.
	@return ApiPropertymappingsProviderSamlDestroyRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderSamlDestroy(ctx context.Context, pmUuid string) ApiPropertymappingsProviderSamlDestroyRequest {
	return ApiPropertymappingsProviderSamlDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsAPIService) PropertymappingsProviderSamlDestroyExecute(r ApiPropertymappingsProviderSamlDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderSamlDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/saml/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderSamlListRequest struct {
	ctx           context.Context
	ApiService    *PropertymappingsAPIService
	friendlyName  *string
	managed       *[]string
	managedIsnull *bool
	name          *string
	ordering      *string
	page          *int32
	pageSize      *int32
	samlName      *string
	search        *string
}

func (r ApiPropertymappingsProviderSamlListRequest) FriendlyName(friendlyName string) ApiPropertymappingsProviderSamlListRequest {
	r.friendlyName = &friendlyName
	return r
}

func (r ApiPropertymappingsProviderSamlListRequest) Managed(managed []string) ApiPropertymappingsProviderSamlListRequest {
	r.managed = &managed
	return r
}

func (r ApiPropertymappingsProviderSamlListRequest) ManagedIsnull(managedIsnull bool) ApiPropertymappingsProviderSamlListRequest {
	r.managedIsnull = &managedIsnull
	return r
}

func (r ApiPropertymappingsProviderSamlListRequest) Name(name string) ApiPropertymappingsProviderSamlListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsProviderSamlListRequest) Ordering(ordering string) ApiPropertymappingsProviderSamlListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsProviderSamlListRequest) Page(page int32) ApiPropertymappingsProviderSamlListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsProviderSamlListRequest) PageSize(pageSize int32) ApiPropertymappingsProviderSamlListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiPropertymappingsProviderSamlListRequest) SamlName(samlName string) ApiPropertymappingsProviderSamlListRequest {
	r.samlName = &samlName
	return r
}

// A search term.
func (r ApiPropertymappingsProviderSamlListRequest) Search(search string) ApiPropertymappingsProviderSamlListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsProviderSamlListRequest) Execute() (*PaginatedSAMLPropertyMappingList, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderSamlListExecute(r)
}

/*
PropertymappingsProviderSamlList Method for PropertymappingsProviderSamlList

SAMLPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsProviderSamlListRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderSamlList(ctx context.Context) ApiPropertymappingsProviderSamlListRequest {
	return ApiPropertymappingsProviderSamlListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedSAMLPropertyMappingList
func (a *PropertymappingsAPIService) PropertymappingsProviderSamlListExecute(r ApiPropertymappingsProviderSamlListRequest) (*PaginatedSAMLPropertyMappingList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedSAMLPropertyMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderSamlList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/saml/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.friendlyName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "friendly_name", r.friendlyName, "form", "")
	}
	if r.managed != nil {
		t := *r.managed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "managed", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "managed", t, "form", "multi")
		}
	}
	if r.managedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "managed__isnull", r.managedIsnull, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.samlName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "saml_name", r.samlName, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderSamlPartialUpdateRequest struct {
	ctx                               context.Context
	ApiService                        *PropertymappingsAPIService
	pmUuid                            string
	patchedSAMLPropertyMappingRequest *PatchedSAMLPropertyMappingRequest
}

func (r ApiPropertymappingsProviderSamlPartialUpdateRequest) PatchedSAMLPropertyMappingRequest(patchedSAMLPropertyMappingRequest PatchedSAMLPropertyMappingRequest) ApiPropertymappingsProviderSamlPartialUpdateRequest {
	r.patchedSAMLPropertyMappingRequest = &patchedSAMLPropertyMappingRequest
	return r
}

func (r ApiPropertymappingsProviderSamlPartialUpdateRequest) Execute() (*SAMLPropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderSamlPartialUpdateExecute(r)
}

/*
PropertymappingsProviderSamlPartialUpdate Method for PropertymappingsProviderSamlPartialUpdate

SAMLPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SAML Provider Property Mapping.
	@return ApiPropertymappingsProviderSamlPartialUpdateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderSamlPartialUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsProviderSamlPartialUpdateRequest {
	return ApiPropertymappingsProviderSamlPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return SAMLPropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsProviderSamlPartialUpdateExecute(r ApiPropertymappingsProviderSamlPartialUpdateRequest) (*SAMLPropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SAMLPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderSamlPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/saml/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedSAMLPropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderSamlRetrieveRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsProviderSamlRetrieveRequest) Execute() (*SAMLPropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderSamlRetrieveExecute(r)
}

/*
PropertymappingsProviderSamlRetrieve Method for PropertymappingsProviderSamlRetrieve

SAMLPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SAML Provider Property Mapping.
	@return ApiPropertymappingsProviderSamlRetrieveRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderSamlRetrieve(ctx context.Context, pmUuid string) ApiPropertymappingsProviderSamlRetrieveRequest {
	return ApiPropertymappingsProviderSamlRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return SAMLPropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsProviderSamlRetrieveExecute(r ApiPropertymappingsProviderSamlRetrieveRequest) (*SAMLPropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SAMLPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderSamlRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/saml/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderSamlUpdateRequest struct {
	ctx                        context.Context
	ApiService                 *PropertymappingsAPIService
	pmUuid                     string
	sAMLPropertyMappingRequest *SAMLPropertyMappingRequest
}

func (r ApiPropertymappingsProviderSamlUpdateRequest) SAMLPropertyMappingRequest(sAMLPropertyMappingRequest SAMLPropertyMappingRequest) ApiPropertymappingsProviderSamlUpdateRequest {
	r.sAMLPropertyMappingRequest = &sAMLPropertyMappingRequest
	return r
}

func (r ApiPropertymappingsProviderSamlUpdateRequest) Execute() (*SAMLPropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderSamlUpdateExecute(r)
}

/*
PropertymappingsProviderSamlUpdate Method for PropertymappingsProviderSamlUpdate

SAMLPropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SAML Provider Property Mapping.
	@return ApiPropertymappingsProviderSamlUpdateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderSamlUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsProviderSamlUpdateRequest {
	return ApiPropertymappingsProviderSamlUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return SAMLPropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsProviderSamlUpdateExecute(r ApiPropertymappingsProviderSamlUpdateRequest) (*SAMLPropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SAMLPropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderSamlUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/saml/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sAMLPropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("sAMLPropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sAMLPropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderSamlUsedByListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsProviderSamlUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderSamlUsedByListExecute(r)
}

/*
PropertymappingsProviderSamlUsedByList Method for PropertymappingsProviderSamlUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SAML Provider Property Mapping.
	@return ApiPropertymappingsProviderSamlUsedByListRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderSamlUsedByList(ctx context.Context, pmUuid string) ApiPropertymappingsProviderSamlUsedByListRequest {
	return ApiPropertymappingsProviderSamlUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *PropertymappingsAPIService) PropertymappingsProviderSamlUsedByListExecute(r ApiPropertymappingsProviderSamlUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderSamlUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/saml/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderScimCreateRequest struct {
	ctx                context.Context
	ApiService         *PropertymappingsAPIService
	sCIMMappingRequest *SCIMMappingRequest
}

func (r ApiPropertymappingsProviderScimCreateRequest) SCIMMappingRequest(sCIMMappingRequest SCIMMappingRequest) ApiPropertymappingsProviderScimCreateRequest {
	r.sCIMMappingRequest = &sCIMMappingRequest
	return r
}

func (r ApiPropertymappingsProviderScimCreateRequest) Execute() (*SCIMMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderScimCreateExecute(r)
}

/*
PropertymappingsProviderScimCreate Method for PropertymappingsProviderScimCreate

SCIMMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsProviderScimCreateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderScimCreate(ctx context.Context) ApiPropertymappingsProviderScimCreateRequest {
	return ApiPropertymappingsProviderScimCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SCIMMapping
func (a *PropertymappingsAPIService) PropertymappingsProviderScimCreateExecute(r ApiPropertymappingsProviderScimCreateRequest) (*SCIMMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SCIMMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderScimCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/scim/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sCIMMappingRequest == nil {
		return localVarReturnValue, nil, reportError("sCIMMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sCIMMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderScimDestroyRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsProviderScimDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PropertymappingsProviderScimDestroyExecute(r)
}

/*
PropertymappingsProviderScimDestroy Method for PropertymappingsProviderScimDestroy

SCIMMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SCIM Provider Mapping.
	@return ApiPropertymappingsProviderScimDestroyRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderScimDestroy(ctx context.Context, pmUuid string) ApiPropertymappingsProviderScimDestroyRequest {
	return ApiPropertymappingsProviderScimDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsAPIService) PropertymappingsProviderScimDestroyExecute(r ApiPropertymappingsProviderScimDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderScimDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/scim/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderScimListRequest struct {
	ctx           context.Context
	ApiService    *PropertymappingsAPIService
	managed       *[]string
	managedIsnull *bool
	name          *string
	ordering      *string
	page          *int32
	pageSize      *int32
	search        *string
}

func (r ApiPropertymappingsProviderScimListRequest) Managed(managed []string) ApiPropertymappingsProviderScimListRequest {
	r.managed = &managed
	return r
}

func (r ApiPropertymappingsProviderScimListRequest) ManagedIsnull(managedIsnull bool) ApiPropertymappingsProviderScimListRequest {
	r.managedIsnull = &managedIsnull
	return r
}

func (r ApiPropertymappingsProviderScimListRequest) Name(name string) ApiPropertymappingsProviderScimListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsProviderScimListRequest) Ordering(ordering string) ApiPropertymappingsProviderScimListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsProviderScimListRequest) Page(page int32) ApiPropertymappingsProviderScimListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsProviderScimListRequest) PageSize(pageSize int32) ApiPropertymappingsProviderScimListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiPropertymappingsProviderScimListRequest) Search(search string) ApiPropertymappingsProviderScimListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsProviderScimListRequest) Execute() (*PaginatedSCIMMappingList, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderScimListExecute(r)
}

/*
PropertymappingsProviderScimList Method for PropertymappingsProviderScimList

SCIMMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsProviderScimListRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderScimList(ctx context.Context) ApiPropertymappingsProviderScimListRequest {
	return ApiPropertymappingsProviderScimListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedSCIMMappingList
func (a *PropertymappingsAPIService) PropertymappingsProviderScimListExecute(r ApiPropertymappingsProviderScimListRequest) (*PaginatedSCIMMappingList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedSCIMMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderScimList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/scim/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.managed != nil {
		t := *r.managed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "managed", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "managed", t, "form", "multi")
		}
	}
	if r.managedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "managed__isnull", r.managedIsnull, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderScimPartialUpdateRequest struct {
	ctx                       context.Context
	ApiService                *PropertymappingsAPIService
	pmUuid                    string
	patchedSCIMMappingRequest *PatchedSCIMMappingRequest
}

func (r ApiPropertymappingsProviderScimPartialUpdateRequest) PatchedSCIMMappingRequest(patchedSCIMMappingRequest PatchedSCIMMappingRequest) ApiPropertymappingsProviderScimPartialUpdateRequest {
	r.patchedSCIMMappingRequest = &patchedSCIMMappingRequest
	return r
}

func (r ApiPropertymappingsProviderScimPartialUpdateRequest) Execute() (*SCIMMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderScimPartialUpdateExecute(r)
}

/*
PropertymappingsProviderScimPartialUpdate Method for PropertymappingsProviderScimPartialUpdate

SCIMMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SCIM Provider Mapping.
	@return ApiPropertymappingsProviderScimPartialUpdateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderScimPartialUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsProviderScimPartialUpdateRequest {
	return ApiPropertymappingsProviderScimPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return SCIMMapping
func (a *PropertymappingsAPIService) PropertymappingsProviderScimPartialUpdateExecute(r ApiPropertymappingsProviderScimPartialUpdateRequest) (*SCIMMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SCIMMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderScimPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/scim/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedSCIMMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderScimRetrieveRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsProviderScimRetrieveRequest) Execute() (*SCIMMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderScimRetrieveExecute(r)
}

/*
PropertymappingsProviderScimRetrieve Method for PropertymappingsProviderScimRetrieve

SCIMMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SCIM Provider Mapping.
	@return ApiPropertymappingsProviderScimRetrieveRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderScimRetrieve(ctx context.Context, pmUuid string) ApiPropertymappingsProviderScimRetrieveRequest {
	return ApiPropertymappingsProviderScimRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return SCIMMapping
func (a *PropertymappingsAPIService) PropertymappingsProviderScimRetrieveExecute(r ApiPropertymappingsProviderScimRetrieveRequest) (*SCIMMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SCIMMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderScimRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/scim/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderScimUpdateRequest struct {
	ctx                context.Context
	ApiService         *PropertymappingsAPIService
	pmUuid             string
	sCIMMappingRequest *SCIMMappingRequest
}

func (r ApiPropertymappingsProviderScimUpdateRequest) SCIMMappingRequest(sCIMMappingRequest SCIMMappingRequest) ApiPropertymappingsProviderScimUpdateRequest {
	r.sCIMMappingRequest = &sCIMMappingRequest
	return r
}

func (r ApiPropertymappingsProviderScimUpdateRequest) Execute() (*SCIMMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderScimUpdateExecute(r)
}

/*
PropertymappingsProviderScimUpdate Method for PropertymappingsProviderScimUpdate

SCIMMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SCIM Provider Mapping.
	@return ApiPropertymappingsProviderScimUpdateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderScimUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsProviderScimUpdateRequest {
	return ApiPropertymappingsProviderScimUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return SCIMMapping
func (a *PropertymappingsAPIService) PropertymappingsProviderScimUpdateExecute(r ApiPropertymappingsProviderScimUpdateRequest) (*SCIMMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SCIMMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderScimUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/scim/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sCIMMappingRequest == nil {
		return localVarReturnValue, nil, reportError("sCIMMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sCIMMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderScimUsedByListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsProviderScimUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderScimUsedByListExecute(r)
}

/*
PropertymappingsProviderScimUsedByList Method for PropertymappingsProviderScimUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SCIM Provider Mapping.
	@return ApiPropertymappingsProviderScimUsedByListRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderScimUsedByList(ctx context.Context, pmUuid string) ApiPropertymappingsProviderScimUsedByListRequest {
	return ApiPropertymappingsProviderScimUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *PropertymappingsAPIService) PropertymappingsProviderScimUsedByListExecute(r ApiPropertymappingsProviderScimUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderScimUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/scim/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderScopeCreateRequest struct {
	ctx                 context.Context
	ApiService          *PropertymappingsAPIService
	scopeMappingRequest *ScopeMappingRequest
}

func (r ApiPropertymappingsProviderScopeCreateRequest) ScopeMappingRequest(scopeMappingRequest ScopeMappingRequest) ApiPropertymappingsProviderScopeCreateRequest {
	r.scopeMappingRequest = &scopeMappingRequest
	return r
}

func (r ApiPropertymappingsProviderScopeCreateRequest) Execute() (*ScopeMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderScopeCreateExecute(r)
}

/*
PropertymappingsProviderScopeCreate Method for PropertymappingsProviderScopeCreate

ScopeMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsProviderScopeCreateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderScopeCreate(ctx context.Context) ApiPropertymappingsProviderScopeCreateRequest {
	return ApiPropertymappingsProviderScopeCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ScopeMapping
func (a *PropertymappingsAPIService) PropertymappingsProviderScopeCreateExecute(r ApiPropertymappingsProviderScopeCreateRequest) (*ScopeMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ScopeMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderScopeCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/scope/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.scopeMappingRequest == nil {
		return localVarReturnValue, nil, reportError("scopeMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.scopeMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderScopeDestroyRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsProviderScopeDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PropertymappingsProviderScopeDestroyExecute(r)
}

/*
PropertymappingsProviderScopeDestroy Method for PropertymappingsProviderScopeDestroy

ScopeMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Scope Mapping.
	@return ApiPropertymappingsProviderScopeDestroyRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderScopeDestroy(ctx context.Context, pmUuid string) ApiPropertymappingsProviderScopeDestroyRequest {
	return ApiPropertymappingsProviderScopeDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsAPIService) PropertymappingsProviderScopeDestroyExecute(r ApiPropertymappingsProviderScopeDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderScopeDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/scope/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderScopeListRequest struct {
	ctx           context.Context
	ApiService    *PropertymappingsAPIService
	managed       *[]string
	managedIsnull *bool
	name          *string
	ordering      *string
	page          *int32
	pageSize      *int32
	scopeName     *string
	search        *string
}

func (r ApiPropertymappingsProviderScopeListRequest) Managed(managed []string) ApiPropertymappingsProviderScopeListRequest {
	r.managed = &managed
	return r
}

func (r ApiPropertymappingsProviderScopeListRequest) ManagedIsnull(managedIsnull bool) ApiPropertymappingsProviderScopeListRequest {
	r.managedIsnull = &managedIsnull
	return r
}

func (r ApiPropertymappingsProviderScopeListRequest) Name(name string) ApiPropertymappingsProviderScopeListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsProviderScopeListRequest) Ordering(ordering string) ApiPropertymappingsProviderScopeListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsProviderScopeListRequest) Page(page int32) ApiPropertymappingsProviderScopeListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsProviderScopeListRequest) PageSize(pageSize int32) ApiPropertymappingsProviderScopeListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiPropertymappingsProviderScopeListRequest) ScopeName(scopeName string) ApiPropertymappingsProviderScopeListRequest {
	r.scopeName = &scopeName
	return r
}

// A search term.
func (r ApiPropertymappingsProviderScopeListRequest) Search(search string) ApiPropertymappingsProviderScopeListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsProviderScopeListRequest) Execute() (*PaginatedScopeMappingList, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderScopeListExecute(r)
}

/*
PropertymappingsProviderScopeList Method for PropertymappingsProviderScopeList

ScopeMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsProviderScopeListRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderScopeList(ctx context.Context) ApiPropertymappingsProviderScopeListRequest {
	return ApiPropertymappingsProviderScopeListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedScopeMappingList
func (a *PropertymappingsAPIService) PropertymappingsProviderScopeListExecute(r ApiPropertymappingsProviderScopeListRequest) (*PaginatedScopeMappingList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedScopeMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderScopeList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/scope/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.managed != nil {
		t := *r.managed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "managed", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "managed", t, "form", "multi")
		}
	}
	if r.managedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "managed__isnull", r.managedIsnull, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.scopeName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope_name", r.scopeName, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderScopePartialUpdateRequest struct {
	ctx                        context.Context
	ApiService                 *PropertymappingsAPIService
	pmUuid                     string
	patchedScopeMappingRequest *PatchedScopeMappingRequest
}

func (r ApiPropertymappingsProviderScopePartialUpdateRequest) PatchedScopeMappingRequest(patchedScopeMappingRequest PatchedScopeMappingRequest) ApiPropertymappingsProviderScopePartialUpdateRequest {
	r.patchedScopeMappingRequest = &patchedScopeMappingRequest
	return r
}

func (r ApiPropertymappingsProviderScopePartialUpdateRequest) Execute() (*ScopeMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderScopePartialUpdateExecute(r)
}

/*
PropertymappingsProviderScopePartialUpdate Method for PropertymappingsProviderScopePartialUpdate

ScopeMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Scope Mapping.
	@return ApiPropertymappingsProviderScopePartialUpdateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderScopePartialUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsProviderScopePartialUpdateRequest {
	return ApiPropertymappingsProviderScopePartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return ScopeMapping
func (a *PropertymappingsAPIService) PropertymappingsProviderScopePartialUpdateExecute(r ApiPropertymappingsProviderScopePartialUpdateRequest) (*ScopeMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ScopeMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderScopePartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/scope/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedScopeMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderScopeRetrieveRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsProviderScopeRetrieveRequest) Execute() (*ScopeMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderScopeRetrieveExecute(r)
}

/*
PropertymappingsProviderScopeRetrieve Method for PropertymappingsProviderScopeRetrieve

ScopeMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Scope Mapping.
	@return ApiPropertymappingsProviderScopeRetrieveRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderScopeRetrieve(ctx context.Context, pmUuid string) ApiPropertymappingsProviderScopeRetrieveRequest {
	return ApiPropertymappingsProviderScopeRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return ScopeMapping
func (a *PropertymappingsAPIService) PropertymappingsProviderScopeRetrieveExecute(r ApiPropertymappingsProviderScopeRetrieveRequest) (*ScopeMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ScopeMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderScopeRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/scope/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderScopeUpdateRequest struct {
	ctx                 context.Context
	ApiService          *PropertymappingsAPIService
	pmUuid              string
	scopeMappingRequest *ScopeMappingRequest
}

func (r ApiPropertymappingsProviderScopeUpdateRequest) ScopeMappingRequest(scopeMappingRequest ScopeMappingRequest) ApiPropertymappingsProviderScopeUpdateRequest {
	r.scopeMappingRequest = &scopeMappingRequest
	return r
}

func (r ApiPropertymappingsProviderScopeUpdateRequest) Execute() (*ScopeMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderScopeUpdateExecute(r)
}

/*
PropertymappingsProviderScopeUpdate Method for PropertymappingsProviderScopeUpdate

ScopeMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Scope Mapping.
	@return ApiPropertymappingsProviderScopeUpdateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderScopeUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsProviderScopeUpdateRequest {
	return ApiPropertymappingsProviderScopeUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return ScopeMapping
func (a *PropertymappingsAPIService) PropertymappingsProviderScopeUpdateExecute(r ApiPropertymappingsProviderScopeUpdateRequest) (*ScopeMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ScopeMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderScopeUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/scope/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.scopeMappingRequest == nil {
		return localVarReturnValue, nil, reportError("scopeMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.scopeMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsProviderScopeUsedByListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsProviderScopeUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.PropertymappingsProviderScopeUsedByListExecute(r)
}

/*
PropertymappingsProviderScopeUsedByList Method for PropertymappingsProviderScopeUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Scope Mapping.
	@return ApiPropertymappingsProviderScopeUsedByListRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsProviderScopeUsedByList(ctx context.Context, pmUuid string) ApiPropertymappingsProviderScopeUsedByListRequest {
	return ApiPropertymappingsProviderScopeUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *PropertymappingsAPIService) PropertymappingsProviderScopeUsedByListExecute(r ApiPropertymappingsProviderScopeUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsProviderScopeUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/provider/scope/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceKerberosCreateRequest struct {
	ctx                                  context.Context
	ApiService                           *PropertymappingsAPIService
	kerberosSourcePropertyMappingRequest *KerberosSourcePropertyMappingRequest
}

func (r ApiPropertymappingsSourceKerberosCreateRequest) KerberosSourcePropertyMappingRequest(kerberosSourcePropertyMappingRequest KerberosSourcePropertyMappingRequest) ApiPropertymappingsSourceKerberosCreateRequest {
	r.kerberosSourcePropertyMappingRequest = &kerberosSourcePropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSourceKerberosCreateRequest) Execute() (*KerberosSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceKerberosCreateExecute(r)
}

/*
PropertymappingsSourceKerberosCreate Method for PropertymappingsSourceKerberosCreate

KerberosSource PropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsSourceKerberosCreateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceKerberosCreate(ctx context.Context) ApiPropertymappingsSourceKerberosCreateRequest {
	return ApiPropertymappingsSourceKerberosCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return KerberosSourcePropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsSourceKerberosCreateExecute(r ApiPropertymappingsSourceKerberosCreateRequest) (*KerberosSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KerberosSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceKerberosCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/kerberos/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kerberosSourcePropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("kerberosSourcePropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.kerberosSourcePropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceKerberosDestroyRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsSourceKerberosDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PropertymappingsSourceKerberosDestroyExecute(r)
}

/*
PropertymappingsSourceKerberosDestroy Method for PropertymappingsSourceKerberosDestroy

KerberosSource PropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Kerberos Source Property Mapping.
	@return ApiPropertymappingsSourceKerberosDestroyRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceKerberosDestroy(ctx context.Context, pmUuid string) ApiPropertymappingsSourceKerberosDestroyRequest {
	return ApiPropertymappingsSourceKerberosDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsAPIService) PropertymappingsSourceKerberosDestroyExecute(r ApiPropertymappingsSourceKerberosDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceKerberosDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/kerberos/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceKerberosListRequest struct {
	ctx           context.Context
	ApiService    *PropertymappingsAPIService
	managed       *[]string
	managedIsnull *bool
	name          *string
	ordering      *string
	page          *int32
	pageSize      *int32
	search        *string
}

func (r ApiPropertymappingsSourceKerberosListRequest) Managed(managed []string) ApiPropertymappingsSourceKerberosListRequest {
	r.managed = &managed
	return r
}

func (r ApiPropertymappingsSourceKerberosListRequest) ManagedIsnull(managedIsnull bool) ApiPropertymappingsSourceKerberosListRequest {
	r.managedIsnull = &managedIsnull
	return r
}

func (r ApiPropertymappingsSourceKerberosListRequest) Name(name string) ApiPropertymappingsSourceKerberosListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsSourceKerberosListRequest) Ordering(ordering string) ApiPropertymappingsSourceKerberosListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsSourceKerberosListRequest) Page(page int32) ApiPropertymappingsSourceKerberosListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsSourceKerberosListRequest) PageSize(pageSize int32) ApiPropertymappingsSourceKerberosListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiPropertymappingsSourceKerberosListRequest) Search(search string) ApiPropertymappingsSourceKerberosListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsSourceKerberosListRequest) Execute() (*PaginatedKerberosSourcePropertyMappingList, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceKerberosListExecute(r)
}

/*
PropertymappingsSourceKerberosList Method for PropertymappingsSourceKerberosList

KerberosSource PropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsSourceKerberosListRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceKerberosList(ctx context.Context) ApiPropertymappingsSourceKerberosListRequest {
	return ApiPropertymappingsSourceKerberosListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedKerberosSourcePropertyMappingList
func (a *PropertymappingsAPIService) PropertymappingsSourceKerberosListExecute(r ApiPropertymappingsSourceKerberosListRequest) (*PaginatedKerberosSourcePropertyMappingList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedKerberosSourcePropertyMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceKerberosList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/kerberos/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.managed != nil {
		t := *r.managed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "managed", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "managed", t, "form", "multi")
		}
	}
	if r.managedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "managed__isnull", r.managedIsnull, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceKerberosPartialUpdateRequest struct {
	ctx                                         context.Context
	ApiService                                  *PropertymappingsAPIService
	pmUuid                                      string
	patchedKerberosSourcePropertyMappingRequest *PatchedKerberosSourcePropertyMappingRequest
}

func (r ApiPropertymappingsSourceKerberosPartialUpdateRequest) PatchedKerberosSourcePropertyMappingRequest(patchedKerberosSourcePropertyMappingRequest PatchedKerberosSourcePropertyMappingRequest) ApiPropertymappingsSourceKerberosPartialUpdateRequest {
	r.patchedKerberosSourcePropertyMappingRequest = &patchedKerberosSourcePropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSourceKerberosPartialUpdateRequest) Execute() (*KerberosSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceKerberosPartialUpdateExecute(r)
}

/*
PropertymappingsSourceKerberosPartialUpdate Method for PropertymappingsSourceKerberosPartialUpdate

KerberosSource PropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Kerberos Source Property Mapping.
	@return ApiPropertymappingsSourceKerberosPartialUpdateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceKerberosPartialUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsSourceKerberosPartialUpdateRequest {
	return ApiPropertymappingsSourceKerberosPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return KerberosSourcePropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsSourceKerberosPartialUpdateExecute(r ApiPropertymappingsSourceKerberosPartialUpdateRequest) (*KerberosSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KerberosSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceKerberosPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/kerberos/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedKerberosSourcePropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceKerberosRetrieveRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsSourceKerberosRetrieveRequest) Execute() (*KerberosSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceKerberosRetrieveExecute(r)
}

/*
PropertymappingsSourceKerberosRetrieve Method for PropertymappingsSourceKerberosRetrieve

KerberosSource PropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Kerberos Source Property Mapping.
	@return ApiPropertymappingsSourceKerberosRetrieveRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceKerberosRetrieve(ctx context.Context, pmUuid string) ApiPropertymappingsSourceKerberosRetrieveRequest {
	return ApiPropertymappingsSourceKerberosRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return KerberosSourcePropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsSourceKerberosRetrieveExecute(r ApiPropertymappingsSourceKerberosRetrieveRequest) (*KerberosSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KerberosSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceKerberosRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/kerberos/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceKerberosUpdateRequest struct {
	ctx                                  context.Context
	ApiService                           *PropertymappingsAPIService
	pmUuid                               string
	kerberosSourcePropertyMappingRequest *KerberosSourcePropertyMappingRequest
}

func (r ApiPropertymappingsSourceKerberosUpdateRequest) KerberosSourcePropertyMappingRequest(kerberosSourcePropertyMappingRequest KerberosSourcePropertyMappingRequest) ApiPropertymappingsSourceKerberosUpdateRequest {
	r.kerberosSourcePropertyMappingRequest = &kerberosSourcePropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSourceKerberosUpdateRequest) Execute() (*KerberosSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceKerberosUpdateExecute(r)
}

/*
PropertymappingsSourceKerberosUpdate Method for PropertymappingsSourceKerberosUpdate

KerberosSource PropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Kerberos Source Property Mapping.
	@return ApiPropertymappingsSourceKerberosUpdateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceKerberosUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsSourceKerberosUpdateRequest {
	return ApiPropertymappingsSourceKerberosUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return KerberosSourcePropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsSourceKerberosUpdateExecute(r ApiPropertymappingsSourceKerberosUpdateRequest) (*KerberosSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KerberosSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceKerberosUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/kerberos/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kerberosSourcePropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("kerberosSourcePropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.kerberosSourcePropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceKerberosUsedByListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsSourceKerberosUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceKerberosUsedByListExecute(r)
}

/*
PropertymappingsSourceKerberosUsedByList Method for PropertymappingsSourceKerberosUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Kerberos Source Property Mapping.
	@return ApiPropertymappingsSourceKerberosUsedByListRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceKerberosUsedByList(ctx context.Context, pmUuid string) ApiPropertymappingsSourceKerberosUsedByListRequest {
	return ApiPropertymappingsSourceKerberosUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *PropertymappingsAPIService) PropertymappingsSourceKerberosUsedByListExecute(r ApiPropertymappingsSourceKerberosUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceKerberosUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/kerberos/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceLdapCreateRequest struct {
	ctx                              context.Context
	ApiService                       *PropertymappingsAPIService
	lDAPSourcePropertyMappingRequest *LDAPSourcePropertyMappingRequest
}

func (r ApiPropertymappingsSourceLdapCreateRequest) LDAPSourcePropertyMappingRequest(lDAPSourcePropertyMappingRequest LDAPSourcePropertyMappingRequest) ApiPropertymappingsSourceLdapCreateRequest {
	r.lDAPSourcePropertyMappingRequest = &lDAPSourcePropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSourceLdapCreateRequest) Execute() (*LDAPSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceLdapCreateExecute(r)
}

/*
PropertymappingsSourceLdapCreate Method for PropertymappingsSourceLdapCreate

LDAP PropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsSourceLdapCreateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceLdapCreate(ctx context.Context) ApiPropertymappingsSourceLdapCreateRequest {
	return ApiPropertymappingsSourceLdapCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return LDAPSourcePropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsSourceLdapCreateExecute(r ApiPropertymappingsSourceLdapCreateRequest) (*LDAPSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LDAPSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceLdapCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/ldap/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.lDAPSourcePropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("lDAPSourcePropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.lDAPSourcePropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceLdapDestroyRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsSourceLdapDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PropertymappingsSourceLdapDestroyExecute(r)
}

/*
PropertymappingsSourceLdapDestroy Method for PropertymappingsSourceLdapDestroy

LDAP PropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this LDAP Source Property Mapping.
	@return ApiPropertymappingsSourceLdapDestroyRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceLdapDestroy(ctx context.Context, pmUuid string) ApiPropertymappingsSourceLdapDestroyRequest {
	return ApiPropertymappingsSourceLdapDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsAPIService) PropertymappingsSourceLdapDestroyExecute(r ApiPropertymappingsSourceLdapDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceLdapDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/ldap/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceLdapListRequest struct {
	ctx           context.Context
	ApiService    *PropertymappingsAPIService
	managed       *[]string
	managedIsnull *bool
	name          *string
	ordering      *string
	page          *int32
	pageSize      *int32
	search        *string
}

func (r ApiPropertymappingsSourceLdapListRequest) Managed(managed []string) ApiPropertymappingsSourceLdapListRequest {
	r.managed = &managed
	return r
}

func (r ApiPropertymappingsSourceLdapListRequest) ManagedIsnull(managedIsnull bool) ApiPropertymappingsSourceLdapListRequest {
	r.managedIsnull = &managedIsnull
	return r
}

func (r ApiPropertymappingsSourceLdapListRequest) Name(name string) ApiPropertymappingsSourceLdapListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsSourceLdapListRequest) Ordering(ordering string) ApiPropertymappingsSourceLdapListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsSourceLdapListRequest) Page(page int32) ApiPropertymappingsSourceLdapListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsSourceLdapListRequest) PageSize(pageSize int32) ApiPropertymappingsSourceLdapListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiPropertymappingsSourceLdapListRequest) Search(search string) ApiPropertymappingsSourceLdapListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsSourceLdapListRequest) Execute() (*PaginatedLDAPSourcePropertyMappingList, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceLdapListExecute(r)
}

/*
PropertymappingsSourceLdapList Method for PropertymappingsSourceLdapList

LDAP PropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsSourceLdapListRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceLdapList(ctx context.Context) ApiPropertymappingsSourceLdapListRequest {
	return ApiPropertymappingsSourceLdapListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedLDAPSourcePropertyMappingList
func (a *PropertymappingsAPIService) PropertymappingsSourceLdapListExecute(r ApiPropertymappingsSourceLdapListRequest) (*PaginatedLDAPSourcePropertyMappingList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedLDAPSourcePropertyMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceLdapList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/ldap/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.managed != nil {
		t := *r.managed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "managed", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "managed", t, "form", "multi")
		}
	}
	if r.managedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "managed__isnull", r.managedIsnull, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceLdapPartialUpdateRequest struct {
	ctx                                     context.Context
	ApiService                              *PropertymappingsAPIService
	pmUuid                                  string
	patchedLDAPSourcePropertyMappingRequest *PatchedLDAPSourcePropertyMappingRequest
}

func (r ApiPropertymappingsSourceLdapPartialUpdateRequest) PatchedLDAPSourcePropertyMappingRequest(patchedLDAPSourcePropertyMappingRequest PatchedLDAPSourcePropertyMappingRequest) ApiPropertymappingsSourceLdapPartialUpdateRequest {
	r.patchedLDAPSourcePropertyMappingRequest = &patchedLDAPSourcePropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSourceLdapPartialUpdateRequest) Execute() (*LDAPSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceLdapPartialUpdateExecute(r)
}

/*
PropertymappingsSourceLdapPartialUpdate Method for PropertymappingsSourceLdapPartialUpdate

LDAP PropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this LDAP Source Property Mapping.
	@return ApiPropertymappingsSourceLdapPartialUpdateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceLdapPartialUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsSourceLdapPartialUpdateRequest {
	return ApiPropertymappingsSourceLdapPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return LDAPSourcePropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsSourceLdapPartialUpdateExecute(r ApiPropertymappingsSourceLdapPartialUpdateRequest) (*LDAPSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LDAPSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceLdapPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/ldap/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedLDAPSourcePropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceLdapRetrieveRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsSourceLdapRetrieveRequest) Execute() (*LDAPSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceLdapRetrieveExecute(r)
}

/*
PropertymappingsSourceLdapRetrieve Method for PropertymappingsSourceLdapRetrieve

LDAP PropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this LDAP Source Property Mapping.
	@return ApiPropertymappingsSourceLdapRetrieveRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceLdapRetrieve(ctx context.Context, pmUuid string) ApiPropertymappingsSourceLdapRetrieveRequest {
	return ApiPropertymappingsSourceLdapRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return LDAPSourcePropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsSourceLdapRetrieveExecute(r ApiPropertymappingsSourceLdapRetrieveRequest) (*LDAPSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LDAPSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceLdapRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/ldap/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceLdapUpdateRequest struct {
	ctx                              context.Context
	ApiService                       *PropertymappingsAPIService
	pmUuid                           string
	lDAPSourcePropertyMappingRequest *LDAPSourcePropertyMappingRequest
}

func (r ApiPropertymappingsSourceLdapUpdateRequest) LDAPSourcePropertyMappingRequest(lDAPSourcePropertyMappingRequest LDAPSourcePropertyMappingRequest) ApiPropertymappingsSourceLdapUpdateRequest {
	r.lDAPSourcePropertyMappingRequest = &lDAPSourcePropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSourceLdapUpdateRequest) Execute() (*LDAPSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceLdapUpdateExecute(r)
}

/*
PropertymappingsSourceLdapUpdate Method for PropertymappingsSourceLdapUpdate

LDAP PropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this LDAP Source Property Mapping.
	@return ApiPropertymappingsSourceLdapUpdateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceLdapUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsSourceLdapUpdateRequest {
	return ApiPropertymappingsSourceLdapUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return LDAPSourcePropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsSourceLdapUpdateExecute(r ApiPropertymappingsSourceLdapUpdateRequest) (*LDAPSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LDAPSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceLdapUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/ldap/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.lDAPSourcePropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("lDAPSourcePropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.lDAPSourcePropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceLdapUsedByListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsSourceLdapUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceLdapUsedByListExecute(r)
}

/*
PropertymappingsSourceLdapUsedByList Method for PropertymappingsSourceLdapUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this LDAP Source Property Mapping.
	@return ApiPropertymappingsSourceLdapUsedByListRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceLdapUsedByList(ctx context.Context, pmUuid string) ApiPropertymappingsSourceLdapUsedByListRequest {
	return ApiPropertymappingsSourceLdapUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *PropertymappingsAPIService) PropertymappingsSourceLdapUsedByListExecute(r ApiPropertymappingsSourceLdapUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceLdapUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/ldap/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceOauthCreateRequest struct {
	ctx                               context.Context
	ApiService                        *PropertymappingsAPIService
	oAuthSourcePropertyMappingRequest *OAuthSourcePropertyMappingRequest
}

func (r ApiPropertymappingsSourceOauthCreateRequest) OAuthSourcePropertyMappingRequest(oAuthSourcePropertyMappingRequest OAuthSourcePropertyMappingRequest) ApiPropertymappingsSourceOauthCreateRequest {
	r.oAuthSourcePropertyMappingRequest = &oAuthSourcePropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSourceOauthCreateRequest) Execute() (*OAuthSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceOauthCreateExecute(r)
}

/*
PropertymappingsSourceOauthCreate Method for PropertymappingsSourceOauthCreate

OAuthSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsSourceOauthCreateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceOauthCreate(ctx context.Context) ApiPropertymappingsSourceOauthCreateRequest {
	return ApiPropertymappingsSourceOauthCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return OAuthSourcePropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsSourceOauthCreateExecute(r ApiPropertymappingsSourceOauthCreateRequest) (*OAuthSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OAuthSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceOauthCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/oauth/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.oAuthSourcePropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("oAuthSourcePropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.oAuthSourcePropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceOauthDestroyRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsSourceOauthDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PropertymappingsSourceOauthDestroyExecute(r)
}

/*
PropertymappingsSourceOauthDestroy Method for PropertymappingsSourceOauthDestroy

OAuthSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this OAuth Source Property Mapping.
	@return ApiPropertymappingsSourceOauthDestroyRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceOauthDestroy(ctx context.Context, pmUuid string) ApiPropertymappingsSourceOauthDestroyRequest {
	return ApiPropertymappingsSourceOauthDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsAPIService) PropertymappingsSourceOauthDestroyExecute(r ApiPropertymappingsSourceOauthDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceOauthDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/oauth/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceOauthListRequest struct {
	ctx           context.Context
	ApiService    *PropertymappingsAPIService
	managed       *[]string
	managedIsnull *bool
	name          *string
	ordering      *string
	page          *int32
	pageSize      *int32
	search        *string
}

func (r ApiPropertymappingsSourceOauthListRequest) Managed(managed []string) ApiPropertymappingsSourceOauthListRequest {
	r.managed = &managed
	return r
}

func (r ApiPropertymappingsSourceOauthListRequest) ManagedIsnull(managedIsnull bool) ApiPropertymappingsSourceOauthListRequest {
	r.managedIsnull = &managedIsnull
	return r
}

func (r ApiPropertymappingsSourceOauthListRequest) Name(name string) ApiPropertymappingsSourceOauthListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsSourceOauthListRequest) Ordering(ordering string) ApiPropertymappingsSourceOauthListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsSourceOauthListRequest) Page(page int32) ApiPropertymappingsSourceOauthListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsSourceOauthListRequest) PageSize(pageSize int32) ApiPropertymappingsSourceOauthListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiPropertymappingsSourceOauthListRequest) Search(search string) ApiPropertymappingsSourceOauthListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsSourceOauthListRequest) Execute() (*PaginatedOAuthSourcePropertyMappingList, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceOauthListExecute(r)
}

/*
PropertymappingsSourceOauthList Method for PropertymappingsSourceOauthList

OAuthSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsSourceOauthListRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceOauthList(ctx context.Context) ApiPropertymappingsSourceOauthListRequest {
	return ApiPropertymappingsSourceOauthListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedOAuthSourcePropertyMappingList
func (a *PropertymappingsAPIService) PropertymappingsSourceOauthListExecute(r ApiPropertymappingsSourceOauthListRequest) (*PaginatedOAuthSourcePropertyMappingList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedOAuthSourcePropertyMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceOauthList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/oauth/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.managed != nil {
		t := *r.managed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "managed", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "managed", t, "form", "multi")
		}
	}
	if r.managedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "managed__isnull", r.managedIsnull, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceOauthPartialUpdateRequest struct {
	ctx                                      context.Context
	ApiService                               *PropertymappingsAPIService
	pmUuid                                   string
	patchedOAuthSourcePropertyMappingRequest *PatchedOAuthSourcePropertyMappingRequest
}

func (r ApiPropertymappingsSourceOauthPartialUpdateRequest) PatchedOAuthSourcePropertyMappingRequest(patchedOAuthSourcePropertyMappingRequest PatchedOAuthSourcePropertyMappingRequest) ApiPropertymappingsSourceOauthPartialUpdateRequest {
	r.patchedOAuthSourcePropertyMappingRequest = &patchedOAuthSourcePropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSourceOauthPartialUpdateRequest) Execute() (*OAuthSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceOauthPartialUpdateExecute(r)
}

/*
PropertymappingsSourceOauthPartialUpdate Method for PropertymappingsSourceOauthPartialUpdate

OAuthSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this OAuth Source Property Mapping.
	@return ApiPropertymappingsSourceOauthPartialUpdateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceOauthPartialUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsSourceOauthPartialUpdateRequest {
	return ApiPropertymappingsSourceOauthPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return OAuthSourcePropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsSourceOauthPartialUpdateExecute(r ApiPropertymappingsSourceOauthPartialUpdateRequest) (*OAuthSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OAuthSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceOauthPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/oauth/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedOAuthSourcePropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceOauthRetrieveRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsSourceOauthRetrieveRequest) Execute() (*OAuthSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceOauthRetrieveExecute(r)
}

/*
PropertymappingsSourceOauthRetrieve Method for PropertymappingsSourceOauthRetrieve

OAuthSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this OAuth Source Property Mapping.
	@return ApiPropertymappingsSourceOauthRetrieveRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceOauthRetrieve(ctx context.Context, pmUuid string) ApiPropertymappingsSourceOauthRetrieveRequest {
	return ApiPropertymappingsSourceOauthRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return OAuthSourcePropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsSourceOauthRetrieveExecute(r ApiPropertymappingsSourceOauthRetrieveRequest) (*OAuthSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OAuthSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceOauthRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/oauth/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceOauthUpdateRequest struct {
	ctx                               context.Context
	ApiService                        *PropertymappingsAPIService
	pmUuid                            string
	oAuthSourcePropertyMappingRequest *OAuthSourcePropertyMappingRequest
}

func (r ApiPropertymappingsSourceOauthUpdateRequest) OAuthSourcePropertyMappingRequest(oAuthSourcePropertyMappingRequest OAuthSourcePropertyMappingRequest) ApiPropertymappingsSourceOauthUpdateRequest {
	r.oAuthSourcePropertyMappingRequest = &oAuthSourcePropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSourceOauthUpdateRequest) Execute() (*OAuthSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceOauthUpdateExecute(r)
}

/*
PropertymappingsSourceOauthUpdate Method for PropertymappingsSourceOauthUpdate

OAuthSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this OAuth Source Property Mapping.
	@return ApiPropertymappingsSourceOauthUpdateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceOauthUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsSourceOauthUpdateRequest {
	return ApiPropertymappingsSourceOauthUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return OAuthSourcePropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsSourceOauthUpdateExecute(r ApiPropertymappingsSourceOauthUpdateRequest) (*OAuthSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OAuthSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceOauthUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/oauth/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.oAuthSourcePropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("oAuthSourcePropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.oAuthSourcePropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceOauthUsedByListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsSourceOauthUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceOauthUsedByListExecute(r)
}

/*
PropertymappingsSourceOauthUsedByList Method for PropertymappingsSourceOauthUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this OAuth Source Property Mapping.
	@return ApiPropertymappingsSourceOauthUsedByListRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceOauthUsedByList(ctx context.Context, pmUuid string) ApiPropertymappingsSourceOauthUsedByListRequest {
	return ApiPropertymappingsSourceOauthUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *PropertymappingsAPIService) PropertymappingsSourceOauthUsedByListExecute(r ApiPropertymappingsSourceOauthUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceOauthUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/oauth/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourcePlexCreateRequest struct {
	ctx                              context.Context
	ApiService                       *PropertymappingsAPIService
	plexSourcePropertyMappingRequest *PlexSourcePropertyMappingRequest
}

func (r ApiPropertymappingsSourcePlexCreateRequest) PlexSourcePropertyMappingRequest(plexSourcePropertyMappingRequest PlexSourcePropertyMappingRequest) ApiPropertymappingsSourcePlexCreateRequest {
	r.plexSourcePropertyMappingRequest = &plexSourcePropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSourcePlexCreateRequest) Execute() (*PlexSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourcePlexCreateExecute(r)
}

/*
PropertymappingsSourcePlexCreate Method for PropertymappingsSourcePlexCreate

PlexSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsSourcePlexCreateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourcePlexCreate(ctx context.Context) ApiPropertymappingsSourcePlexCreateRequest {
	return ApiPropertymappingsSourcePlexCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PlexSourcePropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsSourcePlexCreateExecute(r ApiPropertymappingsSourcePlexCreateRequest) (*PlexSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PlexSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourcePlexCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/plex/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.plexSourcePropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("plexSourcePropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.plexSourcePropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourcePlexDestroyRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsSourcePlexDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PropertymappingsSourcePlexDestroyExecute(r)
}

/*
PropertymappingsSourcePlexDestroy Method for PropertymappingsSourcePlexDestroy

PlexSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Plex Source Property Mapping.
	@return ApiPropertymappingsSourcePlexDestroyRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourcePlexDestroy(ctx context.Context, pmUuid string) ApiPropertymappingsSourcePlexDestroyRequest {
	return ApiPropertymappingsSourcePlexDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsAPIService) PropertymappingsSourcePlexDestroyExecute(r ApiPropertymappingsSourcePlexDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourcePlexDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/plex/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsSourcePlexListRequest struct {
	ctx           context.Context
	ApiService    *PropertymappingsAPIService
	managed       *[]string
	managedIsnull *bool
	name          *string
	ordering      *string
	page          *int32
	pageSize      *int32
	search        *string
}

func (r ApiPropertymappingsSourcePlexListRequest) Managed(managed []string) ApiPropertymappingsSourcePlexListRequest {
	r.managed = &managed
	return r
}

func (r ApiPropertymappingsSourcePlexListRequest) ManagedIsnull(managedIsnull bool) ApiPropertymappingsSourcePlexListRequest {
	r.managedIsnull = &managedIsnull
	return r
}

func (r ApiPropertymappingsSourcePlexListRequest) Name(name string) ApiPropertymappingsSourcePlexListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsSourcePlexListRequest) Ordering(ordering string) ApiPropertymappingsSourcePlexListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsSourcePlexListRequest) Page(page int32) ApiPropertymappingsSourcePlexListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsSourcePlexListRequest) PageSize(pageSize int32) ApiPropertymappingsSourcePlexListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiPropertymappingsSourcePlexListRequest) Search(search string) ApiPropertymappingsSourcePlexListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsSourcePlexListRequest) Execute() (*PaginatedPlexSourcePropertyMappingList, *http.Response, error) {
	return r.ApiService.PropertymappingsSourcePlexListExecute(r)
}

/*
PropertymappingsSourcePlexList Method for PropertymappingsSourcePlexList

PlexSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsSourcePlexListRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourcePlexList(ctx context.Context) ApiPropertymappingsSourcePlexListRequest {
	return ApiPropertymappingsSourcePlexListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedPlexSourcePropertyMappingList
func (a *PropertymappingsAPIService) PropertymappingsSourcePlexListExecute(r ApiPropertymappingsSourcePlexListRequest) (*PaginatedPlexSourcePropertyMappingList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedPlexSourcePropertyMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourcePlexList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/plex/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.managed != nil {
		t := *r.managed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "managed", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "managed", t, "form", "multi")
		}
	}
	if r.managedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "managed__isnull", r.managedIsnull, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourcePlexPartialUpdateRequest struct {
	ctx                                     context.Context
	ApiService                              *PropertymappingsAPIService
	pmUuid                                  string
	patchedPlexSourcePropertyMappingRequest *PatchedPlexSourcePropertyMappingRequest
}

func (r ApiPropertymappingsSourcePlexPartialUpdateRequest) PatchedPlexSourcePropertyMappingRequest(patchedPlexSourcePropertyMappingRequest PatchedPlexSourcePropertyMappingRequest) ApiPropertymappingsSourcePlexPartialUpdateRequest {
	r.patchedPlexSourcePropertyMappingRequest = &patchedPlexSourcePropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSourcePlexPartialUpdateRequest) Execute() (*PlexSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourcePlexPartialUpdateExecute(r)
}

/*
PropertymappingsSourcePlexPartialUpdate Method for PropertymappingsSourcePlexPartialUpdate

PlexSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Plex Source Property Mapping.
	@return ApiPropertymappingsSourcePlexPartialUpdateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourcePlexPartialUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsSourcePlexPartialUpdateRequest {
	return ApiPropertymappingsSourcePlexPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return PlexSourcePropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsSourcePlexPartialUpdateExecute(r ApiPropertymappingsSourcePlexPartialUpdateRequest) (*PlexSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PlexSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourcePlexPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/plex/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedPlexSourcePropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourcePlexRetrieveRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsSourcePlexRetrieveRequest) Execute() (*PlexSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourcePlexRetrieveExecute(r)
}

/*
PropertymappingsSourcePlexRetrieve Method for PropertymappingsSourcePlexRetrieve

PlexSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Plex Source Property Mapping.
	@return ApiPropertymappingsSourcePlexRetrieveRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourcePlexRetrieve(ctx context.Context, pmUuid string) ApiPropertymappingsSourcePlexRetrieveRequest {
	return ApiPropertymappingsSourcePlexRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return PlexSourcePropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsSourcePlexRetrieveExecute(r ApiPropertymappingsSourcePlexRetrieveRequest) (*PlexSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PlexSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourcePlexRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/plex/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourcePlexUpdateRequest struct {
	ctx                              context.Context
	ApiService                       *PropertymappingsAPIService
	pmUuid                           string
	plexSourcePropertyMappingRequest *PlexSourcePropertyMappingRequest
}

func (r ApiPropertymappingsSourcePlexUpdateRequest) PlexSourcePropertyMappingRequest(plexSourcePropertyMappingRequest PlexSourcePropertyMappingRequest) ApiPropertymappingsSourcePlexUpdateRequest {
	r.plexSourcePropertyMappingRequest = &plexSourcePropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSourcePlexUpdateRequest) Execute() (*PlexSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourcePlexUpdateExecute(r)
}

/*
PropertymappingsSourcePlexUpdate Method for PropertymappingsSourcePlexUpdate

PlexSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Plex Source Property Mapping.
	@return ApiPropertymappingsSourcePlexUpdateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourcePlexUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsSourcePlexUpdateRequest {
	return ApiPropertymappingsSourcePlexUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return PlexSourcePropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsSourcePlexUpdateExecute(r ApiPropertymappingsSourcePlexUpdateRequest) (*PlexSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PlexSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourcePlexUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/plex/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.plexSourcePropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("plexSourcePropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.plexSourcePropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourcePlexUsedByListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsSourcePlexUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.PropertymappingsSourcePlexUsedByListExecute(r)
}

/*
PropertymappingsSourcePlexUsedByList Method for PropertymappingsSourcePlexUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this Plex Source Property Mapping.
	@return ApiPropertymappingsSourcePlexUsedByListRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourcePlexUsedByList(ctx context.Context, pmUuid string) ApiPropertymappingsSourcePlexUsedByListRequest {
	return ApiPropertymappingsSourcePlexUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *PropertymappingsAPIService) PropertymappingsSourcePlexUsedByListExecute(r ApiPropertymappingsSourcePlexUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourcePlexUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/plex/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceSamlCreateRequest struct {
	ctx                              context.Context
	ApiService                       *PropertymappingsAPIService
	sAMLSourcePropertyMappingRequest *SAMLSourcePropertyMappingRequest
}

func (r ApiPropertymappingsSourceSamlCreateRequest) SAMLSourcePropertyMappingRequest(sAMLSourcePropertyMappingRequest SAMLSourcePropertyMappingRequest) ApiPropertymappingsSourceSamlCreateRequest {
	r.sAMLSourcePropertyMappingRequest = &sAMLSourcePropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSourceSamlCreateRequest) Execute() (*SAMLSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceSamlCreateExecute(r)
}

/*
PropertymappingsSourceSamlCreate Method for PropertymappingsSourceSamlCreate

SAMLSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsSourceSamlCreateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceSamlCreate(ctx context.Context) ApiPropertymappingsSourceSamlCreateRequest {
	return ApiPropertymappingsSourceSamlCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SAMLSourcePropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsSourceSamlCreateExecute(r ApiPropertymappingsSourceSamlCreateRequest) (*SAMLSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SAMLSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceSamlCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/saml/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sAMLSourcePropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("sAMLSourcePropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sAMLSourcePropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceSamlDestroyRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsSourceSamlDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PropertymappingsSourceSamlDestroyExecute(r)
}

/*
PropertymappingsSourceSamlDestroy Method for PropertymappingsSourceSamlDestroy

SAMLSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SAML Source Property Mapping.
	@return ApiPropertymappingsSourceSamlDestroyRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceSamlDestroy(ctx context.Context, pmUuid string) ApiPropertymappingsSourceSamlDestroyRequest {
	return ApiPropertymappingsSourceSamlDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsAPIService) PropertymappingsSourceSamlDestroyExecute(r ApiPropertymappingsSourceSamlDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceSamlDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/saml/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceSamlListRequest struct {
	ctx           context.Context
	ApiService    *PropertymappingsAPIService
	managed       *[]string
	managedIsnull *bool
	name          *string
	ordering      *string
	page          *int32
	pageSize      *int32
	search        *string
}

func (r ApiPropertymappingsSourceSamlListRequest) Managed(managed []string) ApiPropertymappingsSourceSamlListRequest {
	r.managed = &managed
	return r
}

func (r ApiPropertymappingsSourceSamlListRequest) ManagedIsnull(managedIsnull bool) ApiPropertymappingsSourceSamlListRequest {
	r.managedIsnull = &managedIsnull
	return r
}

func (r ApiPropertymappingsSourceSamlListRequest) Name(name string) ApiPropertymappingsSourceSamlListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsSourceSamlListRequest) Ordering(ordering string) ApiPropertymappingsSourceSamlListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsSourceSamlListRequest) Page(page int32) ApiPropertymappingsSourceSamlListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsSourceSamlListRequest) PageSize(pageSize int32) ApiPropertymappingsSourceSamlListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiPropertymappingsSourceSamlListRequest) Search(search string) ApiPropertymappingsSourceSamlListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsSourceSamlListRequest) Execute() (*PaginatedSAMLSourcePropertyMappingList, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceSamlListExecute(r)
}

/*
PropertymappingsSourceSamlList Method for PropertymappingsSourceSamlList

SAMLSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsSourceSamlListRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceSamlList(ctx context.Context) ApiPropertymappingsSourceSamlListRequest {
	return ApiPropertymappingsSourceSamlListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedSAMLSourcePropertyMappingList
func (a *PropertymappingsAPIService) PropertymappingsSourceSamlListExecute(r ApiPropertymappingsSourceSamlListRequest) (*PaginatedSAMLSourcePropertyMappingList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedSAMLSourcePropertyMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceSamlList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/saml/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.managed != nil {
		t := *r.managed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "managed", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "managed", t, "form", "multi")
		}
	}
	if r.managedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "managed__isnull", r.managedIsnull, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceSamlPartialUpdateRequest struct {
	ctx                                     context.Context
	ApiService                              *PropertymappingsAPIService
	pmUuid                                  string
	patchedSAMLSourcePropertyMappingRequest *PatchedSAMLSourcePropertyMappingRequest
}

func (r ApiPropertymappingsSourceSamlPartialUpdateRequest) PatchedSAMLSourcePropertyMappingRequest(patchedSAMLSourcePropertyMappingRequest PatchedSAMLSourcePropertyMappingRequest) ApiPropertymappingsSourceSamlPartialUpdateRequest {
	r.patchedSAMLSourcePropertyMappingRequest = &patchedSAMLSourcePropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSourceSamlPartialUpdateRequest) Execute() (*SAMLSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceSamlPartialUpdateExecute(r)
}

/*
PropertymappingsSourceSamlPartialUpdate Method for PropertymappingsSourceSamlPartialUpdate

SAMLSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SAML Source Property Mapping.
	@return ApiPropertymappingsSourceSamlPartialUpdateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceSamlPartialUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsSourceSamlPartialUpdateRequest {
	return ApiPropertymappingsSourceSamlPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return SAMLSourcePropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsSourceSamlPartialUpdateExecute(r ApiPropertymappingsSourceSamlPartialUpdateRequest) (*SAMLSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SAMLSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceSamlPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/saml/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedSAMLSourcePropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceSamlRetrieveRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsSourceSamlRetrieveRequest) Execute() (*SAMLSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceSamlRetrieveExecute(r)
}

/*
PropertymappingsSourceSamlRetrieve Method for PropertymappingsSourceSamlRetrieve

SAMLSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SAML Source Property Mapping.
	@return ApiPropertymappingsSourceSamlRetrieveRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceSamlRetrieve(ctx context.Context, pmUuid string) ApiPropertymappingsSourceSamlRetrieveRequest {
	return ApiPropertymappingsSourceSamlRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return SAMLSourcePropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsSourceSamlRetrieveExecute(r ApiPropertymappingsSourceSamlRetrieveRequest) (*SAMLSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SAMLSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceSamlRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/saml/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceSamlUpdateRequest struct {
	ctx                              context.Context
	ApiService                       *PropertymappingsAPIService
	pmUuid                           string
	sAMLSourcePropertyMappingRequest *SAMLSourcePropertyMappingRequest
}

func (r ApiPropertymappingsSourceSamlUpdateRequest) SAMLSourcePropertyMappingRequest(sAMLSourcePropertyMappingRequest SAMLSourcePropertyMappingRequest) ApiPropertymappingsSourceSamlUpdateRequest {
	r.sAMLSourcePropertyMappingRequest = &sAMLSourcePropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSourceSamlUpdateRequest) Execute() (*SAMLSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceSamlUpdateExecute(r)
}

/*
PropertymappingsSourceSamlUpdate Method for PropertymappingsSourceSamlUpdate

SAMLSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SAML Source Property Mapping.
	@return ApiPropertymappingsSourceSamlUpdateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceSamlUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsSourceSamlUpdateRequest {
	return ApiPropertymappingsSourceSamlUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return SAMLSourcePropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsSourceSamlUpdateExecute(r ApiPropertymappingsSourceSamlUpdateRequest) (*SAMLSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SAMLSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceSamlUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/saml/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sAMLSourcePropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("sAMLSourcePropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sAMLSourcePropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceSamlUsedByListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsSourceSamlUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceSamlUsedByListExecute(r)
}

/*
PropertymappingsSourceSamlUsedByList Method for PropertymappingsSourceSamlUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SAML Source Property Mapping.
	@return ApiPropertymappingsSourceSamlUsedByListRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceSamlUsedByList(ctx context.Context, pmUuid string) ApiPropertymappingsSourceSamlUsedByListRequest {
	return ApiPropertymappingsSourceSamlUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *PropertymappingsAPIService) PropertymappingsSourceSamlUsedByListExecute(r ApiPropertymappingsSourceSamlUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceSamlUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/saml/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceScimCreateRequest struct {
	ctx                              context.Context
	ApiService                       *PropertymappingsAPIService
	sCIMSourcePropertyMappingRequest *SCIMSourcePropertyMappingRequest
}

func (r ApiPropertymappingsSourceScimCreateRequest) SCIMSourcePropertyMappingRequest(sCIMSourcePropertyMappingRequest SCIMSourcePropertyMappingRequest) ApiPropertymappingsSourceScimCreateRequest {
	r.sCIMSourcePropertyMappingRequest = &sCIMSourcePropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSourceScimCreateRequest) Execute() (*SCIMSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceScimCreateExecute(r)
}

/*
PropertymappingsSourceScimCreate Method for PropertymappingsSourceScimCreate

SCIMSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsSourceScimCreateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceScimCreate(ctx context.Context) ApiPropertymappingsSourceScimCreateRequest {
	return ApiPropertymappingsSourceScimCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SCIMSourcePropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsSourceScimCreateExecute(r ApiPropertymappingsSourceScimCreateRequest) (*SCIMSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SCIMSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceScimCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/scim/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sCIMSourcePropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("sCIMSourcePropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sCIMSourcePropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceScimDestroyRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsSourceScimDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PropertymappingsSourceScimDestroyExecute(r)
}

/*
PropertymappingsSourceScimDestroy Method for PropertymappingsSourceScimDestroy

SCIMSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SCIM Source Property Mapping.
	@return ApiPropertymappingsSourceScimDestroyRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceScimDestroy(ctx context.Context, pmUuid string) ApiPropertymappingsSourceScimDestroyRequest {
	return ApiPropertymappingsSourceScimDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
func (a *PropertymappingsAPIService) PropertymappingsSourceScimDestroyExecute(r ApiPropertymappingsSourceScimDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceScimDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/scim/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceScimListRequest struct {
	ctx           context.Context
	ApiService    *PropertymappingsAPIService
	managed       *[]string
	managedIsnull *bool
	name          *string
	ordering      *string
	page          *int32
	pageSize      *int32
	search        *string
}

func (r ApiPropertymappingsSourceScimListRequest) Managed(managed []string) ApiPropertymappingsSourceScimListRequest {
	r.managed = &managed
	return r
}

func (r ApiPropertymappingsSourceScimListRequest) ManagedIsnull(managedIsnull bool) ApiPropertymappingsSourceScimListRequest {
	r.managedIsnull = &managedIsnull
	return r
}

func (r ApiPropertymappingsSourceScimListRequest) Name(name string) ApiPropertymappingsSourceScimListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPropertymappingsSourceScimListRequest) Ordering(ordering string) ApiPropertymappingsSourceScimListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPropertymappingsSourceScimListRequest) Page(page int32) ApiPropertymappingsSourceScimListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPropertymappingsSourceScimListRequest) PageSize(pageSize int32) ApiPropertymappingsSourceScimListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiPropertymappingsSourceScimListRequest) Search(search string) ApiPropertymappingsSourceScimListRequest {
	r.search = &search
	return r
}

func (r ApiPropertymappingsSourceScimListRequest) Execute() (*PaginatedSCIMSourcePropertyMappingList, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceScimListExecute(r)
}

/*
PropertymappingsSourceScimList Method for PropertymappingsSourceScimList

SCIMSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPropertymappingsSourceScimListRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceScimList(ctx context.Context) ApiPropertymappingsSourceScimListRequest {
	return ApiPropertymappingsSourceScimListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedSCIMSourcePropertyMappingList
func (a *PropertymappingsAPIService) PropertymappingsSourceScimListExecute(r ApiPropertymappingsSourceScimListRequest) (*PaginatedSCIMSourcePropertyMappingList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedSCIMSourcePropertyMappingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceScimList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/scim/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.managed != nil {
		t := *r.managed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "managed", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "managed", t, "form", "multi")
		}
	}
	if r.managedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "managed__isnull", r.managedIsnull, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceScimPartialUpdateRequest struct {
	ctx                                     context.Context
	ApiService                              *PropertymappingsAPIService
	pmUuid                                  string
	patchedSCIMSourcePropertyMappingRequest *PatchedSCIMSourcePropertyMappingRequest
}

func (r ApiPropertymappingsSourceScimPartialUpdateRequest) PatchedSCIMSourcePropertyMappingRequest(patchedSCIMSourcePropertyMappingRequest PatchedSCIMSourcePropertyMappingRequest) ApiPropertymappingsSourceScimPartialUpdateRequest {
	r.patchedSCIMSourcePropertyMappingRequest = &patchedSCIMSourcePropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSourceScimPartialUpdateRequest) Execute() (*SCIMSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceScimPartialUpdateExecute(r)
}

/*
PropertymappingsSourceScimPartialUpdate Method for PropertymappingsSourceScimPartialUpdate

SCIMSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SCIM Source Property Mapping.
	@return ApiPropertymappingsSourceScimPartialUpdateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceScimPartialUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsSourceScimPartialUpdateRequest {
	return ApiPropertymappingsSourceScimPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return SCIMSourcePropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsSourceScimPartialUpdateExecute(r ApiPropertymappingsSourceScimPartialUpdateRequest) (*SCIMSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SCIMSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceScimPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/scim/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedSCIMSourcePropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceScimRetrieveRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsSourceScimRetrieveRequest) Execute() (*SCIMSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceScimRetrieveExecute(r)
}

/*
PropertymappingsSourceScimRetrieve Method for PropertymappingsSourceScimRetrieve

SCIMSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SCIM Source Property Mapping.
	@return ApiPropertymappingsSourceScimRetrieveRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceScimRetrieve(ctx context.Context, pmUuid string) ApiPropertymappingsSourceScimRetrieveRequest {
	return ApiPropertymappingsSourceScimRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return SCIMSourcePropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsSourceScimRetrieveExecute(r ApiPropertymappingsSourceScimRetrieveRequest) (*SCIMSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SCIMSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceScimRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/scim/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceScimUpdateRequest struct {
	ctx                              context.Context
	ApiService                       *PropertymappingsAPIService
	pmUuid                           string
	sCIMSourcePropertyMappingRequest *SCIMSourcePropertyMappingRequest
}

func (r ApiPropertymappingsSourceScimUpdateRequest) SCIMSourcePropertyMappingRequest(sCIMSourcePropertyMappingRequest SCIMSourcePropertyMappingRequest) ApiPropertymappingsSourceScimUpdateRequest {
	r.sCIMSourcePropertyMappingRequest = &sCIMSourcePropertyMappingRequest
	return r
}

func (r ApiPropertymappingsSourceScimUpdateRequest) Execute() (*SCIMSourcePropertyMapping, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceScimUpdateExecute(r)
}

/*
PropertymappingsSourceScimUpdate Method for PropertymappingsSourceScimUpdate

SCIMSourcePropertyMapping Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SCIM Source Property Mapping.
	@return ApiPropertymappingsSourceScimUpdateRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceScimUpdate(ctx context.Context, pmUuid string) ApiPropertymappingsSourceScimUpdateRequest {
	return ApiPropertymappingsSourceScimUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return SCIMSourcePropertyMapping
func (a *PropertymappingsAPIService) PropertymappingsSourceScimUpdateExecute(r ApiPropertymappingsSourceScimUpdateRequest) (*SCIMSourcePropertyMapping, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SCIMSourcePropertyMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceScimUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/scim/{pm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sCIMSourcePropertyMappingRequest == nil {
		return localVarReturnValue, nil, reportError("sCIMSourcePropertyMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sCIMSourcePropertyMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPropertymappingsSourceScimUsedByListRequest struct {
	ctx        context.Context
	ApiService *PropertymappingsAPIService
	pmUuid     string
}

func (r ApiPropertymappingsSourceScimUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.PropertymappingsSourceScimUsedByListExecute(r)
}

/*
PropertymappingsSourceScimUsedByList Method for PropertymappingsSourceScimUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pmUuid A UUID string identifying this SCIM Source Property Mapping.
	@return ApiPropertymappingsSourceScimUsedByListRequest
*/
func (a *PropertymappingsAPIService) PropertymappingsSourceScimUsedByList(ctx context.Context, pmUuid string) ApiPropertymappingsSourceScimUsedByListRequest {
	return ApiPropertymappingsSourceScimUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pmUuid:     pmUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *PropertymappingsAPIService) PropertymappingsSourceScimUsedByListExecute(r ApiPropertymappingsSourceScimUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PropertymappingsAPIService.PropertymappingsSourceScimUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/propertymappings/source/scim/{pm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pm_uuid"+"}", url.PathEscape(parameterValueToString(r.pmUuid, "pmUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
