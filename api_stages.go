/*
authentik

Making authentication simple.

API version: 2026.2.0-rc1
Contact: hello@goauthentik.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
	"time"
)

// StagesAPIService StagesAPI service
type StagesAPIService service

type ApiStagesAllDestroyRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesAllDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.StagesAllDestroyExecute(r)
}

/*
StagesAllDestroy Method for StagesAllDestroy

Stage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this stage.
	@return ApiStagesAllDestroyRequest
*/
func (a *StagesAPIService) StagesAllDestroy(ctx context.Context, stageUuid string) ApiStagesAllDestroyRequest {
	return ApiStagesAllDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
func (a *StagesAPIService) StagesAllDestroyExecute(r ApiStagesAllDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAllDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/all/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStagesAllListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	name       *string
	ordering   *string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiStagesAllListRequest) Name(name string) ApiStagesAllListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiStagesAllListRequest) Ordering(ordering string) ApiStagesAllListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiStagesAllListRequest) Page(page int32) ApiStagesAllListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiStagesAllListRequest) PageSize(pageSize int32) ApiStagesAllListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiStagesAllListRequest) Search(search string) ApiStagesAllListRequest {
	r.search = &search
	return r
}

func (r ApiStagesAllListRequest) Execute() (*PaginatedStageList, *http.Response, error) {
	return r.ApiService.StagesAllListExecute(r)
}

/*
StagesAllList Method for StagesAllList

Stage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesAllListRequest
*/
func (a *StagesAPIService) StagesAllList(ctx context.Context) ApiStagesAllListRequest {
	return ApiStagesAllListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedStageList
func (a *StagesAPIService) StagesAllListExecute(r ApiStagesAllListRequest) (*PaginatedStageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedStageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAllList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/all/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAllRetrieveRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesAllRetrieveRequest) Execute() (*Stage, *http.Response, error) {
	return r.ApiService.StagesAllRetrieveExecute(r)
}

/*
StagesAllRetrieve Method for StagesAllRetrieve

Stage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this stage.
	@return ApiStagesAllRetrieveRequest
*/
func (a *StagesAPIService) StagesAllRetrieve(ctx context.Context, stageUuid string) ApiStagesAllRetrieveRequest {
	return ApiStagesAllRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return Stage
func (a *StagesAPIService) StagesAllRetrieveExecute(r ApiStagesAllRetrieveRequest) (*Stage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Stage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAllRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/all/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAllTypesListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
}

func (r ApiStagesAllTypesListRequest) Execute() ([]TypeCreate, *http.Response, error) {
	return r.ApiService.StagesAllTypesListExecute(r)
}

/*
StagesAllTypesList Method for StagesAllTypesList

Get all creatable types

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesAllTypesListRequest
*/
func (a *StagesAPIService) StagesAllTypesList(ctx context.Context) ApiStagesAllTypesListRequest {
	return ApiStagesAllTypesListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []TypeCreate
func (a *StagesAPIService) StagesAllTypesListExecute(r ApiStagesAllTypesListRequest) ([]TypeCreate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []TypeCreate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAllTypesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/all/types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAllUsedByListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesAllUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.StagesAllUsedByListExecute(r)
}

/*
StagesAllUsedByList Method for StagesAllUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this stage.
	@return ApiStagesAllUsedByListRequest
*/
func (a *StagesAPIService) StagesAllUsedByList(ctx context.Context, stageUuid string) ApiStagesAllUsedByListRequest {
	return ApiStagesAllUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *StagesAPIService) StagesAllUsedByListExecute(r ApiStagesAllUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAllUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/all/{stage_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAllUserSettingsListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
}

func (r ApiStagesAllUserSettingsListRequest) Execute() ([]UserSetting, *http.Response, error) {
	return r.ApiService.StagesAllUserSettingsListExecute(r)
}

/*
StagesAllUserSettingsList Method for StagesAllUserSettingsList

Get all stages the user can configure

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesAllUserSettingsListRequest
*/
func (a *StagesAPIService) StagesAllUserSettingsList(ctx context.Context) ApiStagesAllUserSettingsListRequest {
	return ApiStagesAllUserSettingsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []UserSetting
func (a *StagesAPIService) StagesAllUserSettingsListExecute(r ApiStagesAllUserSettingsListRequest) ([]UserSetting, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UserSetting
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAllUserSettingsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/all/user_settings/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorDuoCreateRequest struct {
	ctx                          context.Context
	ApiService                   *StagesAPIService
	authenticatorDuoStageRequest *AuthenticatorDuoStageRequest
}

func (r ApiStagesAuthenticatorDuoCreateRequest) AuthenticatorDuoStageRequest(authenticatorDuoStageRequest AuthenticatorDuoStageRequest) ApiStagesAuthenticatorDuoCreateRequest {
	r.authenticatorDuoStageRequest = &authenticatorDuoStageRequest
	return r
}

func (r ApiStagesAuthenticatorDuoCreateRequest) Execute() (*AuthenticatorDuoStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorDuoCreateExecute(r)
}

/*
StagesAuthenticatorDuoCreate Method for StagesAuthenticatorDuoCreate

AuthenticatorDuoStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesAuthenticatorDuoCreateRequest
*/
func (a *StagesAPIService) StagesAuthenticatorDuoCreate(ctx context.Context) ApiStagesAuthenticatorDuoCreateRequest {
	return ApiStagesAuthenticatorDuoCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AuthenticatorDuoStage
func (a *StagesAPIService) StagesAuthenticatorDuoCreateExecute(r ApiStagesAuthenticatorDuoCreateRequest) (*AuthenticatorDuoStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorDuoStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorDuoCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/duo/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authenticatorDuoStageRequest == nil {
		return localVarReturnValue, nil, reportError("authenticatorDuoStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticatorDuoStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorDuoDestroyRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesAuthenticatorDuoDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.StagesAuthenticatorDuoDestroyExecute(r)
}

/*
StagesAuthenticatorDuoDestroy Method for StagesAuthenticatorDuoDestroy

AuthenticatorDuoStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
	@return ApiStagesAuthenticatorDuoDestroyRequest
*/
func (a *StagesAPIService) StagesAuthenticatorDuoDestroy(ctx context.Context, stageUuid string) ApiStagesAuthenticatorDuoDestroyRequest {
	return ApiStagesAuthenticatorDuoDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
func (a *StagesAPIService) StagesAuthenticatorDuoDestroyExecute(r ApiStagesAuthenticatorDuoDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorDuoDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/duo/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorDuoEnrollmentStatusCreateRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesAuthenticatorDuoEnrollmentStatusCreateRequest) Execute() (*DuoDeviceEnrollmentStatus, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorDuoEnrollmentStatusCreateExecute(r)
}

/*
StagesAuthenticatorDuoEnrollmentStatusCreate Method for StagesAuthenticatorDuoEnrollmentStatusCreate

Check enrollment status of user details in current session

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
	@return ApiStagesAuthenticatorDuoEnrollmentStatusCreateRequest
*/
func (a *StagesAPIService) StagesAuthenticatorDuoEnrollmentStatusCreate(ctx context.Context, stageUuid string) ApiStagesAuthenticatorDuoEnrollmentStatusCreateRequest {
	return ApiStagesAuthenticatorDuoEnrollmentStatusCreateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return DuoDeviceEnrollmentStatus
func (a *StagesAPIService) StagesAuthenticatorDuoEnrollmentStatusCreateExecute(r ApiStagesAuthenticatorDuoEnrollmentStatusCreateRequest) (*DuoDeviceEnrollmentStatus, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DuoDeviceEnrollmentStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorDuoEnrollmentStatusCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/duo/{stage_uuid}/enrollment_status/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorDuoImportDeviceManualCreateRequest struct {
	ctx                                            context.Context
	ApiService                                     *StagesAPIService
	stageUuid                                      string
	authenticatorDuoStageManualDeviceImportRequest *AuthenticatorDuoStageManualDeviceImportRequest
}

func (r ApiStagesAuthenticatorDuoImportDeviceManualCreateRequest) AuthenticatorDuoStageManualDeviceImportRequest(authenticatorDuoStageManualDeviceImportRequest AuthenticatorDuoStageManualDeviceImportRequest) ApiStagesAuthenticatorDuoImportDeviceManualCreateRequest {
	r.authenticatorDuoStageManualDeviceImportRequest = &authenticatorDuoStageManualDeviceImportRequest
	return r
}

func (r ApiStagesAuthenticatorDuoImportDeviceManualCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.StagesAuthenticatorDuoImportDeviceManualCreateExecute(r)
}

/*
StagesAuthenticatorDuoImportDeviceManualCreate Method for StagesAuthenticatorDuoImportDeviceManualCreate

Import duo devices into authentik

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
	@return ApiStagesAuthenticatorDuoImportDeviceManualCreateRequest
*/
func (a *StagesAPIService) StagesAuthenticatorDuoImportDeviceManualCreate(ctx context.Context, stageUuid string) ApiStagesAuthenticatorDuoImportDeviceManualCreateRequest {
	return ApiStagesAuthenticatorDuoImportDeviceManualCreateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
func (a *StagesAPIService) StagesAuthenticatorDuoImportDeviceManualCreateExecute(r ApiStagesAuthenticatorDuoImportDeviceManualCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorDuoImportDeviceManualCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/duo/{stage_uuid}/import_device_manual/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authenticatorDuoStageManualDeviceImportRequest == nil {
		return nil, reportError("authenticatorDuoStageManualDeviceImportRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticatorDuoStageManualDeviceImportRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorDuoImportDevicesAutomaticCreateRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesAuthenticatorDuoImportDevicesAutomaticCreateRequest) Execute() (*AuthenticatorDuoStageDeviceImportResponse, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorDuoImportDevicesAutomaticCreateExecute(r)
}

/*
StagesAuthenticatorDuoImportDevicesAutomaticCreate Method for StagesAuthenticatorDuoImportDevicesAutomaticCreate

Import duo devices into authentik

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
	@return ApiStagesAuthenticatorDuoImportDevicesAutomaticCreateRequest
*/
func (a *StagesAPIService) StagesAuthenticatorDuoImportDevicesAutomaticCreate(ctx context.Context, stageUuid string) ApiStagesAuthenticatorDuoImportDevicesAutomaticCreateRequest {
	return ApiStagesAuthenticatorDuoImportDevicesAutomaticCreateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return AuthenticatorDuoStageDeviceImportResponse
func (a *StagesAPIService) StagesAuthenticatorDuoImportDevicesAutomaticCreateExecute(r ApiStagesAuthenticatorDuoImportDevicesAutomaticCreateRequest) (*AuthenticatorDuoStageDeviceImportResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorDuoStageDeviceImportResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorDuoImportDevicesAutomaticCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/duo/{stage_uuid}/import_devices_automatic/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorDuoListRequest struct {
	ctx           context.Context
	ApiService    *StagesAPIService
	apiHostname   *string
	clientId      *string
	configureFlow *string
	name          *string
	ordering      *string
	page          *int32
	pageSize      *int32
	search        *string
}

func (r ApiStagesAuthenticatorDuoListRequest) ApiHostname(apiHostname string) ApiStagesAuthenticatorDuoListRequest {
	r.apiHostname = &apiHostname
	return r
}

func (r ApiStagesAuthenticatorDuoListRequest) ClientId(clientId string) ApiStagesAuthenticatorDuoListRequest {
	r.clientId = &clientId
	return r
}

func (r ApiStagesAuthenticatorDuoListRequest) ConfigureFlow(configureFlow string) ApiStagesAuthenticatorDuoListRequest {
	r.configureFlow = &configureFlow
	return r
}

func (r ApiStagesAuthenticatorDuoListRequest) Name(name string) ApiStagesAuthenticatorDuoListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiStagesAuthenticatorDuoListRequest) Ordering(ordering string) ApiStagesAuthenticatorDuoListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiStagesAuthenticatorDuoListRequest) Page(page int32) ApiStagesAuthenticatorDuoListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiStagesAuthenticatorDuoListRequest) PageSize(pageSize int32) ApiStagesAuthenticatorDuoListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiStagesAuthenticatorDuoListRequest) Search(search string) ApiStagesAuthenticatorDuoListRequest {
	r.search = &search
	return r
}

func (r ApiStagesAuthenticatorDuoListRequest) Execute() (*PaginatedAuthenticatorDuoStageList, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorDuoListExecute(r)
}

/*
StagesAuthenticatorDuoList Method for StagesAuthenticatorDuoList

AuthenticatorDuoStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesAuthenticatorDuoListRequest
*/
func (a *StagesAPIService) StagesAuthenticatorDuoList(ctx context.Context) ApiStagesAuthenticatorDuoListRequest {
	return ApiStagesAuthenticatorDuoListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedAuthenticatorDuoStageList
func (a *StagesAPIService) StagesAuthenticatorDuoListExecute(r ApiStagesAuthenticatorDuoListRequest) (*PaginatedAuthenticatorDuoStageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedAuthenticatorDuoStageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorDuoList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/duo/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.apiHostname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api_hostname", r.apiHostname, "form", "")
	}
	if r.clientId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "client_id", r.clientId, "form", "")
	}
	if r.configureFlow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "configure_flow", r.configureFlow, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorDuoPartialUpdateRequest struct {
	ctx                                 context.Context
	ApiService                          *StagesAPIService
	stageUuid                           string
	patchedAuthenticatorDuoStageRequest *PatchedAuthenticatorDuoStageRequest
}

func (r ApiStagesAuthenticatorDuoPartialUpdateRequest) PatchedAuthenticatorDuoStageRequest(patchedAuthenticatorDuoStageRequest PatchedAuthenticatorDuoStageRequest) ApiStagesAuthenticatorDuoPartialUpdateRequest {
	r.patchedAuthenticatorDuoStageRequest = &patchedAuthenticatorDuoStageRequest
	return r
}

func (r ApiStagesAuthenticatorDuoPartialUpdateRequest) Execute() (*AuthenticatorDuoStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorDuoPartialUpdateExecute(r)
}

/*
StagesAuthenticatorDuoPartialUpdate Method for StagesAuthenticatorDuoPartialUpdate

AuthenticatorDuoStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
	@return ApiStagesAuthenticatorDuoPartialUpdateRequest
*/
func (a *StagesAPIService) StagesAuthenticatorDuoPartialUpdate(ctx context.Context, stageUuid string) ApiStagesAuthenticatorDuoPartialUpdateRequest {
	return ApiStagesAuthenticatorDuoPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return AuthenticatorDuoStage
func (a *StagesAPIService) StagesAuthenticatorDuoPartialUpdateExecute(r ApiStagesAuthenticatorDuoPartialUpdateRequest) (*AuthenticatorDuoStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorDuoStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorDuoPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/duo/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedAuthenticatorDuoStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorDuoRetrieveRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesAuthenticatorDuoRetrieveRequest) Execute() (*AuthenticatorDuoStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorDuoRetrieveExecute(r)
}

/*
StagesAuthenticatorDuoRetrieve Method for StagesAuthenticatorDuoRetrieve

AuthenticatorDuoStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
	@return ApiStagesAuthenticatorDuoRetrieveRequest
*/
func (a *StagesAPIService) StagesAuthenticatorDuoRetrieve(ctx context.Context, stageUuid string) ApiStagesAuthenticatorDuoRetrieveRequest {
	return ApiStagesAuthenticatorDuoRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return AuthenticatorDuoStage
func (a *StagesAPIService) StagesAuthenticatorDuoRetrieveExecute(r ApiStagesAuthenticatorDuoRetrieveRequest) (*AuthenticatorDuoStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorDuoStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorDuoRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/duo/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorDuoUpdateRequest struct {
	ctx                          context.Context
	ApiService                   *StagesAPIService
	stageUuid                    string
	authenticatorDuoStageRequest *AuthenticatorDuoStageRequest
}

func (r ApiStagesAuthenticatorDuoUpdateRequest) AuthenticatorDuoStageRequest(authenticatorDuoStageRequest AuthenticatorDuoStageRequest) ApiStagesAuthenticatorDuoUpdateRequest {
	r.authenticatorDuoStageRequest = &authenticatorDuoStageRequest
	return r
}

func (r ApiStagesAuthenticatorDuoUpdateRequest) Execute() (*AuthenticatorDuoStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorDuoUpdateExecute(r)
}

/*
StagesAuthenticatorDuoUpdate Method for StagesAuthenticatorDuoUpdate

AuthenticatorDuoStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
	@return ApiStagesAuthenticatorDuoUpdateRequest
*/
func (a *StagesAPIService) StagesAuthenticatorDuoUpdate(ctx context.Context, stageUuid string) ApiStagesAuthenticatorDuoUpdateRequest {
	return ApiStagesAuthenticatorDuoUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return AuthenticatorDuoStage
func (a *StagesAPIService) StagesAuthenticatorDuoUpdateExecute(r ApiStagesAuthenticatorDuoUpdateRequest) (*AuthenticatorDuoStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorDuoStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorDuoUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/duo/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authenticatorDuoStageRequest == nil {
		return localVarReturnValue, nil, reportError("authenticatorDuoStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticatorDuoStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorDuoUsedByListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesAuthenticatorDuoUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorDuoUsedByListExecute(r)
}

/*
StagesAuthenticatorDuoUsedByList Method for StagesAuthenticatorDuoUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
	@return ApiStagesAuthenticatorDuoUsedByListRequest
*/
func (a *StagesAPIService) StagesAuthenticatorDuoUsedByList(ctx context.Context, stageUuid string) ApiStagesAuthenticatorDuoUsedByListRequest {
	return ApiStagesAuthenticatorDuoUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *StagesAPIService) StagesAuthenticatorDuoUsedByListExecute(r ApiStagesAuthenticatorDuoUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorDuoUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/duo/{stage_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorEmailCreateRequest struct {
	ctx                            context.Context
	ApiService                     *StagesAPIService
	authenticatorEmailStageRequest *AuthenticatorEmailStageRequest
}

func (r ApiStagesAuthenticatorEmailCreateRequest) AuthenticatorEmailStageRequest(authenticatorEmailStageRequest AuthenticatorEmailStageRequest) ApiStagesAuthenticatorEmailCreateRequest {
	r.authenticatorEmailStageRequest = &authenticatorEmailStageRequest
	return r
}

func (r ApiStagesAuthenticatorEmailCreateRequest) Execute() (*AuthenticatorEmailStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorEmailCreateExecute(r)
}

/*
StagesAuthenticatorEmailCreate Method for StagesAuthenticatorEmailCreate

AuthenticatorEmailStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesAuthenticatorEmailCreateRequest
*/
func (a *StagesAPIService) StagesAuthenticatorEmailCreate(ctx context.Context) ApiStagesAuthenticatorEmailCreateRequest {
	return ApiStagesAuthenticatorEmailCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AuthenticatorEmailStage
func (a *StagesAPIService) StagesAuthenticatorEmailCreateExecute(r ApiStagesAuthenticatorEmailCreateRequest) (*AuthenticatorEmailStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorEmailStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorEmailCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/email/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authenticatorEmailStageRequest == nil {
		return localVarReturnValue, nil, reportError("authenticatorEmailStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticatorEmailStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorEmailDestroyRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesAuthenticatorEmailDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.StagesAuthenticatorEmailDestroyExecute(r)
}

/*
StagesAuthenticatorEmailDestroy Method for StagesAuthenticatorEmailDestroy

AuthenticatorEmailStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Email Authenticator Setup Stage.
	@return ApiStagesAuthenticatorEmailDestroyRequest
*/
func (a *StagesAPIService) StagesAuthenticatorEmailDestroy(ctx context.Context, stageUuid string) ApiStagesAuthenticatorEmailDestroyRequest {
	return ApiStagesAuthenticatorEmailDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
func (a *StagesAPIService) StagesAuthenticatorEmailDestroyExecute(r ApiStagesAuthenticatorEmailDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorEmailDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/email/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorEmailListRequest struct {
	ctx               context.Context
	ApiService        *StagesAPIService
	configureFlow     *string
	friendlyName      *string
	fromAddress       *string
	host              *string
	name              *string
	ordering          *string
	page              *int32
	pageSize          *int32
	password          *string
	port              *int32
	search            *string
	stageUuid         *string
	subject           *string
	template          *string
	timeout           *int32
	tokenExpiry       *string
	useGlobalSettings *bool
	useSsl            *bool
	useTls            *bool
	username          *string
}

func (r ApiStagesAuthenticatorEmailListRequest) ConfigureFlow(configureFlow string) ApiStagesAuthenticatorEmailListRequest {
	r.configureFlow = &configureFlow
	return r
}

func (r ApiStagesAuthenticatorEmailListRequest) FriendlyName(friendlyName string) ApiStagesAuthenticatorEmailListRequest {
	r.friendlyName = &friendlyName
	return r
}

func (r ApiStagesAuthenticatorEmailListRequest) FromAddress(fromAddress string) ApiStagesAuthenticatorEmailListRequest {
	r.fromAddress = &fromAddress
	return r
}

func (r ApiStagesAuthenticatorEmailListRequest) Host(host string) ApiStagesAuthenticatorEmailListRequest {
	r.host = &host
	return r
}

func (r ApiStagesAuthenticatorEmailListRequest) Name(name string) ApiStagesAuthenticatorEmailListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiStagesAuthenticatorEmailListRequest) Ordering(ordering string) ApiStagesAuthenticatorEmailListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiStagesAuthenticatorEmailListRequest) Page(page int32) ApiStagesAuthenticatorEmailListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiStagesAuthenticatorEmailListRequest) PageSize(pageSize int32) ApiStagesAuthenticatorEmailListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiStagesAuthenticatorEmailListRequest) Password(password string) ApiStagesAuthenticatorEmailListRequest {
	r.password = &password
	return r
}

func (r ApiStagesAuthenticatorEmailListRequest) Port(port int32) ApiStagesAuthenticatorEmailListRequest {
	r.port = &port
	return r
}

// A search term.
func (r ApiStagesAuthenticatorEmailListRequest) Search(search string) ApiStagesAuthenticatorEmailListRequest {
	r.search = &search
	return r
}

func (r ApiStagesAuthenticatorEmailListRequest) StageUuid(stageUuid string) ApiStagesAuthenticatorEmailListRequest {
	r.stageUuid = &stageUuid
	return r
}

func (r ApiStagesAuthenticatorEmailListRequest) Subject(subject string) ApiStagesAuthenticatorEmailListRequest {
	r.subject = &subject
	return r
}

func (r ApiStagesAuthenticatorEmailListRequest) Template(template string) ApiStagesAuthenticatorEmailListRequest {
	r.template = &template
	return r
}

func (r ApiStagesAuthenticatorEmailListRequest) Timeout(timeout int32) ApiStagesAuthenticatorEmailListRequest {
	r.timeout = &timeout
	return r
}

func (r ApiStagesAuthenticatorEmailListRequest) TokenExpiry(tokenExpiry string) ApiStagesAuthenticatorEmailListRequest {
	r.tokenExpiry = &tokenExpiry
	return r
}

func (r ApiStagesAuthenticatorEmailListRequest) UseGlobalSettings(useGlobalSettings bool) ApiStagesAuthenticatorEmailListRequest {
	r.useGlobalSettings = &useGlobalSettings
	return r
}

func (r ApiStagesAuthenticatorEmailListRequest) UseSsl(useSsl bool) ApiStagesAuthenticatorEmailListRequest {
	r.useSsl = &useSsl
	return r
}

func (r ApiStagesAuthenticatorEmailListRequest) UseTls(useTls bool) ApiStagesAuthenticatorEmailListRequest {
	r.useTls = &useTls
	return r
}

func (r ApiStagesAuthenticatorEmailListRequest) Username(username string) ApiStagesAuthenticatorEmailListRequest {
	r.username = &username
	return r
}

func (r ApiStagesAuthenticatorEmailListRequest) Execute() (*PaginatedAuthenticatorEmailStageList, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorEmailListExecute(r)
}

/*
StagesAuthenticatorEmailList Method for StagesAuthenticatorEmailList

AuthenticatorEmailStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesAuthenticatorEmailListRequest
*/
func (a *StagesAPIService) StagesAuthenticatorEmailList(ctx context.Context) ApiStagesAuthenticatorEmailListRequest {
	return ApiStagesAuthenticatorEmailListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedAuthenticatorEmailStageList
func (a *StagesAPIService) StagesAuthenticatorEmailListExecute(r ApiStagesAuthenticatorEmailListRequest) (*PaginatedAuthenticatorEmailStageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedAuthenticatorEmailStageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorEmailList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/email/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.configureFlow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "configure_flow", r.configureFlow, "form", "")
	}
	if r.friendlyName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "friendly_name", r.friendlyName, "form", "")
	}
	if r.fromAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_address", r.fromAddress, "form", "")
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.password != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "password", r.password, "form", "")
	}
	if r.port != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "port", r.port, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.stageUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stage_uuid", r.stageUuid, "form", "")
	}
	if r.subject != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subject", r.subject, "form", "")
	}
	if r.template != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "template", r.template, "form", "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "form", "")
	}
	if r.tokenExpiry != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token_expiry", r.tokenExpiry, "form", "")
	}
	if r.useGlobalSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "use_global_settings", r.useGlobalSettings, "form", "")
	}
	if r.useSsl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "use_ssl", r.useSsl, "form", "")
	}
	if r.useTls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "use_tls", r.useTls, "form", "")
	}
	if r.username != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "username", r.username, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorEmailPartialUpdateRequest struct {
	ctx                                   context.Context
	ApiService                            *StagesAPIService
	stageUuid                             string
	patchedAuthenticatorEmailStageRequest *PatchedAuthenticatorEmailStageRequest
}

func (r ApiStagesAuthenticatorEmailPartialUpdateRequest) PatchedAuthenticatorEmailStageRequest(patchedAuthenticatorEmailStageRequest PatchedAuthenticatorEmailStageRequest) ApiStagesAuthenticatorEmailPartialUpdateRequest {
	r.patchedAuthenticatorEmailStageRequest = &patchedAuthenticatorEmailStageRequest
	return r
}

func (r ApiStagesAuthenticatorEmailPartialUpdateRequest) Execute() (*AuthenticatorEmailStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorEmailPartialUpdateExecute(r)
}

/*
StagesAuthenticatorEmailPartialUpdate Method for StagesAuthenticatorEmailPartialUpdate

AuthenticatorEmailStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Email Authenticator Setup Stage.
	@return ApiStagesAuthenticatorEmailPartialUpdateRequest
*/
func (a *StagesAPIService) StagesAuthenticatorEmailPartialUpdate(ctx context.Context, stageUuid string) ApiStagesAuthenticatorEmailPartialUpdateRequest {
	return ApiStagesAuthenticatorEmailPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return AuthenticatorEmailStage
func (a *StagesAPIService) StagesAuthenticatorEmailPartialUpdateExecute(r ApiStagesAuthenticatorEmailPartialUpdateRequest) (*AuthenticatorEmailStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorEmailStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorEmailPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/email/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedAuthenticatorEmailStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorEmailRetrieveRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesAuthenticatorEmailRetrieveRequest) Execute() (*AuthenticatorEmailStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorEmailRetrieveExecute(r)
}

/*
StagesAuthenticatorEmailRetrieve Method for StagesAuthenticatorEmailRetrieve

AuthenticatorEmailStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Email Authenticator Setup Stage.
	@return ApiStagesAuthenticatorEmailRetrieveRequest
*/
func (a *StagesAPIService) StagesAuthenticatorEmailRetrieve(ctx context.Context, stageUuid string) ApiStagesAuthenticatorEmailRetrieveRequest {
	return ApiStagesAuthenticatorEmailRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return AuthenticatorEmailStage
func (a *StagesAPIService) StagesAuthenticatorEmailRetrieveExecute(r ApiStagesAuthenticatorEmailRetrieveRequest) (*AuthenticatorEmailStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorEmailStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorEmailRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/email/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorEmailUpdateRequest struct {
	ctx                            context.Context
	ApiService                     *StagesAPIService
	stageUuid                      string
	authenticatorEmailStageRequest *AuthenticatorEmailStageRequest
}

func (r ApiStagesAuthenticatorEmailUpdateRequest) AuthenticatorEmailStageRequest(authenticatorEmailStageRequest AuthenticatorEmailStageRequest) ApiStagesAuthenticatorEmailUpdateRequest {
	r.authenticatorEmailStageRequest = &authenticatorEmailStageRequest
	return r
}

func (r ApiStagesAuthenticatorEmailUpdateRequest) Execute() (*AuthenticatorEmailStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorEmailUpdateExecute(r)
}

/*
StagesAuthenticatorEmailUpdate Method for StagesAuthenticatorEmailUpdate

AuthenticatorEmailStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Email Authenticator Setup Stage.
	@return ApiStagesAuthenticatorEmailUpdateRequest
*/
func (a *StagesAPIService) StagesAuthenticatorEmailUpdate(ctx context.Context, stageUuid string) ApiStagesAuthenticatorEmailUpdateRequest {
	return ApiStagesAuthenticatorEmailUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return AuthenticatorEmailStage
func (a *StagesAPIService) StagesAuthenticatorEmailUpdateExecute(r ApiStagesAuthenticatorEmailUpdateRequest) (*AuthenticatorEmailStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorEmailStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorEmailUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/email/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authenticatorEmailStageRequest == nil {
		return localVarReturnValue, nil, reportError("authenticatorEmailStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticatorEmailStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorEmailUsedByListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesAuthenticatorEmailUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorEmailUsedByListExecute(r)
}

/*
StagesAuthenticatorEmailUsedByList Method for StagesAuthenticatorEmailUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Email Authenticator Setup Stage.
	@return ApiStagesAuthenticatorEmailUsedByListRequest
*/
func (a *StagesAPIService) StagesAuthenticatorEmailUsedByList(ctx context.Context, stageUuid string) ApiStagesAuthenticatorEmailUsedByListRequest {
	return ApiStagesAuthenticatorEmailUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *StagesAPIService) StagesAuthenticatorEmailUsedByListExecute(r ApiStagesAuthenticatorEmailUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorEmailUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/email/{stage_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorEndpointGdtcCreateRequest struct {
	ctx                                   context.Context
	ApiService                            *StagesAPIService
	authenticatorEndpointGDTCStageRequest *AuthenticatorEndpointGDTCStageRequest
}

func (r ApiStagesAuthenticatorEndpointGdtcCreateRequest) AuthenticatorEndpointGDTCStageRequest(authenticatorEndpointGDTCStageRequest AuthenticatorEndpointGDTCStageRequest) ApiStagesAuthenticatorEndpointGdtcCreateRequest {
	r.authenticatorEndpointGDTCStageRequest = &authenticatorEndpointGDTCStageRequest
	return r
}

func (r ApiStagesAuthenticatorEndpointGdtcCreateRequest) Execute() (*AuthenticatorEndpointGDTCStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorEndpointGdtcCreateExecute(r)
}

/*
StagesAuthenticatorEndpointGdtcCreate Method for StagesAuthenticatorEndpointGdtcCreate

AuthenticatorEndpointGDTCStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesAuthenticatorEndpointGdtcCreateRequest
*/
func (a *StagesAPIService) StagesAuthenticatorEndpointGdtcCreate(ctx context.Context) ApiStagesAuthenticatorEndpointGdtcCreateRequest {
	return ApiStagesAuthenticatorEndpointGdtcCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AuthenticatorEndpointGDTCStage
func (a *StagesAPIService) StagesAuthenticatorEndpointGdtcCreateExecute(r ApiStagesAuthenticatorEndpointGdtcCreateRequest) (*AuthenticatorEndpointGDTCStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorEndpointGDTCStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorEndpointGdtcCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/endpoint_gdtc/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authenticatorEndpointGDTCStageRequest == nil {
		return localVarReturnValue, nil, reportError("authenticatorEndpointGDTCStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticatorEndpointGDTCStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorEndpointGdtcDestroyRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesAuthenticatorEndpointGdtcDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.StagesAuthenticatorEndpointGdtcDestroyExecute(r)
}

/*
StagesAuthenticatorEndpointGdtcDestroy Method for StagesAuthenticatorEndpointGdtcDestroy

AuthenticatorEndpointGDTCStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Endpoint Authenticator Google Device Trust Connector Stage.
	@return ApiStagesAuthenticatorEndpointGdtcDestroyRequest
*/
func (a *StagesAPIService) StagesAuthenticatorEndpointGdtcDestroy(ctx context.Context, stageUuid string) ApiStagesAuthenticatorEndpointGdtcDestroyRequest {
	return ApiStagesAuthenticatorEndpointGdtcDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
func (a *StagesAPIService) StagesAuthenticatorEndpointGdtcDestroyExecute(r ApiStagesAuthenticatorEndpointGdtcDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorEndpointGdtcDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/endpoint_gdtc/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorEndpointGdtcListRequest struct {
	ctx           context.Context
	ApiService    *StagesAPIService
	configureFlow *string
	name          *string
	ordering      *string
	page          *int32
	pageSize      *int32
	search        *string
}

func (r ApiStagesAuthenticatorEndpointGdtcListRequest) ConfigureFlow(configureFlow string) ApiStagesAuthenticatorEndpointGdtcListRequest {
	r.configureFlow = &configureFlow
	return r
}

func (r ApiStagesAuthenticatorEndpointGdtcListRequest) Name(name string) ApiStagesAuthenticatorEndpointGdtcListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiStagesAuthenticatorEndpointGdtcListRequest) Ordering(ordering string) ApiStagesAuthenticatorEndpointGdtcListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiStagesAuthenticatorEndpointGdtcListRequest) Page(page int32) ApiStagesAuthenticatorEndpointGdtcListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiStagesAuthenticatorEndpointGdtcListRequest) PageSize(pageSize int32) ApiStagesAuthenticatorEndpointGdtcListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiStagesAuthenticatorEndpointGdtcListRequest) Search(search string) ApiStagesAuthenticatorEndpointGdtcListRequest {
	r.search = &search
	return r
}

func (r ApiStagesAuthenticatorEndpointGdtcListRequest) Execute() (*PaginatedAuthenticatorEndpointGDTCStageList, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorEndpointGdtcListExecute(r)
}

/*
StagesAuthenticatorEndpointGdtcList Method for StagesAuthenticatorEndpointGdtcList

AuthenticatorEndpointGDTCStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesAuthenticatorEndpointGdtcListRequest
*/
func (a *StagesAPIService) StagesAuthenticatorEndpointGdtcList(ctx context.Context) ApiStagesAuthenticatorEndpointGdtcListRequest {
	return ApiStagesAuthenticatorEndpointGdtcListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedAuthenticatorEndpointGDTCStageList
func (a *StagesAPIService) StagesAuthenticatorEndpointGdtcListExecute(r ApiStagesAuthenticatorEndpointGdtcListRequest) (*PaginatedAuthenticatorEndpointGDTCStageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedAuthenticatorEndpointGDTCStageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorEndpointGdtcList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/endpoint_gdtc/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.configureFlow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "configure_flow", r.configureFlow, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorEndpointGdtcPartialUpdateRequest struct {
	ctx                                          context.Context
	ApiService                                   *StagesAPIService
	stageUuid                                    string
	patchedAuthenticatorEndpointGDTCStageRequest *PatchedAuthenticatorEndpointGDTCStageRequest
}

func (r ApiStagesAuthenticatorEndpointGdtcPartialUpdateRequest) PatchedAuthenticatorEndpointGDTCStageRequest(patchedAuthenticatorEndpointGDTCStageRequest PatchedAuthenticatorEndpointGDTCStageRequest) ApiStagesAuthenticatorEndpointGdtcPartialUpdateRequest {
	r.patchedAuthenticatorEndpointGDTCStageRequest = &patchedAuthenticatorEndpointGDTCStageRequest
	return r
}

func (r ApiStagesAuthenticatorEndpointGdtcPartialUpdateRequest) Execute() (*AuthenticatorEndpointGDTCStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorEndpointGdtcPartialUpdateExecute(r)
}

/*
StagesAuthenticatorEndpointGdtcPartialUpdate Method for StagesAuthenticatorEndpointGdtcPartialUpdate

AuthenticatorEndpointGDTCStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Endpoint Authenticator Google Device Trust Connector Stage.
	@return ApiStagesAuthenticatorEndpointGdtcPartialUpdateRequest
*/
func (a *StagesAPIService) StagesAuthenticatorEndpointGdtcPartialUpdate(ctx context.Context, stageUuid string) ApiStagesAuthenticatorEndpointGdtcPartialUpdateRequest {
	return ApiStagesAuthenticatorEndpointGdtcPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return AuthenticatorEndpointGDTCStage
func (a *StagesAPIService) StagesAuthenticatorEndpointGdtcPartialUpdateExecute(r ApiStagesAuthenticatorEndpointGdtcPartialUpdateRequest) (*AuthenticatorEndpointGDTCStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorEndpointGDTCStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorEndpointGdtcPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/endpoint_gdtc/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedAuthenticatorEndpointGDTCStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorEndpointGdtcRetrieveRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesAuthenticatorEndpointGdtcRetrieveRequest) Execute() (*AuthenticatorEndpointGDTCStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorEndpointGdtcRetrieveExecute(r)
}

/*
StagesAuthenticatorEndpointGdtcRetrieve Method for StagesAuthenticatorEndpointGdtcRetrieve

AuthenticatorEndpointGDTCStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Endpoint Authenticator Google Device Trust Connector Stage.
	@return ApiStagesAuthenticatorEndpointGdtcRetrieveRequest
*/
func (a *StagesAPIService) StagesAuthenticatorEndpointGdtcRetrieve(ctx context.Context, stageUuid string) ApiStagesAuthenticatorEndpointGdtcRetrieveRequest {
	return ApiStagesAuthenticatorEndpointGdtcRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return AuthenticatorEndpointGDTCStage
func (a *StagesAPIService) StagesAuthenticatorEndpointGdtcRetrieveExecute(r ApiStagesAuthenticatorEndpointGdtcRetrieveRequest) (*AuthenticatorEndpointGDTCStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorEndpointGDTCStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorEndpointGdtcRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/endpoint_gdtc/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorEndpointGdtcUpdateRequest struct {
	ctx                                   context.Context
	ApiService                            *StagesAPIService
	stageUuid                             string
	authenticatorEndpointGDTCStageRequest *AuthenticatorEndpointGDTCStageRequest
}

func (r ApiStagesAuthenticatorEndpointGdtcUpdateRequest) AuthenticatorEndpointGDTCStageRequest(authenticatorEndpointGDTCStageRequest AuthenticatorEndpointGDTCStageRequest) ApiStagesAuthenticatorEndpointGdtcUpdateRequest {
	r.authenticatorEndpointGDTCStageRequest = &authenticatorEndpointGDTCStageRequest
	return r
}

func (r ApiStagesAuthenticatorEndpointGdtcUpdateRequest) Execute() (*AuthenticatorEndpointGDTCStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorEndpointGdtcUpdateExecute(r)
}

/*
StagesAuthenticatorEndpointGdtcUpdate Method for StagesAuthenticatorEndpointGdtcUpdate

AuthenticatorEndpointGDTCStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Endpoint Authenticator Google Device Trust Connector Stage.
	@return ApiStagesAuthenticatorEndpointGdtcUpdateRequest
*/
func (a *StagesAPIService) StagesAuthenticatorEndpointGdtcUpdate(ctx context.Context, stageUuid string) ApiStagesAuthenticatorEndpointGdtcUpdateRequest {
	return ApiStagesAuthenticatorEndpointGdtcUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return AuthenticatorEndpointGDTCStage
func (a *StagesAPIService) StagesAuthenticatorEndpointGdtcUpdateExecute(r ApiStagesAuthenticatorEndpointGdtcUpdateRequest) (*AuthenticatorEndpointGDTCStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorEndpointGDTCStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorEndpointGdtcUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/endpoint_gdtc/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authenticatorEndpointGDTCStageRequest == nil {
		return localVarReturnValue, nil, reportError("authenticatorEndpointGDTCStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticatorEndpointGDTCStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorEndpointGdtcUsedByListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesAuthenticatorEndpointGdtcUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorEndpointGdtcUsedByListExecute(r)
}

/*
StagesAuthenticatorEndpointGdtcUsedByList Method for StagesAuthenticatorEndpointGdtcUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Endpoint Authenticator Google Device Trust Connector Stage.
	@return ApiStagesAuthenticatorEndpointGdtcUsedByListRequest
*/
func (a *StagesAPIService) StagesAuthenticatorEndpointGdtcUsedByList(ctx context.Context, stageUuid string) ApiStagesAuthenticatorEndpointGdtcUsedByListRequest {
	return ApiStagesAuthenticatorEndpointGdtcUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *StagesAPIService) StagesAuthenticatorEndpointGdtcUsedByListExecute(r ApiStagesAuthenticatorEndpointGdtcUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorEndpointGdtcUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/endpoint_gdtc/{stage_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorSmsCreateRequest struct {
	ctx                          context.Context
	ApiService                   *StagesAPIService
	authenticatorSMSStageRequest *AuthenticatorSMSStageRequest
}

func (r ApiStagesAuthenticatorSmsCreateRequest) AuthenticatorSMSStageRequest(authenticatorSMSStageRequest AuthenticatorSMSStageRequest) ApiStagesAuthenticatorSmsCreateRequest {
	r.authenticatorSMSStageRequest = &authenticatorSMSStageRequest
	return r
}

func (r ApiStagesAuthenticatorSmsCreateRequest) Execute() (*AuthenticatorSMSStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorSmsCreateExecute(r)
}

/*
StagesAuthenticatorSmsCreate Method for StagesAuthenticatorSmsCreate

AuthenticatorSMSStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesAuthenticatorSmsCreateRequest
*/
func (a *StagesAPIService) StagesAuthenticatorSmsCreate(ctx context.Context) ApiStagesAuthenticatorSmsCreateRequest {
	return ApiStagesAuthenticatorSmsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AuthenticatorSMSStage
func (a *StagesAPIService) StagesAuthenticatorSmsCreateExecute(r ApiStagesAuthenticatorSmsCreateRequest) (*AuthenticatorSMSStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorSMSStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorSmsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/sms/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authenticatorSMSStageRequest == nil {
		return localVarReturnValue, nil, reportError("authenticatorSMSStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticatorSMSStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorSmsDestroyRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesAuthenticatorSmsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.StagesAuthenticatorSmsDestroyExecute(r)
}

/*
StagesAuthenticatorSmsDestroy Method for StagesAuthenticatorSmsDestroy

AuthenticatorSMSStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this SMS Authenticator Setup Stage.
	@return ApiStagesAuthenticatorSmsDestroyRequest
*/
func (a *StagesAPIService) StagesAuthenticatorSmsDestroy(ctx context.Context, stageUuid string) ApiStagesAuthenticatorSmsDestroyRequest {
	return ApiStagesAuthenticatorSmsDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
func (a *StagesAPIService) StagesAuthenticatorSmsDestroyExecute(r ApiStagesAuthenticatorSmsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorSmsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/sms/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorSmsListRequest struct {
	ctx           context.Context
	ApiService    *StagesAPIService
	accountSid    *string
	auth          *string
	authPassword  *string
	authType      *string
	configureFlow *string
	friendlyName  *string
	fromNumber    *string
	mapping       *string
	name          *string
	ordering      *string
	page          *int32
	pageSize      *int32
	provider      *string
	search        *string
	stageUuid     *string
	verifyOnly    *bool
}

func (r ApiStagesAuthenticatorSmsListRequest) AccountSid(accountSid string) ApiStagesAuthenticatorSmsListRequest {
	r.accountSid = &accountSid
	return r
}

func (r ApiStagesAuthenticatorSmsListRequest) Auth(auth string) ApiStagesAuthenticatorSmsListRequest {
	r.auth = &auth
	return r
}

func (r ApiStagesAuthenticatorSmsListRequest) AuthPassword(authPassword string) ApiStagesAuthenticatorSmsListRequest {
	r.authPassword = &authPassword
	return r
}

func (r ApiStagesAuthenticatorSmsListRequest) AuthType(authType string) ApiStagesAuthenticatorSmsListRequest {
	r.authType = &authType
	return r
}

func (r ApiStagesAuthenticatorSmsListRequest) ConfigureFlow(configureFlow string) ApiStagesAuthenticatorSmsListRequest {
	r.configureFlow = &configureFlow
	return r
}

func (r ApiStagesAuthenticatorSmsListRequest) FriendlyName(friendlyName string) ApiStagesAuthenticatorSmsListRequest {
	r.friendlyName = &friendlyName
	return r
}

func (r ApiStagesAuthenticatorSmsListRequest) FromNumber(fromNumber string) ApiStagesAuthenticatorSmsListRequest {
	r.fromNumber = &fromNumber
	return r
}

func (r ApiStagesAuthenticatorSmsListRequest) Mapping(mapping string) ApiStagesAuthenticatorSmsListRequest {
	r.mapping = &mapping
	return r
}

func (r ApiStagesAuthenticatorSmsListRequest) Name(name string) ApiStagesAuthenticatorSmsListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiStagesAuthenticatorSmsListRequest) Ordering(ordering string) ApiStagesAuthenticatorSmsListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiStagesAuthenticatorSmsListRequest) Page(page int32) ApiStagesAuthenticatorSmsListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiStagesAuthenticatorSmsListRequest) PageSize(pageSize int32) ApiStagesAuthenticatorSmsListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiStagesAuthenticatorSmsListRequest) Provider(provider string) ApiStagesAuthenticatorSmsListRequest {
	r.provider = &provider
	return r
}

// A search term.
func (r ApiStagesAuthenticatorSmsListRequest) Search(search string) ApiStagesAuthenticatorSmsListRequest {
	r.search = &search
	return r
}

func (r ApiStagesAuthenticatorSmsListRequest) StageUuid(stageUuid string) ApiStagesAuthenticatorSmsListRequest {
	r.stageUuid = &stageUuid
	return r
}

func (r ApiStagesAuthenticatorSmsListRequest) VerifyOnly(verifyOnly bool) ApiStagesAuthenticatorSmsListRequest {
	r.verifyOnly = &verifyOnly
	return r
}

func (r ApiStagesAuthenticatorSmsListRequest) Execute() (*PaginatedAuthenticatorSMSStageList, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorSmsListExecute(r)
}

/*
StagesAuthenticatorSmsList Method for StagesAuthenticatorSmsList

AuthenticatorSMSStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesAuthenticatorSmsListRequest
*/
func (a *StagesAPIService) StagesAuthenticatorSmsList(ctx context.Context) ApiStagesAuthenticatorSmsListRequest {
	return ApiStagesAuthenticatorSmsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedAuthenticatorSMSStageList
func (a *StagesAPIService) StagesAuthenticatorSmsListExecute(r ApiStagesAuthenticatorSmsListRequest) (*PaginatedAuthenticatorSMSStageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedAuthenticatorSMSStageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorSmsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/sms/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountSid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account_sid", r.accountSid, "form", "")
	}
	if r.auth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auth", r.auth, "form", "")
	}
	if r.authPassword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auth_password", r.authPassword, "form", "")
	}
	if r.authType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auth_type", r.authType, "form", "")
	}
	if r.configureFlow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "configure_flow", r.configureFlow, "form", "")
	}
	if r.friendlyName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "friendly_name", r.friendlyName, "form", "")
	}
	if r.fromNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_number", r.fromNumber, "form", "")
	}
	if r.mapping != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mapping", r.mapping, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.provider != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "provider", r.provider, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.stageUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stage_uuid", r.stageUuid, "form", "")
	}
	if r.verifyOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "verify_only", r.verifyOnly, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorSmsPartialUpdateRequest struct {
	ctx                                 context.Context
	ApiService                          *StagesAPIService
	stageUuid                           string
	patchedAuthenticatorSMSStageRequest *PatchedAuthenticatorSMSStageRequest
}

func (r ApiStagesAuthenticatorSmsPartialUpdateRequest) PatchedAuthenticatorSMSStageRequest(patchedAuthenticatorSMSStageRequest PatchedAuthenticatorSMSStageRequest) ApiStagesAuthenticatorSmsPartialUpdateRequest {
	r.patchedAuthenticatorSMSStageRequest = &patchedAuthenticatorSMSStageRequest
	return r
}

func (r ApiStagesAuthenticatorSmsPartialUpdateRequest) Execute() (*AuthenticatorSMSStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorSmsPartialUpdateExecute(r)
}

/*
StagesAuthenticatorSmsPartialUpdate Method for StagesAuthenticatorSmsPartialUpdate

AuthenticatorSMSStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this SMS Authenticator Setup Stage.
	@return ApiStagesAuthenticatorSmsPartialUpdateRequest
*/
func (a *StagesAPIService) StagesAuthenticatorSmsPartialUpdate(ctx context.Context, stageUuid string) ApiStagesAuthenticatorSmsPartialUpdateRequest {
	return ApiStagesAuthenticatorSmsPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return AuthenticatorSMSStage
func (a *StagesAPIService) StagesAuthenticatorSmsPartialUpdateExecute(r ApiStagesAuthenticatorSmsPartialUpdateRequest) (*AuthenticatorSMSStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorSMSStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorSmsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/sms/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedAuthenticatorSMSStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorSmsRetrieveRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesAuthenticatorSmsRetrieveRequest) Execute() (*AuthenticatorSMSStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorSmsRetrieveExecute(r)
}

/*
StagesAuthenticatorSmsRetrieve Method for StagesAuthenticatorSmsRetrieve

AuthenticatorSMSStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this SMS Authenticator Setup Stage.
	@return ApiStagesAuthenticatorSmsRetrieveRequest
*/
func (a *StagesAPIService) StagesAuthenticatorSmsRetrieve(ctx context.Context, stageUuid string) ApiStagesAuthenticatorSmsRetrieveRequest {
	return ApiStagesAuthenticatorSmsRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return AuthenticatorSMSStage
func (a *StagesAPIService) StagesAuthenticatorSmsRetrieveExecute(r ApiStagesAuthenticatorSmsRetrieveRequest) (*AuthenticatorSMSStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorSMSStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorSmsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/sms/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorSmsUpdateRequest struct {
	ctx                          context.Context
	ApiService                   *StagesAPIService
	stageUuid                    string
	authenticatorSMSStageRequest *AuthenticatorSMSStageRequest
}

func (r ApiStagesAuthenticatorSmsUpdateRequest) AuthenticatorSMSStageRequest(authenticatorSMSStageRequest AuthenticatorSMSStageRequest) ApiStagesAuthenticatorSmsUpdateRequest {
	r.authenticatorSMSStageRequest = &authenticatorSMSStageRequest
	return r
}

func (r ApiStagesAuthenticatorSmsUpdateRequest) Execute() (*AuthenticatorSMSStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorSmsUpdateExecute(r)
}

/*
StagesAuthenticatorSmsUpdate Method for StagesAuthenticatorSmsUpdate

AuthenticatorSMSStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this SMS Authenticator Setup Stage.
	@return ApiStagesAuthenticatorSmsUpdateRequest
*/
func (a *StagesAPIService) StagesAuthenticatorSmsUpdate(ctx context.Context, stageUuid string) ApiStagesAuthenticatorSmsUpdateRequest {
	return ApiStagesAuthenticatorSmsUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return AuthenticatorSMSStage
func (a *StagesAPIService) StagesAuthenticatorSmsUpdateExecute(r ApiStagesAuthenticatorSmsUpdateRequest) (*AuthenticatorSMSStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorSMSStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorSmsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/sms/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authenticatorSMSStageRequest == nil {
		return localVarReturnValue, nil, reportError("authenticatorSMSStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticatorSMSStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorSmsUsedByListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesAuthenticatorSmsUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorSmsUsedByListExecute(r)
}

/*
StagesAuthenticatorSmsUsedByList Method for StagesAuthenticatorSmsUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this SMS Authenticator Setup Stage.
	@return ApiStagesAuthenticatorSmsUsedByListRequest
*/
func (a *StagesAPIService) StagesAuthenticatorSmsUsedByList(ctx context.Context, stageUuid string) ApiStagesAuthenticatorSmsUsedByListRequest {
	return ApiStagesAuthenticatorSmsUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *StagesAPIService) StagesAuthenticatorSmsUsedByListExecute(r ApiStagesAuthenticatorSmsUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorSmsUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/sms/{stage_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorStaticCreateRequest struct {
	ctx                             context.Context
	ApiService                      *StagesAPIService
	authenticatorStaticStageRequest *AuthenticatorStaticStageRequest
}

func (r ApiStagesAuthenticatorStaticCreateRequest) AuthenticatorStaticStageRequest(authenticatorStaticStageRequest AuthenticatorStaticStageRequest) ApiStagesAuthenticatorStaticCreateRequest {
	r.authenticatorStaticStageRequest = &authenticatorStaticStageRequest
	return r
}

func (r ApiStagesAuthenticatorStaticCreateRequest) Execute() (*AuthenticatorStaticStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorStaticCreateExecute(r)
}

/*
StagesAuthenticatorStaticCreate Method for StagesAuthenticatorStaticCreate

AuthenticatorStaticStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesAuthenticatorStaticCreateRequest
*/
func (a *StagesAPIService) StagesAuthenticatorStaticCreate(ctx context.Context) ApiStagesAuthenticatorStaticCreateRequest {
	return ApiStagesAuthenticatorStaticCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AuthenticatorStaticStage
func (a *StagesAPIService) StagesAuthenticatorStaticCreateExecute(r ApiStagesAuthenticatorStaticCreateRequest) (*AuthenticatorStaticStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorStaticStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorStaticCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/static/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authenticatorStaticStageRequest == nil {
		return localVarReturnValue, nil, reportError("authenticatorStaticStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticatorStaticStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorStaticDestroyRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesAuthenticatorStaticDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.StagesAuthenticatorStaticDestroyExecute(r)
}

/*
StagesAuthenticatorStaticDestroy Method for StagesAuthenticatorStaticDestroy

AuthenticatorStaticStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Static Authenticator Setup Stage.
	@return ApiStagesAuthenticatorStaticDestroyRequest
*/
func (a *StagesAPIService) StagesAuthenticatorStaticDestroy(ctx context.Context, stageUuid string) ApiStagesAuthenticatorStaticDestroyRequest {
	return ApiStagesAuthenticatorStaticDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
func (a *StagesAPIService) StagesAuthenticatorStaticDestroyExecute(r ApiStagesAuthenticatorStaticDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorStaticDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/static/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorStaticListRequest struct {
	ctx           context.Context
	ApiService    *StagesAPIService
	configureFlow *string
	friendlyName  *string
	name          *string
	ordering      *string
	page          *int32
	pageSize      *int32
	search        *string
	stageUuid     *string
	tokenCount    *int32
	tokenLength   *int32
}

func (r ApiStagesAuthenticatorStaticListRequest) ConfigureFlow(configureFlow string) ApiStagesAuthenticatorStaticListRequest {
	r.configureFlow = &configureFlow
	return r
}

func (r ApiStagesAuthenticatorStaticListRequest) FriendlyName(friendlyName string) ApiStagesAuthenticatorStaticListRequest {
	r.friendlyName = &friendlyName
	return r
}

func (r ApiStagesAuthenticatorStaticListRequest) Name(name string) ApiStagesAuthenticatorStaticListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiStagesAuthenticatorStaticListRequest) Ordering(ordering string) ApiStagesAuthenticatorStaticListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiStagesAuthenticatorStaticListRequest) Page(page int32) ApiStagesAuthenticatorStaticListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiStagesAuthenticatorStaticListRequest) PageSize(pageSize int32) ApiStagesAuthenticatorStaticListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiStagesAuthenticatorStaticListRequest) Search(search string) ApiStagesAuthenticatorStaticListRequest {
	r.search = &search
	return r
}

func (r ApiStagesAuthenticatorStaticListRequest) StageUuid(stageUuid string) ApiStagesAuthenticatorStaticListRequest {
	r.stageUuid = &stageUuid
	return r
}

func (r ApiStagesAuthenticatorStaticListRequest) TokenCount(tokenCount int32) ApiStagesAuthenticatorStaticListRequest {
	r.tokenCount = &tokenCount
	return r
}

func (r ApiStagesAuthenticatorStaticListRequest) TokenLength(tokenLength int32) ApiStagesAuthenticatorStaticListRequest {
	r.tokenLength = &tokenLength
	return r
}

func (r ApiStagesAuthenticatorStaticListRequest) Execute() (*PaginatedAuthenticatorStaticStageList, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorStaticListExecute(r)
}

/*
StagesAuthenticatorStaticList Method for StagesAuthenticatorStaticList

AuthenticatorStaticStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesAuthenticatorStaticListRequest
*/
func (a *StagesAPIService) StagesAuthenticatorStaticList(ctx context.Context) ApiStagesAuthenticatorStaticListRequest {
	return ApiStagesAuthenticatorStaticListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedAuthenticatorStaticStageList
func (a *StagesAPIService) StagesAuthenticatorStaticListExecute(r ApiStagesAuthenticatorStaticListRequest) (*PaginatedAuthenticatorStaticStageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedAuthenticatorStaticStageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorStaticList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/static/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.configureFlow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "configure_flow", r.configureFlow, "form", "")
	}
	if r.friendlyName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "friendly_name", r.friendlyName, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.stageUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stage_uuid", r.stageUuid, "form", "")
	}
	if r.tokenCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token_count", r.tokenCount, "form", "")
	}
	if r.tokenLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token_length", r.tokenLength, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorStaticPartialUpdateRequest struct {
	ctx                                    context.Context
	ApiService                             *StagesAPIService
	stageUuid                              string
	patchedAuthenticatorStaticStageRequest *PatchedAuthenticatorStaticStageRequest
}

func (r ApiStagesAuthenticatorStaticPartialUpdateRequest) PatchedAuthenticatorStaticStageRequest(patchedAuthenticatorStaticStageRequest PatchedAuthenticatorStaticStageRequest) ApiStagesAuthenticatorStaticPartialUpdateRequest {
	r.patchedAuthenticatorStaticStageRequest = &patchedAuthenticatorStaticStageRequest
	return r
}

func (r ApiStagesAuthenticatorStaticPartialUpdateRequest) Execute() (*AuthenticatorStaticStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorStaticPartialUpdateExecute(r)
}

/*
StagesAuthenticatorStaticPartialUpdate Method for StagesAuthenticatorStaticPartialUpdate

AuthenticatorStaticStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Static Authenticator Setup Stage.
	@return ApiStagesAuthenticatorStaticPartialUpdateRequest
*/
func (a *StagesAPIService) StagesAuthenticatorStaticPartialUpdate(ctx context.Context, stageUuid string) ApiStagesAuthenticatorStaticPartialUpdateRequest {
	return ApiStagesAuthenticatorStaticPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return AuthenticatorStaticStage
func (a *StagesAPIService) StagesAuthenticatorStaticPartialUpdateExecute(r ApiStagesAuthenticatorStaticPartialUpdateRequest) (*AuthenticatorStaticStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorStaticStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorStaticPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/static/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedAuthenticatorStaticStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorStaticRetrieveRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesAuthenticatorStaticRetrieveRequest) Execute() (*AuthenticatorStaticStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorStaticRetrieveExecute(r)
}

/*
StagesAuthenticatorStaticRetrieve Method for StagesAuthenticatorStaticRetrieve

AuthenticatorStaticStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Static Authenticator Setup Stage.
	@return ApiStagesAuthenticatorStaticRetrieveRequest
*/
func (a *StagesAPIService) StagesAuthenticatorStaticRetrieve(ctx context.Context, stageUuid string) ApiStagesAuthenticatorStaticRetrieveRequest {
	return ApiStagesAuthenticatorStaticRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return AuthenticatorStaticStage
func (a *StagesAPIService) StagesAuthenticatorStaticRetrieveExecute(r ApiStagesAuthenticatorStaticRetrieveRequest) (*AuthenticatorStaticStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorStaticStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorStaticRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/static/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorStaticUpdateRequest struct {
	ctx                             context.Context
	ApiService                      *StagesAPIService
	stageUuid                       string
	authenticatorStaticStageRequest *AuthenticatorStaticStageRequest
}

func (r ApiStagesAuthenticatorStaticUpdateRequest) AuthenticatorStaticStageRequest(authenticatorStaticStageRequest AuthenticatorStaticStageRequest) ApiStagesAuthenticatorStaticUpdateRequest {
	r.authenticatorStaticStageRequest = &authenticatorStaticStageRequest
	return r
}

func (r ApiStagesAuthenticatorStaticUpdateRequest) Execute() (*AuthenticatorStaticStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorStaticUpdateExecute(r)
}

/*
StagesAuthenticatorStaticUpdate Method for StagesAuthenticatorStaticUpdate

AuthenticatorStaticStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Static Authenticator Setup Stage.
	@return ApiStagesAuthenticatorStaticUpdateRequest
*/
func (a *StagesAPIService) StagesAuthenticatorStaticUpdate(ctx context.Context, stageUuid string) ApiStagesAuthenticatorStaticUpdateRequest {
	return ApiStagesAuthenticatorStaticUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return AuthenticatorStaticStage
func (a *StagesAPIService) StagesAuthenticatorStaticUpdateExecute(r ApiStagesAuthenticatorStaticUpdateRequest) (*AuthenticatorStaticStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorStaticStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorStaticUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/static/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authenticatorStaticStageRequest == nil {
		return localVarReturnValue, nil, reportError("authenticatorStaticStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticatorStaticStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorStaticUsedByListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesAuthenticatorStaticUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorStaticUsedByListExecute(r)
}

/*
StagesAuthenticatorStaticUsedByList Method for StagesAuthenticatorStaticUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Static Authenticator Setup Stage.
	@return ApiStagesAuthenticatorStaticUsedByListRequest
*/
func (a *StagesAPIService) StagesAuthenticatorStaticUsedByList(ctx context.Context, stageUuid string) ApiStagesAuthenticatorStaticUsedByListRequest {
	return ApiStagesAuthenticatorStaticUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *StagesAPIService) StagesAuthenticatorStaticUsedByListExecute(r ApiStagesAuthenticatorStaticUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorStaticUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/static/{stage_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorTotpCreateRequest struct {
	ctx                           context.Context
	ApiService                    *StagesAPIService
	authenticatorTOTPStageRequest *AuthenticatorTOTPStageRequest
}

func (r ApiStagesAuthenticatorTotpCreateRequest) AuthenticatorTOTPStageRequest(authenticatorTOTPStageRequest AuthenticatorTOTPStageRequest) ApiStagesAuthenticatorTotpCreateRequest {
	r.authenticatorTOTPStageRequest = &authenticatorTOTPStageRequest
	return r
}

func (r ApiStagesAuthenticatorTotpCreateRequest) Execute() (*AuthenticatorTOTPStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorTotpCreateExecute(r)
}

/*
StagesAuthenticatorTotpCreate Method for StagesAuthenticatorTotpCreate

AuthenticatorTOTPStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesAuthenticatorTotpCreateRequest
*/
func (a *StagesAPIService) StagesAuthenticatorTotpCreate(ctx context.Context) ApiStagesAuthenticatorTotpCreateRequest {
	return ApiStagesAuthenticatorTotpCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AuthenticatorTOTPStage
func (a *StagesAPIService) StagesAuthenticatorTotpCreateExecute(r ApiStagesAuthenticatorTotpCreateRequest) (*AuthenticatorTOTPStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorTOTPStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorTotpCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/totp/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authenticatorTOTPStageRequest == nil {
		return localVarReturnValue, nil, reportError("authenticatorTOTPStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticatorTOTPStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorTotpDestroyRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesAuthenticatorTotpDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.StagesAuthenticatorTotpDestroyExecute(r)
}

/*
StagesAuthenticatorTotpDestroy Method for StagesAuthenticatorTotpDestroy

AuthenticatorTOTPStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this TOTP Authenticator Setup Stage.
	@return ApiStagesAuthenticatorTotpDestroyRequest
*/
func (a *StagesAPIService) StagesAuthenticatorTotpDestroy(ctx context.Context, stageUuid string) ApiStagesAuthenticatorTotpDestroyRequest {
	return ApiStagesAuthenticatorTotpDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
func (a *StagesAPIService) StagesAuthenticatorTotpDestroyExecute(r ApiStagesAuthenticatorTotpDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorTotpDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/totp/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorTotpListRequest struct {
	ctx           context.Context
	ApiService    *StagesAPIService
	configureFlow *string
	digits        *string
	friendlyName  *string
	name          *string
	ordering      *string
	page          *int32
	pageSize      *int32
	search        *string
	stageUuid     *string
}

func (r ApiStagesAuthenticatorTotpListRequest) ConfigureFlow(configureFlow string) ApiStagesAuthenticatorTotpListRequest {
	r.configureFlow = &configureFlow
	return r
}

func (r ApiStagesAuthenticatorTotpListRequest) Digits(digits string) ApiStagesAuthenticatorTotpListRequest {
	r.digits = &digits
	return r
}

func (r ApiStagesAuthenticatorTotpListRequest) FriendlyName(friendlyName string) ApiStagesAuthenticatorTotpListRequest {
	r.friendlyName = &friendlyName
	return r
}

func (r ApiStagesAuthenticatorTotpListRequest) Name(name string) ApiStagesAuthenticatorTotpListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiStagesAuthenticatorTotpListRequest) Ordering(ordering string) ApiStagesAuthenticatorTotpListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiStagesAuthenticatorTotpListRequest) Page(page int32) ApiStagesAuthenticatorTotpListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiStagesAuthenticatorTotpListRequest) PageSize(pageSize int32) ApiStagesAuthenticatorTotpListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiStagesAuthenticatorTotpListRequest) Search(search string) ApiStagesAuthenticatorTotpListRequest {
	r.search = &search
	return r
}

func (r ApiStagesAuthenticatorTotpListRequest) StageUuid(stageUuid string) ApiStagesAuthenticatorTotpListRequest {
	r.stageUuid = &stageUuid
	return r
}

func (r ApiStagesAuthenticatorTotpListRequest) Execute() (*PaginatedAuthenticatorTOTPStageList, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorTotpListExecute(r)
}

/*
StagesAuthenticatorTotpList Method for StagesAuthenticatorTotpList

AuthenticatorTOTPStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesAuthenticatorTotpListRequest
*/
func (a *StagesAPIService) StagesAuthenticatorTotpList(ctx context.Context) ApiStagesAuthenticatorTotpListRequest {
	return ApiStagesAuthenticatorTotpListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedAuthenticatorTOTPStageList
func (a *StagesAPIService) StagesAuthenticatorTotpListExecute(r ApiStagesAuthenticatorTotpListRequest) (*PaginatedAuthenticatorTOTPStageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedAuthenticatorTOTPStageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorTotpList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/totp/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.configureFlow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "configure_flow", r.configureFlow, "form", "")
	}
	if r.digits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "digits", r.digits, "form", "")
	}
	if r.friendlyName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "friendly_name", r.friendlyName, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.stageUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stage_uuid", r.stageUuid, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorTotpPartialUpdateRequest struct {
	ctx                                  context.Context
	ApiService                           *StagesAPIService
	stageUuid                            string
	patchedAuthenticatorTOTPStageRequest *PatchedAuthenticatorTOTPStageRequest
}

func (r ApiStagesAuthenticatorTotpPartialUpdateRequest) PatchedAuthenticatorTOTPStageRequest(patchedAuthenticatorTOTPStageRequest PatchedAuthenticatorTOTPStageRequest) ApiStagesAuthenticatorTotpPartialUpdateRequest {
	r.patchedAuthenticatorTOTPStageRequest = &patchedAuthenticatorTOTPStageRequest
	return r
}

func (r ApiStagesAuthenticatorTotpPartialUpdateRequest) Execute() (*AuthenticatorTOTPStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorTotpPartialUpdateExecute(r)
}

/*
StagesAuthenticatorTotpPartialUpdate Method for StagesAuthenticatorTotpPartialUpdate

AuthenticatorTOTPStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this TOTP Authenticator Setup Stage.
	@return ApiStagesAuthenticatorTotpPartialUpdateRequest
*/
func (a *StagesAPIService) StagesAuthenticatorTotpPartialUpdate(ctx context.Context, stageUuid string) ApiStagesAuthenticatorTotpPartialUpdateRequest {
	return ApiStagesAuthenticatorTotpPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return AuthenticatorTOTPStage
func (a *StagesAPIService) StagesAuthenticatorTotpPartialUpdateExecute(r ApiStagesAuthenticatorTotpPartialUpdateRequest) (*AuthenticatorTOTPStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorTOTPStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorTotpPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/totp/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedAuthenticatorTOTPStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorTotpRetrieveRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesAuthenticatorTotpRetrieveRequest) Execute() (*AuthenticatorTOTPStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorTotpRetrieveExecute(r)
}

/*
StagesAuthenticatorTotpRetrieve Method for StagesAuthenticatorTotpRetrieve

AuthenticatorTOTPStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this TOTP Authenticator Setup Stage.
	@return ApiStagesAuthenticatorTotpRetrieveRequest
*/
func (a *StagesAPIService) StagesAuthenticatorTotpRetrieve(ctx context.Context, stageUuid string) ApiStagesAuthenticatorTotpRetrieveRequest {
	return ApiStagesAuthenticatorTotpRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return AuthenticatorTOTPStage
func (a *StagesAPIService) StagesAuthenticatorTotpRetrieveExecute(r ApiStagesAuthenticatorTotpRetrieveRequest) (*AuthenticatorTOTPStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorTOTPStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorTotpRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/totp/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorTotpUpdateRequest struct {
	ctx                           context.Context
	ApiService                    *StagesAPIService
	stageUuid                     string
	authenticatorTOTPStageRequest *AuthenticatorTOTPStageRequest
}

func (r ApiStagesAuthenticatorTotpUpdateRequest) AuthenticatorTOTPStageRequest(authenticatorTOTPStageRequest AuthenticatorTOTPStageRequest) ApiStagesAuthenticatorTotpUpdateRequest {
	r.authenticatorTOTPStageRequest = &authenticatorTOTPStageRequest
	return r
}

func (r ApiStagesAuthenticatorTotpUpdateRequest) Execute() (*AuthenticatorTOTPStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorTotpUpdateExecute(r)
}

/*
StagesAuthenticatorTotpUpdate Method for StagesAuthenticatorTotpUpdate

AuthenticatorTOTPStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this TOTP Authenticator Setup Stage.
	@return ApiStagesAuthenticatorTotpUpdateRequest
*/
func (a *StagesAPIService) StagesAuthenticatorTotpUpdate(ctx context.Context, stageUuid string) ApiStagesAuthenticatorTotpUpdateRequest {
	return ApiStagesAuthenticatorTotpUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return AuthenticatorTOTPStage
func (a *StagesAPIService) StagesAuthenticatorTotpUpdateExecute(r ApiStagesAuthenticatorTotpUpdateRequest) (*AuthenticatorTOTPStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorTOTPStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorTotpUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/totp/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authenticatorTOTPStageRequest == nil {
		return localVarReturnValue, nil, reportError("authenticatorTOTPStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticatorTOTPStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorTotpUsedByListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesAuthenticatorTotpUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorTotpUsedByListExecute(r)
}

/*
StagesAuthenticatorTotpUsedByList Method for StagesAuthenticatorTotpUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this TOTP Authenticator Setup Stage.
	@return ApiStagesAuthenticatorTotpUsedByListRequest
*/
func (a *StagesAPIService) StagesAuthenticatorTotpUsedByList(ctx context.Context, stageUuid string) ApiStagesAuthenticatorTotpUsedByListRequest {
	return ApiStagesAuthenticatorTotpUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *StagesAPIService) StagesAuthenticatorTotpUsedByListExecute(r ApiStagesAuthenticatorTotpUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorTotpUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/totp/{stage_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorValidateCreateRequest struct {
	ctx                               context.Context
	ApiService                        *StagesAPIService
	authenticatorValidateStageRequest *AuthenticatorValidateStageRequest
}

func (r ApiStagesAuthenticatorValidateCreateRequest) AuthenticatorValidateStageRequest(authenticatorValidateStageRequest AuthenticatorValidateStageRequest) ApiStagesAuthenticatorValidateCreateRequest {
	r.authenticatorValidateStageRequest = &authenticatorValidateStageRequest
	return r
}

func (r ApiStagesAuthenticatorValidateCreateRequest) Execute() (*AuthenticatorValidateStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorValidateCreateExecute(r)
}

/*
StagesAuthenticatorValidateCreate Method for StagesAuthenticatorValidateCreate

AuthenticatorValidateStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesAuthenticatorValidateCreateRequest
*/
func (a *StagesAPIService) StagesAuthenticatorValidateCreate(ctx context.Context) ApiStagesAuthenticatorValidateCreateRequest {
	return ApiStagesAuthenticatorValidateCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AuthenticatorValidateStage
func (a *StagesAPIService) StagesAuthenticatorValidateCreateExecute(r ApiStagesAuthenticatorValidateCreateRequest) (*AuthenticatorValidateStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorValidateStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorValidateCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/validate/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authenticatorValidateStageRequest == nil {
		return localVarReturnValue, nil, reportError("authenticatorValidateStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticatorValidateStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorValidateDestroyRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesAuthenticatorValidateDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.StagesAuthenticatorValidateDestroyExecute(r)
}

/*
StagesAuthenticatorValidateDestroy Method for StagesAuthenticatorValidateDestroy

AuthenticatorValidateStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Authenticator Validation Stage.
	@return ApiStagesAuthenticatorValidateDestroyRequest
*/
func (a *StagesAPIService) StagesAuthenticatorValidateDestroy(ctx context.Context, stageUuid string) ApiStagesAuthenticatorValidateDestroyRequest {
	return ApiStagesAuthenticatorValidateDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
func (a *StagesAPIService) StagesAuthenticatorValidateDestroyExecute(r ApiStagesAuthenticatorValidateDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorValidateDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/validate/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorValidateListRequest struct {
	ctx                 context.Context
	ApiService          *StagesAPIService
	configurationStages *[]string
	name                *string
	notConfiguredAction *string
	ordering            *string
	page                *int32
	pageSize            *int32
	search              *string
}

func (r ApiStagesAuthenticatorValidateListRequest) ConfigurationStages(configurationStages []string) ApiStagesAuthenticatorValidateListRequest {
	r.configurationStages = &configurationStages
	return r
}

func (r ApiStagesAuthenticatorValidateListRequest) Name(name string) ApiStagesAuthenticatorValidateListRequest {
	r.name = &name
	return r
}

func (r ApiStagesAuthenticatorValidateListRequest) NotConfiguredAction(notConfiguredAction string) ApiStagesAuthenticatorValidateListRequest {
	r.notConfiguredAction = &notConfiguredAction
	return r
}

// Which field to use when ordering the results.
func (r ApiStagesAuthenticatorValidateListRequest) Ordering(ordering string) ApiStagesAuthenticatorValidateListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiStagesAuthenticatorValidateListRequest) Page(page int32) ApiStagesAuthenticatorValidateListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiStagesAuthenticatorValidateListRequest) PageSize(pageSize int32) ApiStagesAuthenticatorValidateListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiStagesAuthenticatorValidateListRequest) Search(search string) ApiStagesAuthenticatorValidateListRequest {
	r.search = &search
	return r
}

func (r ApiStagesAuthenticatorValidateListRequest) Execute() (*PaginatedAuthenticatorValidateStageList, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorValidateListExecute(r)
}

/*
StagesAuthenticatorValidateList Method for StagesAuthenticatorValidateList

AuthenticatorValidateStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesAuthenticatorValidateListRequest
*/
func (a *StagesAPIService) StagesAuthenticatorValidateList(ctx context.Context) ApiStagesAuthenticatorValidateListRequest {
	return ApiStagesAuthenticatorValidateListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedAuthenticatorValidateStageList
func (a *StagesAPIService) StagesAuthenticatorValidateListExecute(r ApiStagesAuthenticatorValidateListRequest) (*PaginatedAuthenticatorValidateStageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedAuthenticatorValidateStageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorValidateList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/validate/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.configurationStages != nil {
		t := *r.configurationStages
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "configuration_stages", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "configuration_stages", t, "form", "multi")
		}
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.notConfiguredAction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "not_configured_action", r.notConfiguredAction, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorValidatePartialUpdateRequest struct {
	ctx                                      context.Context
	ApiService                               *StagesAPIService
	stageUuid                                string
	patchedAuthenticatorValidateStageRequest *PatchedAuthenticatorValidateStageRequest
}

func (r ApiStagesAuthenticatorValidatePartialUpdateRequest) PatchedAuthenticatorValidateStageRequest(patchedAuthenticatorValidateStageRequest PatchedAuthenticatorValidateStageRequest) ApiStagesAuthenticatorValidatePartialUpdateRequest {
	r.patchedAuthenticatorValidateStageRequest = &patchedAuthenticatorValidateStageRequest
	return r
}

func (r ApiStagesAuthenticatorValidatePartialUpdateRequest) Execute() (*AuthenticatorValidateStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorValidatePartialUpdateExecute(r)
}

/*
StagesAuthenticatorValidatePartialUpdate Method for StagesAuthenticatorValidatePartialUpdate

AuthenticatorValidateStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Authenticator Validation Stage.
	@return ApiStagesAuthenticatorValidatePartialUpdateRequest
*/
func (a *StagesAPIService) StagesAuthenticatorValidatePartialUpdate(ctx context.Context, stageUuid string) ApiStagesAuthenticatorValidatePartialUpdateRequest {
	return ApiStagesAuthenticatorValidatePartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return AuthenticatorValidateStage
func (a *StagesAPIService) StagesAuthenticatorValidatePartialUpdateExecute(r ApiStagesAuthenticatorValidatePartialUpdateRequest) (*AuthenticatorValidateStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorValidateStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorValidatePartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/validate/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedAuthenticatorValidateStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorValidateRetrieveRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesAuthenticatorValidateRetrieveRequest) Execute() (*AuthenticatorValidateStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorValidateRetrieveExecute(r)
}

/*
StagesAuthenticatorValidateRetrieve Method for StagesAuthenticatorValidateRetrieve

AuthenticatorValidateStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Authenticator Validation Stage.
	@return ApiStagesAuthenticatorValidateRetrieveRequest
*/
func (a *StagesAPIService) StagesAuthenticatorValidateRetrieve(ctx context.Context, stageUuid string) ApiStagesAuthenticatorValidateRetrieveRequest {
	return ApiStagesAuthenticatorValidateRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return AuthenticatorValidateStage
func (a *StagesAPIService) StagesAuthenticatorValidateRetrieveExecute(r ApiStagesAuthenticatorValidateRetrieveRequest) (*AuthenticatorValidateStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorValidateStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorValidateRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/validate/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorValidateUpdateRequest struct {
	ctx                               context.Context
	ApiService                        *StagesAPIService
	stageUuid                         string
	authenticatorValidateStageRequest *AuthenticatorValidateStageRequest
}

func (r ApiStagesAuthenticatorValidateUpdateRequest) AuthenticatorValidateStageRequest(authenticatorValidateStageRequest AuthenticatorValidateStageRequest) ApiStagesAuthenticatorValidateUpdateRequest {
	r.authenticatorValidateStageRequest = &authenticatorValidateStageRequest
	return r
}

func (r ApiStagesAuthenticatorValidateUpdateRequest) Execute() (*AuthenticatorValidateStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorValidateUpdateExecute(r)
}

/*
StagesAuthenticatorValidateUpdate Method for StagesAuthenticatorValidateUpdate

AuthenticatorValidateStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Authenticator Validation Stage.
	@return ApiStagesAuthenticatorValidateUpdateRequest
*/
func (a *StagesAPIService) StagesAuthenticatorValidateUpdate(ctx context.Context, stageUuid string) ApiStagesAuthenticatorValidateUpdateRequest {
	return ApiStagesAuthenticatorValidateUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return AuthenticatorValidateStage
func (a *StagesAPIService) StagesAuthenticatorValidateUpdateExecute(r ApiStagesAuthenticatorValidateUpdateRequest) (*AuthenticatorValidateStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorValidateStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorValidateUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/validate/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authenticatorValidateStageRequest == nil {
		return localVarReturnValue, nil, reportError("authenticatorValidateStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticatorValidateStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorValidateUsedByListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesAuthenticatorValidateUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorValidateUsedByListExecute(r)
}

/*
StagesAuthenticatorValidateUsedByList Method for StagesAuthenticatorValidateUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Authenticator Validation Stage.
	@return ApiStagesAuthenticatorValidateUsedByListRequest
*/
func (a *StagesAPIService) StagesAuthenticatorValidateUsedByList(ctx context.Context, stageUuid string) ApiStagesAuthenticatorValidateUsedByListRequest {
	return ApiStagesAuthenticatorValidateUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *StagesAPIService) StagesAuthenticatorValidateUsedByListExecute(r ApiStagesAuthenticatorValidateUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorValidateUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/validate/{stage_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorWebauthnCreateRequest struct {
	ctx                               context.Context
	ApiService                        *StagesAPIService
	authenticatorWebAuthnStageRequest *AuthenticatorWebAuthnStageRequest
}

func (r ApiStagesAuthenticatorWebauthnCreateRequest) AuthenticatorWebAuthnStageRequest(authenticatorWebAuthnStageRequest AuthenticatorWebAuthnStageRequest) ApiStagesAuthenticatorWebauthnCreateRequest {
	r.authenticatorWebAuthnStageRequest = &authenticatorWebAuthnStageRequest
	return r
}

func (r ApiStagesAuthenticatorWebauthnCreateRequest) Execute() (*AuthenticatorWebAuthnStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorWebauthnCreateExecute(r)
}

/*
StagesAuthenticatorWebauthnCreate Method for StagesAuthenticatorWebauthnCreate

AuthenticatorWebAuthnStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesAuthenticatorWebauthnCreateRequest
*/
func (a *StagesAPIService) StagesAuthenticatorWebauthnCreate(ctx context.Context) ApiStagesAuthenticatorWebauthnCreateRequest {
	return ApiStagesAuthenticatorWebauthnCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AuthenticatorWebAuthnStage
func (a *StagesAPIService) StagesAuthenticatorWebauthnCreateExecute(r ApiStagesAuthenticatorWebauthnCreateRequest) (*AuthenticatorWebAuthnStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorWebAuthnStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorWebauthnCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/webauthn/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authenticatorWebAuthnStageRequest == nil {
		return localVarReturnValue, nil, reportError("authenticatorWebAuthnStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticatorWebAuthnStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorWebauthnDestroyRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesAuthenticatorWebauthnDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.StagesAuthenticatorWebauthnDestroyExecute(r)
}

/*
StagesAuthenticatorWebauthnDestroy Method for StagesAuthenticatorWebauthnDestroy

AuthenticatorWebAuthnStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this WebAuthn Authenticator Setup Stage.
	@return ApiStagesAuthenticatorWebauthnDestroyRequest
*/
func (a *StagesAPIService) StagesAuthenticatorWebauthnDestroy(ctx context.Context, stageUuid string) ApiStagesAuthenticatorWebauthnDestroyRequest {
	return ApiStagesAuthenticatorWebauthnDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
func (a *StagesAPIService) StagesAuthenticatorWebauthnDestroyExecute(r ApiStagesAuthenticatorWebauthnDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorWebauthnDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/webauthn/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorWebauthnDeviceTypesListRequest struct {
	ctx         context.Context
	ApiService  *StagesAPIService
	aaguid      *string
	description *string
	icon        *string
	ordering    *string
	page        *int32
	pageSize    *int32
	search      *string
}

func (r ApiStagesAuthenticatorWebauthnDeviceTypesListRequest) Aaguid(aaguid string) ApiStagesAuthenticatorWebauthnDeviceTypesListRequest {
	r.aaguid = &aaguid
	return r
}

func (r ApiStagesAuthenticatorWebauthnDeviceTypesListRequest) Description(description string) ApiStagesAuthenticatorWebauthnDeviceTypesListRequest {
	r.description = &description
	return r
}

func (r ApiStagesAuthenticatorWebauthnDeviceTypesListRequest) Icon(icon string) ApiStagesAuthenticatorWebauthnDeviceTypesListRequest {
	r.icon = &icon
	return r
}

// Which field to use when ordering the results.
func (r ApiStagesAuthenticatorWebauthnDeviceTypesListRequest) Ordering(ordering string) ApiStagesAuthenticatorWebauthnDeviceTypesListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiStagesAuthenticatorWebauthnDeviceTypesListRequest) Page(page int32) ApiStagesAuthenticatorWebauthnDeviceTypesListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiStagesAuthenticatorWebauthnDeviceTypesListRequest) PageSize(pageSize int32) ApiStagesAuthenticatorWebauthnDeviceTypesListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiStagesAuthenticatorWebauthnDeviceTypesListRequest) Search(search string) ApiStagesAuthenticatorWebauthnDeviceTypesListRequest {
	r.search = &search
	return r
}

func (r ApiStagesAuthenticatorWebauthnDeviceTypesListRequest) Execute() (*PaginatedWebAuthnDeviceTypeList, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorWebauthnDeviceTypesListExecute(r)
}

/*
StagesAuthenticatorWebauthnDeviceTypesList Method for StagesAuthenticatorWebauthnDeviceTypesList

WebAuthnDeviceType Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesAuthenticatorWebauthnDeviceTypesListRequest
*/
func (a *StagesAPIService) StagesAuthenticatorWebauthnDeviceTypesList(ctx context.Context) ApiStagesAuthenticatorWebauthnDeviceTypesListRequest {
	return ApiStagesAuthenticatorWebauthnDeviceTypesListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedWebAuthnDeviceTypeList
func (a *StagesAPIService) StagesAuthenticatorWebauthnDeviceTypesListExecute(r ApiStagesAuthenticatorWebauthnDeviceTypesListRequest) (*PaginatedWebAuthnDeviceTypeList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedWebAuthnDeviceTypeList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorWebauthnDeviceTypesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/webauthn_device_types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.aaguid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aaguid", r.aaguid, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.icon != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "icon", r.icon, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorWebauthnDeviceTypesRetrieveRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	aaguid     string
}

func (r ApiStagesAuthenticatorWebauthnDeviceTypesRetrieveRequest) Execute() (*WebAuthnDeviceType, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorWebauthnDeviceTypesRetrieveExecute(r)
}

/*
StagesAuthenticatorWebauthnDeviceTypesRetrieve Method for StagesAuthenticatorWebauthnDeviceTypesRetrieve

WebAuthnDeviceType Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param aaguid A UUID string identifying this WebAuthn Device type.
	@return ApiStagesAuthenticatorWebauthnDeviceTypesRetrieveRequest
*/
func (a *StagesAPIService) StagesAuthenticatorWebauthnDeviceTypesRetrieve(ctx context.Context, aaguid string) ApiStagesAuthenticatorWebauthnDeviceTypesRetrieveRequest {
	return ApiStagesAuthenticatorWebauthnDeviceTypesRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		aaguid:     aaguid,
	}
}

// Execute executes the request
//
//	@return WebAuthnDeviceType
func (a *StagesAPIService) StagesAuthenticatorWebauthnDeviceTypesRetrieveExecute(r ApiStagesAuthenticatorWebauthnDeviceTypesRetrieveRequest) (*WebAuthnDeviceType, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebAuthnDeviceType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorWebauthnDeviceTypesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/webauthn_device_types/{aaguid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"aaguid"+"}", url.PathEscape(parameterValueToString(r.aaguid, "aaguid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorWebauthnListRequest struct {
	ctx                     context.Context
	ApiService              *StagesAPIService
	authenticatorAttachment *string
	configureFlow           *string
	deviceTypeRestrictions  *[]string
	friendlyName            *string
	maxAttempts             *int32
	name                    *string
	ordering                *string
	page                    *int32
	pageSize                *int32
	residentKeyRequirement  *string
	search                  *string
	stageUuid               *string
	userVerification        *string
}

func (r ApiStagesAuthenticatorWebauthnListRequest) AuthenticatorAttachment(authenticatorAttachment string) ApiStagesAuthenticatorWebauthnListRequest {
	r.authenticatorAttachment = &authenticatorAttachment
	return r
}

func (r ApiStagesAuthenticatorWebauthnListRequest) ConfigureFlow(configureFlow string) ApiStagesAuthenticatorWebauthnListRequest {
	r.configureFlow = &configureFlow
	return r
}

func (r ApiStagesAuthenticatorWebauthnListRequest) DeviceTypeRestrictions(deviceTypeRestrictions []string) ApiStagesAuthenticatorWebauthnListRequest {
	r.deviceTypeRestrictions = &deviceTypeRestrictions
	return r
}

func (r ApiStagesAuthenticatorWebauthnListRequest) FriendlyName(friendlyName string) ApiStagesAuthenticatorWebauthnListRequest {
	r.friendlyName = &friendlyName
	return r
}

func (r ApiStagesAuthenticatorWebauthnListRequest) MaxAttempts(maxAttempts int32) ApiStagesAuthenticatorWebauthnListRequest {
	r.maxAttempts = &maxAttempts
	return r
}

func (r ApiStagesAuthenticatorWebauthnListRequest) Name(name string) ApiStagesAuthenticatorWebauthnListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiStagesAuthenticatorWebauthnListRequest) Ordering(ordering string) ApiStagesAuthenticatorWebauthnListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiStagesAuthenticatorWebauthnListRequest) Page(page int32) ApiStagesAuthenticatorWebauthnListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiStagesAuthenticatorWebauthnListRequest) PageSize(pageSize int32) ApiStagesAuthenticatorWebauthnListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiStagesAuthenticatorWebauthnListRequest) ResidentKeyRequirement(residentKeyRequirement string) ApiStagesAuthenticatorWebauthnListRequest {
	r.residentKeyRequirement = &residentKeyRequirement
	return r
}

// A search term.
func (r ApiStagesAuthenticatorWebauthnListRequest) Search(search string) ApiStagesAuthenticatorWebauthnListRequest {
	r.search = &search
	return r
}

func (r ApiStagesAuthenticatorWebauthnListRequest) StageUuid(stageUuid string) ApiStagesAuthenticatorWebauthnListRequest {
	r.stageUuid = &stageUuid
	return r
}

func (r ApiStagesAuthenticatorWebauthnListRequest) UserVerification(userVerification string) ApiStagesAuthenticatorWebauthnListRequest {
	r.userVerification = &userVerification
	return r
}

func (r ApiStagesAuthenticatorWebauthnListRequest) Execute() (*PaginatedAuthenticatorWebAuthnStageList, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorWebauthnListExecute(r)
}

/*
StagesAuthenticatorWebauthnList Method for StagesAuthenticatorWebauthnList

AuthenticatorWebAuthnStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesAuthenticatorWebauthnListRequest
*/
func (a *StagesAPIService) StagesAuthenticatorWebauthnList(ctx context.Context) ApiStagesAuthenticatorWebauthnListRequest {
	return ApiStagesAuthenticatorWebauthnListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedAuthenticatorWebAuthnStageList
func (a *StagesAPIService) StagesAuthenticatorWebauthnListExecute(r ApiStagesAuthenticatorWebauthnListRequest) (*PaginatedAuthenticatorWebAuthnStageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedAuthenticatorWebAuthnStageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorWebauthnList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/webauthn/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.authenticatorAttachment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authenticator_attachment", r.authenticatorAttachment, "form", "")
	}
	if r.configureFlow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "configure_flow", r.configureFlow, "form", "")
	}
	if r.deviceTypeRestrictions != nil {
		t := *r.deviceTypeRestrictions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_type_restrictions", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_type_restrictions", t, "form", "multi")
		}
	}
	if r.friendlyName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "friendly_name", r.friendlyName, "form", "")
	}
	if r.maxAttempts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_attempts", r.maxAttempts, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.residentKeyRequirement != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resident_key_requirement", r.residentKeyRequirement, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.stageUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stage_uuid", r.stageUuid, "form", "")
	}
	if r.userVerification != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_verification", r.userVerification, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorWebauthnPartialUpdateRequest struct {
	ctx                                      context.Context
	ApiService                               *StagesAPIService
	stageUuid                                string
	patchedAuthenticatorWebAuthnStageRequest *PatchedAuthenticatorWebAuthnStageRequest
}

func (r ApiStagesAuthenticatorWebauthnPartialUpdateRequest) PatchedAuthenticatorWebAuthnStageRequest(patchedAuthenticatorWebAuthnStageRequest PatchedAuthenticatorWebAuthnStageRequest) ApiStagesAuthenticatorWebauthnPartialUpdateRequest {
	r.patchedAuthenticatorWebAuthnStageRequest = &patchedAuthenticatorWebAuthnStageRequest
	return r
}

func (r ApiStagesAuthenticatorWebauthnPartialUpdateRequest) Execute() (*AuthenticatorWebAuthnStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorWebauthnPartialUpdateExecute(r)
}

/*
StagesAuthenticatorWebauthnPartialUpdate Method for StagesAuthenticatorWebauthnPartialUpdate

AuthenticatorWebAuthnStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this WebAuthn Authenticator Setup Stage.
	@return ApiStagesAuthenticatorWebauthnPartialUpdateRequest
*/
func (a *StagesAPIService) StagesAuthenticatorWebauthnPartialUpdate(ctx context.Context, stageUuid string) ApiStagesAuthenticatorWebauthnPartialUpdateRequest {
	return ApiStagesAuthenticatorWebauthnPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return AuthenticatorWebAuthnStage
func (a *StagesAPIService) StagesAuthenticatorWebauthnPartialUpdateExecute(r ApiStagesAuthenticatorWebauthnPartialUpdateRequest) (*AuthenticatorWebAuthnStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorWebAuthnStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorWebauthnPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/webauthn/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedAuthenticatorWebAuthnStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorWebauthnRetrieveRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesAuthenticatorWebauthnRetrieveRequest) Execute() (*AuthenticatorWebAuthnStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorWebauthnRetrieveExecute(r)
}

/*
StagesAuthenticatorWebauthnRetrieve Method for StagesAuthenticatorWebauthnRetrieve

AuthenticatorWebAuthnStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this WebAuthn Authenticator Setup Stage.
	@return ApiStagesAuthenticatorWebauthnRetrieveRequest
*/
func (a *StagesAPIService) StagesAuthenticatorWebauthnRetrieve(ctx context.Context, stageUuid string) ApiStagesAuthenticatorWebauthnRetrieveRequest {
	return ApiStagesAuthenticatorWebauthnRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return AuthenticatorWebAuthnStage
func (a *StagesAPIService) StagesAuthenticatorWebauthnRetrieveExecute(r ApiStagesAuthenticatorWebauthnRetrieveRequest) (*AuthenticatorWebAuthnStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorWebAuthnStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorWebauthnRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/webauthn/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorWebauthnUpdateRequest struct {
	ctx                               context.Context
	ApiService                        *StagesAPIService
	stageUuid                         string
	authenticatorWebAuthnStageRequest *AuthenticatorWebAuthnStageRequest
}

func (r ApiStagesAuthenticatorWebauthnUpdateRequest) AuthenticatorWebAuthnStageRequest(authenticatorWebAuthnStageRequest AuthenticatorWebAuthnStageRequest) ApiStagesAuthenticatorWebauthnUpdateRequest {
	r.authenticatorWebAuthnStageRequest = &authenticatorWebAuthnStageRequest
	return r
}

func (r ApiStagesAuthenticatorWebauthnUpdateRequest) Execute() (*AuthenticatorWebAuthnStage, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorWebauthnUpdateExecute(r)
}

/*
StagesAuthenticatorWebauthnUpdate Method for StagesAuthenticatorWebauthnUpdate

AuthenticatorWebAuthnStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this WebAuthn Authenticator Setup Stage.
	@return ApiStagesAuthenticatorWebauthnUpdateRequest
*/
func (a *StagesAPIService) StagesAuthenticatorWebauthnUpdate(ctx context.Context, stageUuid string) ApiStagesAuthenticatorWebauthnUpdateRequest {
	return ApiStagesAuthenticatorWebauthnUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return AuthenticatorWebAuthnStage
func (a *StagesAPIService) StagesAuthenticatorWebauthnUpdateExecute(r ApiStagesAuthenticatorWebauthnUpdateRequest) (*AuthenticatorWebAuthnStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticatorWebAuthnStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorWebauthnUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/webauthn/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authenticatorWebAuthnStageRequest == nil {
		return localVarReturnValue, nil, reportError("authenticatorWebAuthnStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticatorWebAuthnStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesAuthenticatorWebauthnUsedByListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesAuthenticatorWebauthnUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.StagesAuthenticatorWebauthnUsedByListExecute(r)
}

/*
StagesAuthenticatorWebauthnUsedByList Method for StagesAuthenticatorWebauthnUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this WebAuthn Authenticator Setup Stage.
	@return ApiStagesAuthenticatorWebauthnUsedByListRequest
*/
func (a *StagesAPIService) StagesAuthenticatorWebauthnUsedByList(ctx context.Context, stageUuid string) ApiStagesAuthenticatorWebauthnUsedByListRequest {
	return ApiStagesAuthenticatorWebauthnUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *StagesAPIService) StagesAuthenticatorWebauthnUsedByListExecute(r ApiStagesAuthenticatorWebauthnUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesAuthenticatorWebauthnUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/authenticator/webauthn/{stage_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesCaptchaCreateRequest struct {
	ctx                 context.Context
	ApiService          *StagesAPIService
	captchaStageRequest *CaptchaStageRequest
}

func (r ApiStagesCaptchaCreateRequest) CaptchaStageRequest(captchaStageRequest CaptchaStageRequest) ApiStagesCaptchaCreateRequest {
	r.captchaStageRequest = &captchaStageRequest
	return r
}

func (r ApiStagesCaptchaCreateRequest) Execute() (*CaptchaStage, *http.Response, error) {
	return r.ApiService.StagesCaptchaCreateExecute(r)
}

/*
StagesCaptchaCreate Method for StagesCaptchaCreate

CaptchaStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesCaptchaCreateRequest
*/
func (a *StagesAPIService) StagesCaptchaCreate(ctx context.Context) ApiStagesCaptchaCreateRequest {
	return ApiStagesCaptchaCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CaptchaStage
func (a *StagesAPIService) StagesCaptchaCreateExecute(r ApiStagesCaptchaCreateRequest) (*CaptchaStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CaptchaStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesCaptchaCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/captcha/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.captchaStageRequest == nil {
		return localVarReturnValue, nil, reportError("captchaStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.captchaStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesCaptchaDestroyRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesCaptchaDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.StagesCaptchaDestroyExecute(r)
}

/*
StagesCaptchaDestroy Method for StagesCaptchaDestroy

CaptchaStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Captcha Stage.
	@return ApiStagesCaptchaDestroyRequest
*/
func (a *StagesAPIService) StagesCaptchaDestroy(ctx context.Context, stageUuid string) ApiStagesCaptchaDestroyRequest {
	return ApiStagesCaptchaDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
func (a *StagesAPIService) StagesCaptchaDestroyExecute(r ApiStagesCaptchaDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesCaptchaDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/captcha/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStagesCaptchaListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	name       *string
	ordering   *string
	page       *int32
	pageSize   *int32
	publicKey  *string
	search     *string
}

func (r ApiStagesCaptchaListRequest) Name(name string) ApiStagesCaptchaListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiStagesCaptchaListRequest) Ordering(ordering string) ApiStagesCaptchaListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiStagesCaptchaListRequest) Page(page int32) ApiStagesCaptchaListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiStagesCaptchaListRequest) PageSize(pageSize int32) ApiStagesCaptchaListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiStagesCaptchaListRequest) PublicKey(publicKey string) ApiStagesCaptchaListRequest {
	r.publicKey = &publicKey
	return r
}

// A search term.
func (r ApiStagesCaptchaListRequest) Search(search string) ApiStagesCaptchaListRequest {
	r.search = &search
	return r
}

func (r ApiStagesCaptchaListRequest) Execute() (*PaginatedCaptchaStageList, *http.Response, error) {
	return r.ApiService.StagesCaptchaListExecute(r)
}

/*
StagesCaptchaList Method for StagesCaptchaList

CaptchaStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesCaptchaListRequest
*/
func (a *StagesAPIService) StagesCaptchaList(ctx context.Context) ApiStagesCaptchaListRequest {
	return ApiStagesCaptchaListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedCaptchaStageList
func (a *StagesAPIService) StagesCaptchaListExecute(r ApiStagesCaptchaListRequest) (*PaginatedCaptchaStageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedCaptchaStageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesCaptchaList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/captcha/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.publicKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "public_key", r.publicKey, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesCaptchaPartialUpdateRequest struct {
	ctx                        context.Context
	ApiService                 *StagesAPIService
	stageUuid                  string
	patchedCaptchaStageRequest *PatchedCaptchaStageRequest
}

func (r ApiStagesCaptchaPartialUpdateRequest) PatchedCaptchaStageRequest(patchedCaptchaStageRequest PatchedCaptchaStageRequest) ApiStagesCaptchaPartialUpdateRequest {
	r.patchedCaptchaStageRequest = &patchedCaptchaStageRequest
	return r
}

func (r ApiStagesCaptchaPartialUpdateRequest) Execute() (*CaptchaStage, *http.Response, error) {
	return r.ApiService.StagesCaptchaPartialUpdateExecute(r)
}

/*
StagesCaptchaPartialUpdate Method for StagesCaptchaPartialUpdate

CaptchaStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Captcha Stage.
	@return ApiStagesCaptchaPartialUpdateRequest
*/
func (a *StagesAPIService) StagesCaptchaPartialUpdate(ctx context.Context, stageUuid string) ApiStagesCaptchaPartialUpdateRequest {
	return ApiStagesCaptchaPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return CaptchaStage
func (a *StagesAPIService) StagesCaptchaPartialUpdateExecute(r ApiStagesCaptchaPartialUpdateRequest) (*CaptchaStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CaptchaStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesCaptchaPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/captcha/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedCaptchaStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesCaptchaRetrieveRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesCaptchaRetrieveRequest) Execute() (*CaptchaStage, *http.Response, error) {
	return r.ApiService.StagesCaptchaRetrieveExecute(r)
}

/*
StagesCaptchaRetrieve Method for StagesCaptchaRetrieve

CaptchaStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Captcha Stage.
	@return ApiStagesCaptchaRetrieveRequest
*/
func (a *StagesAPIService) StagesCaptchaRetrieve(ctx context.Context, stageUuid string) ApiStagesCaptchaRetrieveRequest {
	return ApiStagesCaptchaRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return CaptchaStage
func (a *StagesAPIService) StagesCaptchaRetrieveExecute(r ApiStagesCaptchaRetrieveRequest) (*CaptchaStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CaptchaStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesCaptchaRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/captcha/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesCaptchaUpdateRequest struct {
	ctx                 context.Context
	ApiService          *StagesAPIService
	stageUuid           string
	captchaStageRequest *CaptchaStageRequest
}

func (r ApiStagesCaptchaUpdateRequest) CaptchaStageRequest(captchaStageRequest CaptchaStageRequest) ApiStagesCaptchaUpdateRequest {
	r.captchaStageRequest = &captchaStageRequest
	return r
}

func (r ApiStagesCaptchaUpdateRequest) Execute() (*CaptchaStage, *http.Response, error) {
	return r.ApiService.StagesCaptchaUpdateExecute(r)
}

/*
StagesCaptchaUpdate Method for StagesCaptchaUpdate

CaptchaStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Captcha Stage.
	@return ApiStagesCaptchaUpdateRequest
*/
func (a *StagesAPIService) StagesCaptchaUpdate(ctx context.Context, stageUuid string) ApiStagesCaptchaUpdateRequest {
	return ApiStagesCaptchaUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return CaptchaStage
func (a *StagesAPIService) StagesCaptchaUpdateExecute(r ApiStagesCaptchaUpdateRequest) (*CaptchaStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CaptchaStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesCaptchaUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/captcha/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.captchaStageRequest == nil {
		return localVarReturnValue, nil, reportError("captchaStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.captchaStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesCaptchaUsedByListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesCaptchaUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.StagesCaptchaUsedByListExecute(r)
}

/*
StagesCaptchaUsedByList Method for StagesCaptchaUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Captcha Stage.
	@return ApiStagesCaptchaUsedByListRequest
*/
func (a *StagesAPIService) StagesCaptchaUsedByList(ctx context.Context, stageUuid string) ApiStagesCaptchaUsedByListRequest {
	return ApiStagesCaptchaUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *StagesAPIService) StagesCaptchaUsedByListExecute(r ApiStagesCaptchaUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesCaptchaUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/captcha/{stage_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesConsentCreateRequest struct {
	ctx                 context.Context
	ApiService          *StagesAPIService
	consentStageRequest *ConsentStageRequest
}

func (r ApiStagesConsentCreateRequest) ConsentStageRequest(consentStageRequest ConsentStageRequest) ApiStagesConsentCreateRequest {
	r.consentStageRequest = &consentStageRequest
	return r
}

func (r ApiStagesConsentCreateRequest) Execute() (*ConsentStage, *http.Response, error) {
	return r.ApiService.StagesConsentCreateExecute(r)
}

/*
StagesConsentCreate Method for StagesConsentCreate

ConsentStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesConsentCreateRequest
*/
func (a *StagesAPIService) StagesConsentCreate(ctx context.Context) ApiStagesConsentCreateRequest {
	return ApiStagesConsentCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ConsentStage
func (a *StagesAPIService) StagesConsentCreateExecute(r ApiStagesConsentCreateRequest) (*ConsentStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ConsentStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesConsentCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/consent/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.consentStageRequest == nil {
		return localVarReturnValue, nil, reportError("consentStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.consentStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesConsentDestroyRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesConsentDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.StagesConsentDestroyExecute(r)
}

/*
StagesConsentDestroy Method for StagesConsentDestroy

ConsentStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Consent Stage.
	@return ApiStagesConsentDestroyRequest
*/
func (a *StagesAPIService) StagesConsentDestroy(ctx context.Context, stageUuid string) ApiStagesConsentDestroyRequest {
	return ApiStagesConsentDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
func (a *StagesAPIService) StagesConsentDestroyExecute(r ApiStagesConsentDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesConsentDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/consent/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStagesConsentListRequest struct {
	ctx             context.Context
	ApiService      *StagesAPIService
	consentExpireIn *string
	mode            *string
	name            *string
	ordering        *string
	page            *int32
	pageSize        *int32
	search          *string
	stageUuid       *string
}

func (r ApiStagesConsentListRequest) ConsentExpireIn(consentExpireIn string) ApiStagesConsentListRequest {
	r.consentExpireIn = &consentExpireIn
	return r
}

func (r ApiStagesConsentListRequest) Mode(mode string) ApiStagesConsentListRequest {
	r.mode = &mode
	return r
}

func (r ApiStagesConsentListRequest) Name(name string) ApiStagesConsentListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiStagesConsentListRequest) Ordering(ordering string) ApiStagesConsentListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiStagesConsentListRequest) Page(page int32) ApiStagesConsentListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiStagesConsentListRequest) PageSize(pageSize int32) ApiStagesConsentListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiStagesConsentListRequest) Search(search string) ApiStagesConsentListRequest {
	r.search = &search
	return r
}

func (r ApiStagesConsentListRequest) StageUuid(stageUuid string) ApiStagesConsentListRequest {
	r.stageUuid = &stageUuid
	return r
}

func (r ApiStagesConsentListRequest) Execute() (*PaginatedConsentStageList, *http.Response, error) {
	return r.ApiService.StagesConsentListExecute(r)
}

/*
StagesConsentList Method for StagesConsentList

ConsentStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesConsentListRequest
*/
func (a *StagesAPIService) StagesConsentList(ctx context.Context) ApiStagesConsentListRequest {
	return ApiStagesConsentListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedConsentStageList
func (a *StagesAPIService) StagesConsentListExecute(r ApiStagesConsentListRequest) (*PaginatedConsentStageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedConsentStageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesConsentList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/consent/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.consentExpireIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "consent_expire_in", r.consentExpireIn, "form", "")
	}
	if r.mode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mode", r.mode, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.stageUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stage_uuid", r.stageUuid, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesConsentPartialUpdateRequest struct {
	ctx                        context.Context
	ApiService                 *StagesAPIService
	stageUuid                  string
	patchedConsentStageRequest *PatchedConsentStageRequest
}

func (r ApiStagesConsentPartialUpdateRequest) PatchedConsentStageRequest(patchedConsentStageRequest PatchedConsentStageRequest) ApiStagesConsentPartialUpdateRequest {
	r.patchedConsentStageRequest = &patchedConsentStageRequest
	return r
}

func (r ApiStagesConsentPartialUpdateRequest) Execute() (*ConsentStage, *http.Response, error) {
	return r.ApiService.StagesConsentPartialUpdateExecute(r)
}

/*
StagesConsentPartialUpdate Method for StagesConsentPartialUpdate

ConsentStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Consent Stage.
	@return ApiStagesConsentPartialUpdateRequest
*/
func (a *StagesAPIService) StagesConsentPartialUpdate(ctx context.Context, stageUuid string) ApiStagesConsentPartialUpdateRequest {
	return ApiStagesConsentPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return ConsentStage
func (a *StagesAPIService) StagesConsentPartialUpdateExecute(r ApiStagesConsentPartialUpdateRequest) (*ConsentStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ConsentStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesConsentPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/consent/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedConsentStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesConsentRetrieveRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesConsentRetrieveRequest) Execute() (*ConsentStage, *http.Response, error) {
	return r.ApiService.StagesConsentRetrieveExecute(r)
}

/*
StagesConsentRetrieve Method for StagesConsentRetrieve

ConsentStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Consent Stage.
	@return ApiStagesConsentRetrieveRequest
*/
func (a *StagesAPIService) StagesConsentRetrieve(ctx context.Context, stageUuid string) ApiStagesConsentRetrieveRequest {
	return ApiStagesConsentRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return ConsentStage
func (a *StagesAPIService) StagesConsentRetrieveExecute(r ApiStagesConsentRetrieveRequest) (*ConsentStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ConsentStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesConsentRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/consent/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesConsentUpdateRequest struct {
	ctx                 context.Context
	ApiService          *StagesAPIService
	stageUuid           string
	consentStageRequest *ConsentStageRequest
}

func (r ApiStagesConsentUpdateRequest) ConsentStageRequest(consentStageRequest ConsentStageRequest) ApiStagesConsentUpdateRequest {
	r.consentStageRequest = &consentStageRequest
	return r
}

func (r ApiStagesConsentUpdateRequest) Execute() (*ConsentStage, *http.Response, error) {
	return r.ApiService.StagesConsentUpdateExecute(r)
}

/*
StagesConsentUpdate Method for StagesConsentUpdate

ConsentStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Consent Stage.
	@return ApiStagesConsentUpdateRequest
*/
func (a *StagesAPIService) StagesConsentUpdate(ctx context.Context, stageUuid string) ApiStagesConsentUpdateRequest {
	return ApiStagesConsentUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return ConsentStage
func (a *StagesAPIService) StagesConsentUpdateExecute(r ApiStagesConsentUpdateRequest) (*ConsentStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ConsentStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesConsentUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/consent/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.consentStageRequest == nil {
		return localVarReturnValue, nil, reportError("consentStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.consentStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesConsentUsedByListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesConsentUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.StagesConsentUsedByListExecute(r)
}

/*
StagesConsentUsedByList Method for StagesConsentUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Consent Stage.
	@return ApiStagesConsentUsedByListRequest
*/
func (a *StagesAPIService) StagesConsentUsedByList(ctx context.Context, stageUuid string) ApiStagesConsentUsedByListRequest {
	return ApiStagesConsentUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *StagesAPIService) StagesConsentUsedByListExecute(r ApiStagesConsentUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesConsentUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/consent/{stage_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesDenyCreateRequest struct {
	ctx              context.Context
	ApiService       *StagesAPIService
	denyStageRequest *DenyStageRequest
}

func (r ApiStagesDenyCreateRequest) DenyStageRequest(denyStageRequest DenyStageRequest) ApiStagesDenyCreateRequest {
	r.denyStageRequest = &denyStageRequest
	return r
}

func (r ApiStagesDenyCreateRequest) Execute() (*DenyStage, *http.Response, error) {
	return r.ApiService.StagesDenyCreateExecute(r)
}

/*
StagesDenyCreate Method for StagesDenyCreate

DenyStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesDenyCreateRequest
*/
func (a *StagesAPIService) StagesDenyCreate(ctx context.Context) ApiStagesDenyCreateRequest {
	return ApiStagesDenyCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DenyStage
func (a *StagesAPIService) StagesDenyCreateExecute(r ApiStagesDenyCreateRequest) (*DenyStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DenyStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesDenyCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/deny/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.denyStageRequest == nil {
		return localVarReturnValue, nil, reportError("denyStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.denyStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesDenyDestroyRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesDenyDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.StagesDenyDestroyExecute(r)
}

/*
StagesDenyDestroy Method for StagesDenyDestroy

DenyStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Deny Stage.
	@return ApiStagesDenyDestroyRequest
*/
func (a *StagesAPIService) StagesDenyDestroy(ctx context.Context, stageUuid string) ApiStagesDenyDestroyRequest {
	return ApiStagesDenyDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
func (a *StagesAPIService) StagesDenyDestroyExecute(r ApiStagesDenyDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesDenyDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/deny/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStagesDenyListRequest struct {
	ctx         context.Context
	ApiService  *StagesAPIService
	denyMessage *string
	name        *string
	ordering    *string
	page        *int32
	pageSize    *int32
	search      *string
	stageUuid   *string
}

func (r ApiStagesDenyListRequest) DenyMessage(denyMessage string) ApiStagesDenyListRequest {
	r.denyMessage = &denyMessage
	return r
}

func (r ApiStagesDenyListRequest) Name(name string) ApiStagesDenyListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiStagesDenyListRequest) Ordering(ordering string) ApiStagesDenyListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiStagesDenyListRequest) Page(page int32) ApiStagesDenyListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiStagesDenyListRequest) PageSize(pageSize int32) ApiStagesDenyListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiStagesDenyListRequest) Search(search string) ApiStagesDenyListRequest {
	r.search = &search
	return r
}

func (r ApiStagesDenyListRequest) StageUuid(stageUuid string) ApiStagesDenyListRequest {
	r.stageUuid = &stageUuid
	return r
}

func (r ApiStagesDenyListRequest) Execute() (*PaginatedDenyStageList, *http.Response, error) {
	return r.ApiService.StagesDenyListExecute(r)
}

/*
StagesDenyList Method for StagesDenyList

DenyStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesDenyListRequest
*/
func (a *StagesAPIService) StagesDenyList(ctx context.Context) ApiStagesDenyListRequest {
	return ApiStagesDenyListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedDenyStageList
func (a *StagesAPIService) StagesDenyListExecute(r ApiStagesDenyListRequest) (*PaginatedDenyStageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedDenyStageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesDenyList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/deny/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.denyMessage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deny_message", r.denyMessage, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.stageUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stage_uuid", r.stageUuid, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesDenyPartialUpdateRequest struct {
	ctx                     context.Context
	ApiService              *StagesAPIService
	stageUuid               string
	patchedDenyStageRequest *PatchedDenyStageRequest
}

func (r ApiStagesDenyPartialUpdateRequest) PatchedDenyStageRequest(patchedDenyStageRequest PatchedDenyStageRequest) ApiStagesDenyPartialUpdateRequest {
	r.patchedDenyStageRequest = &patchedDenyStageRequest
	return r
}

func (r ApiStagesDenyPartialUpdateRequest) Execute() (*DenyStage, *http.Response, error) {
	return r.ApiService.StagesDenyPartialUpdateExecute(r)
}

/*
StagesDenyPartialUpdate Method for StagesDenyPartialUpdate

DenyStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Deny Stage.
	@return ApiStagesDenyPartialUpdateRequest
*/
func (a *StagesAPIService) StagesDenyPartialUpdate(ctx context.Context, stageUuid string) ApiStagesDenyPartialUpdateRequest {
	return ApiStagesDenyPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return DenyStage
func (a *StagesAPIService) StagesDenyPartialUpdateExecute(r ApiStagesDenyPartialUpdateRequest) (*DenyStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DenyStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesDenyPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/deny/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedDenyStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesDenyRetrieveRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesDenyRetrieveRequest) Execute() (*DenyStage, *http.Response, error) {
	return r.ApiService.StagesDenyRetrieveExecute(r)
}

/*
StagesDenyRetrieve Method for StagesDenyRetrieve

DenyStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Deny Stage.
	@return ApiStagesDenyRetrieveRequest
*/
func (a *StagesAPIService) StagesDenyRetrieve(ctx context.Context, stageUuid string) ApiStagesDenyRetrieveRequest {
	return ApiStagesDenyRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return DenyStage
func (a *StagesAPIService) StagesDenyRetrieveExecute(r ApiStagesDenyRetrieveRequest) (*DenyStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DenyStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesDenyRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/deny/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesDenyUpdateRequest struct {
	ctx              context.Context
	ApiService       *StagesAPIService
	stageUuid        string
	denyStageRequest *DenyStageRequest
}

func (r ApiStagesDenyUpdateRequest) DenyStageRequest(denyStageRequest DenyStageRequest) ApiStagesDenyUpdateRequest {
	r.denyStageRequest = &denyStageRequest
	return r
}

func (r ApiStagesDenyUpdateRequest) Execute() (*DenyStage, *http.Response, error) {
	return r.ApiService.StagesDenyUpdateExecute(r)
}

/*
StagesDenyUpdate Method for StagesDenyUpdate

DenyStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Deny Stage.
	@return ApiStagesDenyUpdateRequest
*/
func (a *StagesAPIService) StagesDenyUpdate(ctx context.Context, stageUuid string) ApiStagesDenyUpdateRequest {
	return ApiStagesDenyUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return DenyStage
func (a *StagesAPIService) StagesDenyUpdateExecute(r ApiStagesDenyUpdateRequest) (*DenyStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DenyStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesDenyUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/deny/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.denyStageRequest == nil {
		return localVarReturnValue, nil, reportError("denyStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.denyStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesDenyUsedByListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesDenyUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.StagesDenyUsedByListExecute(r)
}

/*
StagesDenyUsedByList Method for StagesDenyUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Deny Stage.
	@return ApiStagesDenyUsedByListRequest
*/
func (a *StagesAPIService) StagesDenyUsedByList(ctx context.Context, stageUuid string) ApiStagesDenyUsedByListRequest {
	return ApiStagesDenyUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *StagesAPIService) StagesDenyUsedByListExecute(r ApiStagesDenyUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesDenyUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/deny/{stage_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesDummyCreateRequest struct {
	ctx               context.Context
	ApiService        *StagesAPIService
	dummyStageRequest *DummyStageRequest
}

func (r ApiStagesDummyCreateRequest) DummyStageRequest(dummyStageRequest DummyStageRequest) ApiStagesDummyCreateRequest {
	r.dummyStageRequest = &dummyStageRequest
	return r
}

func (r ApiStagesDummyCreateRequest) Execute() (*DummyStage, *http.Response, error) {
	return r.ApiService.StagesDummyCreateExecute(r)
}

/*
StagesDummyCreate Method for StagesDummyCreate

DummyStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesDummyCreateRequest
*/
func (a *StagesAPIService) StagesDummyCreate(ctx context.Context) ApiStagesDummyCreateRequest {
	return ApiStagesDummyCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DummyStage
func (a *StagesAPIService) StagesDummyCreateExecute(r ApiStagesDummyCreateRequest) (*DummyStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DummyStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesDummyCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/dummy/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dummyStageRequest == nil {
		return localVarReturnValue, nil, reportError("dummyStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dummyStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesDummyDestroyRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesDummyDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.StagesDummyDestroyExecute(r)
}

/*
StagesDummyDestroy Method for StagesDummyDestroy

DummyStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Dummy Stage.
	@return ApiStagesDummyDestroyRequest
*/
func (a *StagesAPIService) StagesDummyDestroy(ctx context.Context, stageUuid string) ApiStagesDummyDestroyRequest {
	return ApiStagesDummyDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
func (a *StagesAPIService) StagesDummyDestroyExecute(r ApiStagesDummyDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesDummyDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/dummy/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStagesDummyListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	name       *string
	ordering   *string
	page       *int32
	pageSize   *int32
	search     *string
	stageUuid  *string
	throwError *bool
}

func (r ApiStagesDummyListRequest) Name(name string) ApiStagesDummyListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiStagesDummyListRequest) Ordering(ordering string) ApiStagesDummyListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiStagesDummyListRequest) Page(page int32) ApiStagesDummyListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiStagesDummyListRequest) PageSize(pageSize int32) ApiStagesDummyListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiStagesDummyListRequest) Search(search string) ApiStagesDummyListRequest {
	r.search = &search
	return r
}

func (r ApiStagesDummyListRequest) StageUuid(stageUuid string) ApiStagesDummyListRequest {
	r.stageUuid = &stageUuid
	return r
}

func (r ApiStagesDummyListRequest) ThrowError(throwError bool) ApiStagesDummyListRequest {
	r.throwError = &throwError
	return r
}

func (r ApiStagesDummyListRequest) Execute() (*PaginatedDummyStageList, *http.Response, error) {
	return r.ApiService.StagesDummyListExecute(r)
}

/*
StagesDummyList Method for StagesDummyList

DummyStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesDummyListRequest
*/
func (a *StagesAPIService) StagesDummyList(ctx context.Context) ApiStagesDummyListRequest {
	return ApiStagesDummyListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedDummyStageList
func (a *StagesAPIService) StagesDummyListExecute(r ApiStagesDummyListRequest) (*PaginatedDummyStageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedDummyStageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesDummyList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/dummy/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.stageUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stage_uuid", r.stageUuid, "form", "")
	}
	if r.throwError != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "throw_error", r.throwError, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesDummyPartialUpdateRequest struct {
	ctx                      context.Context
	ApiService               *StagesAPIService
	stageUuid                string
	patchedDummyStageRequest *PatchedDummyStageRequest
}

func (r ApiStagesDummyPartialUpdateRequest) PatchedDummyStageRequest(patchedDummyStageRequest PatchedDummyStageRequest) ApiStagesDummyPartialUpdateRequest {
	r.patchedDummyStageRequest = &patchedDummyStageRequest
	return r
}

func (r ApiStagesDummyPartialUpdateRequest) Execute() (*DummyStage, *http.Response, error) {
	return r.ApiService.StagesDummyPartialUpdateExecute(r)
}

/*
StagesDummyPartialUpdate Method for StagesDummyPartialUpdate

DummyStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Dummy Stage.
	@return ApiStagesDummyPartialUpdateRequest
*/
func (a *StagesAPIService) StagesDummyPartialUpdate(ctx context.Context, stageUuid string) ApiStagesDummyPartialUpdateRequest {
	return ApiStagesDummyPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return DummyStage
func (a *StagesAPIService) StagesDummyPartialUpdateExecute(r ApiStagesDummyPartialUpdateRequest) (*DummyStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DummyStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesDummyPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/dummy/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedDummyStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesDummyRetrieveRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesDummyRetrieveRequest) Execute() (*DummyStage, *http.Response, error) {
	return r.ApiService.StagesDummyRetrieveExecute(r)
}

/*
StagesDummyRetrieve Method for StagesDummyRetrieve

DummyStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Dummy Stage.
	@return ApiStagesDummyRetrieveRequest
*/
func (a *StagesAPIService) StagesDummyRetrieve(ctx context.Context, stageUuid string) ApiStagesDummyRetrieveRequest {
	return ApiStagesDummyRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return DummyStage
func (a *StagesAPIService) StagesDummyRetrieveExecute(r ApiStagesDummyRetrieveRequest) (*DummyStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DummyStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesDummyRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/dummy/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesDummyUpdateRequest struct {
	ctx               context.Context
	ApiService        *StagesAPIService
	stageUuid         string
	dummyStageRequest *DummyStageRequest
}

func (r ApiStagesDummyUpdateRequest) DummyStageRequest(dummyStageRequest DummyStageRequest) ApiStagesDummyUpdateRequest {
	r.dummyStageRequest = &dummyStageRequest
	return r
}

func (r ApiStagesDummyUpdateRequest) Execute() (*DummyStage, *http.Response, error) {
	return r.ApiService.StagesDummyUpdateExecute(r)
}

/*
StagesDummyUpdate Method for StagesDummyUpdate

DummyStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Dummy Stage.
	@return ApiStagesDummyUpdateRequest
*/
func (a *StagesAPIService) StagesDummyUpdate(ctx context.Context, stageUuid string) ApiStagesDummyUpdateRequest {
	return ApiStagesDummyUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return DummyStage
func (a *StagesAPIService) StagesDummyUpdateExecute(r ApiStagesDummyUpdateRequest) (*DummyStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DummyStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesDummyUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/dummy/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dummyStageRequest == nil {
		return localVarReturnValue, nil, reportError("dummyStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dummyStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesDummyUsedByListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesDummyUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.StagesDummyUsedByListExecute(r)
}

/*
StagesDummyUsedByList Method for StagesDummyUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Dummy Stage.
	@return ApiStagesDummyUsedByListRequest
*/
func (a *StagesAPIService) StagesDummyUsedByList(ctx context.Context, stageUuid string) ApiStagesDummyUsedByListRequest {
	return ApiStagesDummyUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *StagesAPIService) StagesDummyUsedByListExecute(r ApiStagesDummyUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesDummyUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/dummy/{stage_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesEmailCreateRequest struct {
	ctx               context.Context
	ApiService        *StagesAPIService
	emailStageRequest *EmailStageRequest
}

func (r ApiStagesEmailCreateRequest) EmailStageRequest(emailStageRequest EmailStageRequest) ApiStagesEmailCreateRequest {
	r.emailStageRequest = &emailStageRequest
	return r
}

func (r ApiStagesEmailCreateRequest) Execute() (*EmailStage, *http.Response, error) {
	return r.ApiService.StagesEmailCreateExecute(r)
}

/*
StagesEmailCreate Method for StagesEmailCreate

EmailStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesEmailCreateRequest
*/
func (a *StagesAPIService) StagesEmailCreate(ctx context.Context) ApiStagesEmailCreateRequest {
	return ApiStagesEmailCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return EmailStage
func (a *StagesAPIService) StagesEmailCreateExecute(r ApiStagesEmailCreateRequest) (*EmailStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EmailStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesEmailCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/email/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.emailStageRequest == nil {
		return localVarReturnValue, nil, reportError("emailStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.emailStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesEmailDestroyRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesEmailDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.StagesEmailDestroyExecute(r)
}

/*
StagesEmailDestroy Method for StagesEmailDestroy

EmailStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Email Stage.
	@return ApiStagesEmailDestroyRequest
*/
func (a *StagesAPIService) StagesEmailDestroy(ctx context.Context, stageUuid string) ApiStagesEmailDestroyRequest {
	return ApiStagesEmailDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
func (a *StagesAPIService) StagesEmailDestroyExecute(r ApiStagesEmailDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesEmailDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/email/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStagesEmailListRequest struct {
	ctx                   context.Context
	ApiService            *StagesAPIService
	activateUserOnSuccess *bool
	fromAddress           *string
	host                  *string
	name                  *string
	ordering              *string
	page                  *int32
	pageSize              *int32
	port                  *int32
	search                *string
	subject               *string
	template              *string
	timeout               *int32
	tokenExpiry           *string
	useGlobalSettings     *bool
	useSsl                *bool
	useTls                *bool
	username              *string
}

func (r ApiStagesEmailListRequest) ActivateUserOnSuccess(activateUserOnSuccess bool) ApiStagesEmailListRequest {
	r.activateUserOnSuccess = &activateUserOnSuccess
	return r
}

func (r ApiStagesEmailListRequest) FromAddress(fromAddress string) ApiStagesEmailListRequest {
	r.fromAddress = &fromAddress
	return r
}

func (r ApiStagesEmailListRequest) Host(host string) ApiStagesEmailListRequest {
	r.host = &host
	return r
}

func (r ApiStagesEmailListRequest) Name(name string) ApiStagesEmailListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiStagesEmailListRequest) Ordering(ordering string) ApiStagesEmailListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiStagesEmailListRequest) Page(page int32) ApiStagesEmailListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiStagesEmailListRequest) PageSize(pageSize int32) ApiStagesEmailListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiStagesEmailListRequest) Port(port int32) ApiStagesEmailListRequest {
	r.port = &port
	return r
}

// A search term.
func (r ApiStagesEmailListRequest) Search(search string) ApiStagesEmailListRequest {
	r.search = &search
	return r
}

func (r ApiStagesEmailListRequest) Subject(subject string) ApiStagesEmailListRequest {
	r.subject = &subject
	return r
}

func (r ApiStagesEmailListRequest) Template(template string) ApiStagesEmailListRequest {
	r.template = &template
	return r
}

func (r ApiStagesEmailListRequest) Timeout(timeout int32) ApiStagesEmailListRequest {
	r.timeout = &timeout
	return r
}

func (r ApiStagesEmailListRequest) TokenExpiry(tokenExpiry string) ApiStagesEmailListRequest {
	r.tokenExpiry = &tokenExpiry
	return r
}

func (r ApiStagesEmailListRequest) UseGlobalSettings(useGlobalSettings bool) ApiStagesEmailListRequest {
	r.useGlobalSettings = &useGlobalSettings
	return r
}

func (r ApiStagesEmailListRequest) UseSsl(useSsl bool) ApiStagesEmailListRequest {
	r.useSsl = &useSsl
	return r
}

func (r ApiStagesEmailListRequest) UseTls(useTls bool) ApiStagesEmailListRequest {
	r.useTls = &useTls
	return r
}

func (r ApiStagesEmailListRequest) Username(username string) ApiStagesEmailListRequest {
	r.username = &username
	return r
}

func (r ApiStagesEmailListRequest) Execute() (*PaginatedEmailStageList, *http.Response, error) {
	return r.ApiService.StagesEmailListExecute(r)
}

/*
StagesEmailList Method for StagesEmailList

EmailStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesEmailListRequest
*/
func (a *StagesAPIService) StagesEmailList(ctx context.Context) ApiStagesEmailListRequest {
	return ApiStagesEmailListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedEmailStageList
func (a *StagesAPIService) StagesEmailListExecute(r ApiStagesEmailListRequest) (*PaginatedEmailStageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedEmailStageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesEmailList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/email/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.activateUserOnSuccess != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activate_user_on_success", r.activateUserOnSuccess, "form", "")
	}
	if r.fromAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_address", r.fromAddress, "form", "")
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.port != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "port", r.port, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.subject != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subject", r.subject, "form", "")
	}
	if r.template != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "template", r.template, "form", "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeout", r.timeout, "form", "")
	}
	if r.tokenExpiry != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token_expiry", r.tokenExpiry, "form", "")
	}
	if r.useGlobalSettings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "use_global_settings", r.useGlobalSettings, "form", "")
	}
	if r.useSsl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "use_ssl", r.useSsl, "form", "")
	}
	if r.useTls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "use_tls", r.useTls, "form", "")
	}
	if r.username != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "username", r.username, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesEmailPartialUpdateRequest struct {
	ctx                      context.Context
	ApiService               *StagesAPIService
	stageUuid                string
	patchedEmailStageRequest *PatchedEmailStageRequest
}

func (r ApiStagesEmailPartialUpdateRequest) PatchedEmailStageRequest(patchedEmailStageRequest PatchedEmailStageRequest) ApiStagesEmailPartialUpdateRequest {
	r.patchedEmailStageRequest = &patchedEmailStageRequest
	return r
}

func (r ApiStagesEmailPartialUpdateRequest) Execute() (*EmailStage, *http.Response, error) {
	return r.ApiService.StagesEmailPartialUpdateExecute(r)
}

/*
StagesEmailPartialUpdate Method for StagesEmailPartialUpdate

EmailStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Email Stage.
	@return ApiStagesEmailPartialUpdateRequest
*/
func (a *StagesAPIService) StagesEmailPartialUpdate(ctx context.Context, stageUuid string) ApiStagesEmailPartialUpdateRequest {
	return ApiStagesEmailPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return EmailStage
func (a *StagesAPIService) StagesEmailPartialUpdateExecute(r ApiStagesEmailPartialUpdateRequest) (*EmailStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EmailStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesEmailPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/email/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedEmailStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesEmailRetrieveRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesEmailRetrieveRequest) Execute() (*EmailStage, *http.Response, error) {
	return r.ApiService.StagesEmailRetrieveExecute(r)
}

/*
StagesEmailRetrieve Method for StagesEmailRetrieve

EmailStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Email Stage.
	@return ApiStagesEmailRetrieveRequest
*/
func (a *StagesAPIService) StagesEmailRetrieve(ctx context.Context, stageUuid string) ApiStagesEmailRetrieveRequest {
	return ApiStagesEmailRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return EmailStage
func (a *StagesAPIService) StagesEmailRetrieveExecute(r ApiStagesEmailRetrieveRequest) (*EmailStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EmailStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesEmailRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/email/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesEmailTemplatesListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
}

func (r ApiStagesEmailTemplatesListRequest) Execute() ([]TypeCreate, *http.Response, error) {
	return r.ApiService.StagesEmailTemplatesListExecute(r)
}

/*
StagesEmailTemplatesList Method for StagesEmailTemplatesList

Get all available templates, including custom templates

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesEmailTemplatesListRequest
*/
func (a *StagesAPIService) StagesEmailTemplatesList(ctx context.Context) ApiStagesEmailTemplatesListRequest {
	return ApiStagesEmailTemplatesListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []TypeCreate
func (a *StagesAPIService) StagesEmailTemplatesListExecute(r ApiStagesEmailTemplatesListRequest) ([]TypeCreate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []TypeCreate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesEmailTemplatesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/email/templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesEmailUpdateRequest struct {
	ctx               context.Context
	ApiService        *StagesAPIService
	stageUuid         string
	emailStageRequest *EmailStageRequest
}

func (r ApiStagesEmailUpdateRequest) EmailStageRequest(emailStageRequest EmailStageRequest) ApiStagesEmailUpdateRequest {
	r.emailStageRequest = &emailStageRequest
	return r
}

func (r ApiStagesEmailUpdateRequest) Execute() (*EmailStage, *http.Response, error) {
	return r.ApiService.StagesEmailUpdateExecute(r)
}

/*
StagesEmailUpdate Method for StagesEmailUpdate

EmailStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Email Stage.
	@return ApiStagesEmailUpdateRequest
*/
func (a *StagesAPIService) StagesEmailUpdate(ctx context.Context, stageUuid string) ApiStagesEmailUpdateRequest {
	return ApiStagesEmailUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return EmailStage
func (a *StagesAPIService) StagesEmailUpdateExecute(r ApiStagesEmailUpdateRequest) (*EmailStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EmailStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesEmailUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/email/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.emailStageRequest == nil {
		return localVarReturnValue, nil, reportError("emailStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.emailStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesEmailUsedByListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesEmailUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.StagesEmailUsedByListExecute(r)
}

/*
StagesEmailUsedByList Method for StagesEmailUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Email Stage.
	@return ApiStagesEmailUsedByListRequest
*/
func (a *StagesAPIService) StagesEmailUsedByList(ctx context.Context, stageUuid string) ApiStagesEmailUsedByListRequest {
	return ApiStagesEmailUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *StagesAPIService) StagesEmailUsedByListExecute(r ApiStagesEmailUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesEmailUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/email/{stage_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesEndpointsCreateRequest struct {
	ctx                  context.Context
	ApiService           *StagesAPIService
	endpointStageRequest *EndpointStageRequest
}

func (r ApiStagesEndpointsCreateRequest) EndpointStageRequest(endpointStageRequest EndpointStageRequest) ApiStagesEndpointsCreateRequest {
	r.endpointStageRequest = &endpointStageRequest
	return r
}

func (r ApiStagesEndpointsCreateRequest) Execute() (*EndpointStage, *http.Response, error) {
	return r.ApiService.StagesEndpointsCreateExecute(r)
}

/*
StagesEndpointsCreate Method for StagesEndpointsCreate

EndpointStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesEndpointsCreateRequest
*/
func (a *StagesAPIService) StagesEndpointsCreate(ctx context.Context) ApiStagesEndpointsCreateRequest {
	return ApiStagesEndpointsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return EndpointStage
func (a *StagesAPIService) StagesEndpointsCreateExecute(r ApiStagesEndpointsCreateRequest) (*EndpointStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EndpointStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesEndpointsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/endpoints/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.endpointStageRequest == nil {
		return localVarReturnValue, nil, reportError("endpointStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.endpointStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesEndpointsDestroyRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesEndpointsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.StagesEndpointsDestroyExecute(r)
}

/*
StagesEndpointsDestroy Method for StagesEndpointsDestroy

EndpointStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Endpoint Stage.
	@return ApiStagesEndpointsDestroyRequest
*/
func (a *StagesAPIService) StagesEndpointsDestroy(ctx context.Context, stageUuid string) ApiStagesEndpointsDestroyRequest {
	return ApiStagesEndpointsDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
func (a *StagesAPIService) StagesEndpointsDestroyExecute(r ApiStagesEndpointsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesEndpointsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/endpoints/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStagesEndpointsListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	name       *string
	ordering   *string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiStagesEndpointsListRequest) Name(name string) ApiStagesEndpointsListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiStagesEndpointsListRequest) Ordering(ordering string) ApiStagesEndpointsListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiStagesEndpointsListRequest) Page(page int32) ApiStagesEndpointsListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiStagesEndpointsListRequest) PageSize(pageSize int32) ApiStagesEndpointsListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiStagesEndpointsListRequest) Search(search string) ApiStagesEndpointsListRequest {
	r.search = &search
	return r
}

func (r ApiStagesEndpointsListRequest) Execute() (*PaginatedEndpointStageList, *http.Response, error) {
	return r.ApiService.StagesEndpointsListExecute(r)
}

/*
StagesEndpointsList Method for StagesEndpointsList

EndpointStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesEndpointsListRequest
*/
func (a *StagesAPIService) StagesEndpointsList(ctx context.Context) ApiStagesEndpointsListRequest {
	return ApiStagesEndpointsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedEndpointStageList
func (a *StagesAPIService) StagesEndpointsListExecute(r ApiStagesEndpointsListRequest) (*PaginatedEndpointStageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedEndpointStageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesEndpointsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/endpoints/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesEndpointsPartialUpdateRequest struct {
	ctx                         context.Context
	ApiService                  *StagesAPIService
	stageUuid                   string
	patchedEndpointStageRequest *PatchedEndpointStageRequest
}

func (r ApiStagesEndpointsPartialUpdateRequest) PatchedEndpointStageRequest(patchedEndpointStageRequest PatchedEndpointStageRequest) ApiStagesEndpointsPartialUpdateRequest {
	r.patchedEndpointStageRequest = &patchedEndpointStageRequest
	return r
}

func (r ApiStagesEndpointsPartialUpdateRequest) Execute() (*EndpointStage, *http.Response, error) {
	return r.ApiService.StagesEndpointsPartialUpdateExecute(r)
}

/*
StagesEndpointsPartialUpdate Method for StagesEndpointsPartialUpdate

EndpointStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Endpoint Stage.
	@return ApiStagesEndpointsPartialUpdateRequest
*/
func (a *StagesAPIService) StagesEndpointsPartialUpdate(ctx context.Context, stageUuid string) ApiStagesEndpointsPartialUpdateRequest {
	return ApiStagesEndpointsPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return EndpointStage
func (a *StagesAPIService) StagesEndpointsPartialUpdateExecute(r ApiStagesEndpointsPartialUpdateRequest) (*EndpointStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EndpointStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesEndpointsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/endpoints/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedEndpointStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesEndpointsRetrieveRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesEndpointsRetrieveRequest) Execute() (*EndpointStage, *http.Response, error) {
	return r.ApiService.StagesEndpointsRetrieveExecute(r)
}

/*
StagesEndpointsRetrieve Method for StagesEndpointsRetrieve

EndpointStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Endpoint Stage.
	@return ApiStagesEndpointsRetrieveRequest
*/
func (a *StagesAPIService) StagesEndpointsRetrieve(ctx context.Context, stageUuid string) ApiStagesEndpointsRetrieveRequest {
	return ApiStagesEndpointsRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return EndpointStage
func (a *StagesAPIService) StagesEndpointsRetrieveExecute(r ApiStagesEndpointsRetrieveRequest) (*EndpointStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EndpointStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesEndpointsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/endpoints/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesEndpointsUpdateRequest struct {
	ctx                  context.Context
	ApiService           *StagesAPIService
	stageUuid            string
	endpointStageRequest *EndpointStageRequest
}

func (r ApiStagesEndpointsUpdateRequest) EndpointStageRequest(endpointStageRequest EndpointStageRequest) ApiStagesEndpointsUpdateRequest {
	r.endpointStageRequest = &endpointStageRequest
	return r
}

func (r ApiStagesEndpointsUpdateRequest) Execute() (*EndpointStage, *http.Response, error) {
	return r.ApiService.StagesEndpointsUpdateExecute(r)
}

/*
StagesEndpointsUpdate Method for StagesEndpointsUpdate

EndpointStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Endpoint Stage.
	@return ApiStagesEndpointsUpdateRequest
*/
func (a *StagesAPIService) StagesEndpointsUpdate(ctx context.Context, stageUuid string) ApiStagesEndpointsUpdateRequest {
	return ApiStagesEndpointsUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return EndpointStage
func (a *StagesAPIService) StagesEndpointsUpdateExecute(r ApiStagesEndpointsUpdateRequest) (*EndpointStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EndpointStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesEndpointsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/endpoints/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.endpointStageRequest == nil {
		return localVarReturnValue, nil, reportError("endpointStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.endpointStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesEndpointsUsedByListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesEndpointsUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.StagesEndpointsUsedByListExecute(r)
}

/*
StagesEndpointsUsedByList Method for StagesEndpointsUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Endpoint Stage.
	@return ApiStagesEndpointsUsedByListRequest
*/
func (a *StagesAPIService) StagesEndpointsUsedByList(ctx context.Context, stageUuid string) ApiStagesEndpointsUsedByListRequest {
	return ApiStagesEndpointsUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *StagesAPIService) StagesEndpointsUsedByListExecute(r ApiStagesEndpointsUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesEndpointsUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/endpoints/{stage_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesIdentificationCreateRequest struct {
	ctx                        context.Context
	ApiService                 *StagesAPIService
	identificationStageRequest *IdentificationStageRequest
}

func (r ApiStagesIdentificationCreateRequest) IdentificationStageRequest(identificationStageRequest IdentificationStageRequest) ApiStagesIdentificationCreateRequest {
	r.identificationStageRequest = &identificationStageRequest
	return r
}

func (r ApiStagesIdentificationCreateRequest) Execute() (*IdentificationStage, *http.Response, error) {
	return r.ApiService.StagesIdentificationCreateExecute(r)
}

/*
StagesIdentificationCreate Method for StagesIdentificationCreate

IdentificationStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesIdentificationCreateRequest
*/
func (a *StagesAPIService) StagesIdentificationCreate(ctx context.Context) ApiStagesIdentificationCreateRequest {
	return ApiStagesIdentificationCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return IdentificationStage
func (a *StagesAPIService) StagesIdentificationCreateExecute(r ApiStagesIdentificationCreateRequest) (*IdentificationStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IdentificationStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesIdentificationCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/identification/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.identificationStageRequest == nil {
		return localVarReturnValue, nil, reportError("identificationStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identificationStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesIdentificationDestroyRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesIdentificationDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.StagesIdentificationDestroyExecute(r)
}

/*
StagesIdentificationDestroy Method for StagesIdentificationDestroy

IdentificationStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Identification Stage.
	@return ApiStagesIdentificationDestroyRequest
*/
func (a *StagesAPIService) StagesIdentificationDestroy(ctx context.Context, stageUuid string) ApiStagesIdentificationDestroyRequest {
	return ApiStagesIdentificationDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
func (a *StagesAPIService) StagesIdentificationDestroyExecute(r ApiStagesIdentificationDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesIdentificationDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/identification/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStagesIdentificationListRequest struct {
	ctx                     context.Context
	ApiService              *StagesAPIService
	captchaStage            *string
	caseInsensitiveMatching *bool
	enrollmentFlow          *string
	name                    *string
	ordering                *string
	page                    *int32
	pageSize                *int32
	passwordStage           *string
	passwordlessFlow        *string
	recoveryFlow            *string
	search                  *string
	showMatchedUser         *bool
	showSourceLabels        *bool
	webauthnStage           *string
}

func (r ApiStagesIdentificationListRequest) CaptchaStage(captchaStage string) ApiStagesIdentificationListRequest {
	r.captchaStage = &captchaStage
	return r
}

func (r ApiStagesIdentificationListRequest) CaseInsensitiveMatching(caseInsensitiveMatching bool) ApiStagesIdentificationListRequest {
	r.caseInsensitiveMatching = &caseInsensitiveMatching
	return r
}

func (r ApiStagesIdentificationListRequest) EnrollmentFlow(enrollmentFlow string) ApiStagesIdentificationListRequest {
	r.enrollmentFlow = &enrollmentFlow
	return r
}

func (r ApiStagesIdentificationListRequest) Name(name string) ApiStagesIdentificationListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiStagesIdentificationListRequest) Ordering(ordering string) ApiStagesIdentificationListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiStagesIdentificationListRequest) Page(page int32) ApiStagesIdentificationListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiStagesIdentificationListRequest) PageSize(pageSize int32) ApiStagesIdentificationListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiStagesIdentificationListRequest) PasswordStage(passwordStage string) ApiStagesIdentificationListRequest {
	r.passwordStage = &passwordStage
	return r
}

func (r ApiStagesIdentificationListRequest) PasswordlessFlow(passwordlessFlow string) ApiStagesIdentificationListRequest {
	r.passwordlessFlow = &passwordlessFlow
	return r
}

func (r ApiStagesIdentificationListRequest) RecoveryFlow(recoveryFlow string) ApiStagesIdentificationListRequest {
	r.recoveryFlow = &recoveryFlow
	return r
}

// A search term.
func (r ApiStagesIdentificationListRequest) Search(search string) ApiStagesIdentificationListRequest {
	r.search = &search
	return r
}

func (r ApiStagesIdentificationListRequest) ShowMatchedUser(showMatchedUser bool) ApiStagesIdentificationListRequest {
	r.showMatchedUser = &showMatchedUser
	return r
}

func (r ApiStagesIdentificationListRequest) ShowSourceLabels(showSourceLabels bool) ApiStagesIdentificationListRequest {
	r.showSourceLabels = &showSourceLabels
	return r
}

func (r ApiStagesIdentificationListRequest) WebauthnStage(webauthnStage string) ApiStagesIdentificationListRequest {
	r.webauthnStage = &webauthnStage
	return r
}

func (r ApiStagesIdentificationListRequest) Execute() (*PaginatedIdentificationStageList, *http.Response, error) {
	return r.ApiService.StagesIdentificationListExecute(r)
}

/*
StagesIdentificationList Method for StagesIdentificationList

IdentificationStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesIdentificationListRequest
*/
func (a *StagesAPIService) StagesIdentificationList(ctx context.Context) ApiStagesIdentificationListRequest {
	return ApiStagesIdentificationListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedIdentificationStageList
func (a *StagesAPIService) StagesIdentificationListExecute(r ApiStagesIdentificationListRequest) (*PaginatedIdentificationStageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedIdentificationStageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesIdentificationList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/identification/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.captchaStage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "captcha_stage", r.captchaStage, "form", "")
	}
	if r.caseInsensitiveMatching != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "case_insensitive_matching", r.caseInsensitiveMatching, "form", "")
	}
	if r.enrollmentFlow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enrollment_flow", r.enrollmentFlow, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.passwordStage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "password_stage", r.passwordStage, "form", "")
	}
	if r.passwordlessFlow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "passwordless_flow", r.passwordlessFlow, "form", "")
	}
	if r.recoveryFlow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recovery_flow", r.recoveryFlow, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.showMatchedUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_matched_user", r.showMatchedUser, "form", "")
	}
	if r.showSourceLabels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_source_labels", r.showSourceLabels, "form", "")
	}
	if r.webauthnStage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "webauthn_stage", r.webauthnStage, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesIdentificationPartialUpdateRequest struct {
	ctx                               context.Context
	ApiService                        *StagesAPIService
	stageUuid                         string
	patchedIdentificationStageRequest *PatchedIdentificationStageRequest
}

func (r ApiStagesIdentificationPartialUpdateRequest) PatchedIdentificationStageRequest(patchedIdentificationStageRequest PatchedIdentificationStageRequest) ApiStagesIdentificationPartialUpdateRequest {
	r.patchedIdentificationStageRequest = &patchedIdentificationStageRequest
	return r
}

func (r ApiStagesIdentificationPartialUpdateRequest) Execute() (*IdentificationStage, *http.Response, error) {
	return r.ApiService.StagesIdentificationPartialUpdateExecute(r)
}

/*
StagesIdentificationPartialUpdate Method for StagesIdentificationPartialUpdate

IdentificationStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Identification Stage.
	@return ApiStagesIdentificationPartialUpdateRequest
*/
func (a *StagesAPIService) StagesIdentificationPartialUpdate(ctx context.Context, stageUuid string) ApiStagesIdentificationPartialUpdateRequest {
	return ApiStagesIdentificationPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return IdentificationStage
func (a *StagesAPIService) StagesIdentificationPartialUpdateExecute(r ApiStagesIdentificationPartialUpdateRequest) (*IdentificationStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IdentificationStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesIdentificationPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/identification/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedIdentificationStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesIdentificationRetrieveRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesIdentificationRetrieveRequest) Execute() (*IdentificationStage, *http.Response, error) {
	return r.ApiService.StagesIdentificationRetrieveExecute(r)
}

/*
StagesIdentificationRetrieve Method for StagesIdentificationRetrieve

IdentificationStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Identification Stage.
	@return ApiStagesIdentificationRetrieveRequest
*/
func (a *StagesAPIService) StagesIdentificationRetrieve(ctx context.Context, stageUuid string) ApiStagesIdentificationRetrieveRequest {
	return ApiStagesIdentificationRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return IdentificationStage
func (a *StagesAPIService) StagesIdentificationRetrieveExecute(r ApiStagesIdentificationRetrieveRequest) (*IdentificationStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IdentificationStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesIdentificationRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/identification/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesIdentificationUpdateRequest struct {
	ctx                        context.Context
	ApiService                 *StagesAPIService
	stageUuid                  string
	identificationStageRequest *IdentificationStageRequest
}

func (r ApiStagesIdentificationUpdateRequest) IdentificationStageRequest(identificationStageRequest IdentificationStageRequest) ApiStagesIdentificationUpdateRequest {
	r.identificationStageRequest = &identificationStageRequest
	return r
}

func (r ApiStagesIdentificationUpdateRequest) Execute() (*IdentificationStage, *http.Response, error) {
	return r.ApiService.StagesIdentificationUpdateExecute(r)
}

/*
StagesIdentificationUpdate Method for StagesIdentificationUpdate

IdentificationStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Identification Stage.
	@return ApiStagesIdentificationUpdateRequest
*/
func (a *StagesAPIService) StagesIdentificationUpdate(ctx context.Context, stageUuid string) ApiStagesIdentificationUpdateRequest {
	return ApiStagesIdentificationUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return IdentificationStage
func (a *StagesAPIService) StagesIdentificationUpdateExecute(r ApiStagesIdentificationUpdateRequest) (*IdentificationStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IdentificationStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesIdentificationUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/identification/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.identificationStageRequest == nil {
		return localVarReturnValue, nil, reportError("identificationStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identificationStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesIdentificationUsedByListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesIdentificationUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.StagesIdentificationUsedByListExecute(r)
}

/*
StagesIdentificationUsedByList Method for StagesIdentificationUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Identification Stage.
	@return ApiStagesIdentificationUsedByListRequest
*/
func (a *StagesAPIService) StagesIdentificationUsedByList(ctx context.Context, stageUuid string) ApiStagesIdentificationUsedByListRequest {
	return ApiStagesIdentificationUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *StagesAPIService) StagesIdentificationUsedByListExecute(r ApiStagesIdentificationUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesIdentificationUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/identification/{stage_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesInvitationInvitationsCreateRequest struct {
	ctx               context.Context
	ApiService        *StagesAPIService
	invitationRequest *InvitationRequest
}

func (r ApiStagesInvitationInvitationsCreateRequest) InvitationRequest(invitationRequest InvitationRequest) ApiStagesInvitationInvitationsCreateRequest {
	r.invitationRequest = &invitationRequest
	return r
}

func (r ApiStagesInvitationInvitationsCreateRequest) Execute() (*Invitation, *http.Response, error) {
	return r.ApiService.StagesInvitationInvitationsCreateExecute(r)
}

/*
StagesInvitationInvitationsCreate Method for StagesInvitationInvitationsCreate

Invitation Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesInvitationInvitationsCreateRequest
*/
func (a *StagesAPIService) StagesInvitationInvitationsCreate(ctx context.Context) ApiStagesInvitationInvitationsCreateRequest {
	return ApiStagesInvitationInvitationsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Invitation
func (a *StagesAPIService) StagesInvitationInvitationsCreateExecute(r ApiStagesInvitationInvitationsCreateRequest) (*Invitation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Invitation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesInvitationInvitationsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/invitation/invitations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.invitationRequest == nil {
		return localVarReturnValue, nil, reportError("invitationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.invitationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesInvitationInvitationsDestroyRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	inviteUuid string
}

func (r ApiStagesInvitationInvitationsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.StagesInvitationInvitationsDestroyExecute(r)
}

/*
StagesInvitationInvitationsDestroy Method for StagesInvitationInvitationsDestroy

Invitation Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param inviteUuid A UUID string identifying this Invitation.
	@return ApiStagesInvitationInvitationsDestroyRequest
*/
func (a *StagesAPIService) StagesInvitationInvitationsDestroy(ctx context.Context, inviteUuid string) ApiStagesInvitationInvitationsDestroyRequest {
	return ApiStagesInvitationInvitationsDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		inviteUuid: inviteUuid,
	}
}

// Execute executes the request
func (a *StagesAPIService) StagesInvitationInvitationsDestroyExecute(r ApiStagesInvitationInvitationsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesInvitationInvitationsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/invitation/invitations/{invite_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"invite_uuid"+"}", url.PathEscape(parameterValueToString(r.inviteUuid, "inviteUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStagesInvitationInvitationsListRequest struct {
	ctx               context.Context
	ApiService        *StagesAPIService
	createdByUsername *string
	expires           *time.Time
	flowSlug          *string
	name              *string
	ordering          *string
	page              *int32
	pageSize          *int32
	search            *string
}

func (r ApiStagesInvitationInvitationsListRequest) CreatedByUsername(createdByUsername string) ApiStagesInvitationInvitationsListRequest {
	r.createdByUsername = &createdByUsername
	return r
}

func (r ApiStagesInvitationInvitationsListRequest) Expires(expires time.Time) ApiStagesInvitationInvitationsListRequest {
	r.expires = &expires
	return r
}

func (r ApiStagesInvitationInvitationsListRequest) FlowSlug(flowSlug string) ApiStagesInvitationInvitationsListRequest {
	r.flowSlug = &flowSlug
	return r
}

func (r ApiStagesInvitationInvitationsListRequest) Name(name string) ApiStagesInvitationInvitationsListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiStagesInvitationInvitationsListRequest) Ordering(ordering string) ApiStagesInvitationInvitationsListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiStagesInvitationInvitationsListRequest) Page(page int32) ApiStagesInvitationInvitationsListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiStagesInvitationInvitationsListRequest) PageSize(pageSize int32) ApiStagesInvitationInvitationsListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiStagesInvitationInvitationsListRequest) Search(search string) ApiStagesInvitationInvitationsListRequest {
	r.search = &search
	return r
}

func (r ApiStagesInvitationInvitationsListRequest) Execute() (*PaginatedInvitationList, *http.Response, error) {
	return r.ApiService.StagesInvitationInvitationsListExecute(r)
}

/*
StagesInvitationInvitationsList Method for StagesInvitationInvitationsList

Invitation Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesInvitationInvitationsListRequest
*/
func (a *StagesAPIService) StagesInvitationInvitationsList(ctx context.Context) ApiStagesInvitationInvitationsListRequest {
	return ApiStagesInvitationInvitationsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedInvitationList
func (a *StagesAPIService) StagesInvitationInvitationsListExecute(r ApiStagesInvitationInvitationsListRequest) (*PaginatedInvitationList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedInvitationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesInvitationInvitationsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/invitation/invitations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.createdByUsername != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by__username", r.createdByUsername, "form", "")
	}
	if r.expires != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expires", r.expires, "form", "")
	}
	if r.flowSlug != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flow__slug", r.flowSlug, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesInvitationInvitationsPartialUpdateRequest struct {
	ctx                      context.Context
	ApiService               *StagesAPIService
	inviteUuid               string
	patchedInvitationRequest *PatchedInvitationRequest
}

func (r ApiStagesInvitationInvitationsPartialUpdateRequest) PatchedInvitationRequest(patchedInvitationRequest PatchedInvitationRequest) ApiStagesInvitationInvitationsPartialUpdateRequest {
	r.patchedInvitationRequest = &patchedInvitationRequest
	return r
}

func (r ApiStagesInvitationInvitationsPartialUpdateRequest) Execute() (*Invitation, *http.Response, error) {
	return r.ApiService.StagesInvitationInvitationsPartialUpdateExecute(r)
}

/*
StagesInvitationInvitationsPartialUpdate Method for StagesInvitationInvitationsPartialUpdate

Invitation Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param inviteUuid A UUID string identifying this Invitation.
	@return ApiStagesInvitationInvitationsPartialUpdateRequest
*/
func (a *StagesAPIService) StagesInvitationInvitationsPartialUpdate(ctx context.Context, inviteUuid string) ApiStagesInvitationInvitationsPartialUpdateRequest {
	return ApiStagesInvitationInvitationsPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		inviteUuid: inviteUuid,
	}
}

// Execute executes the request
//
//	@return Invitation
func (a *StagesAPIService) StagesInvitationInvitationsPartialUpdateExecute(r ApiStagesInvitationInvitationsPartialUpdateRequest) (*Invitation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Invitation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesInvitationInvitationsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/invitation/invitations/{invite_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"invite_uuid"+"}", url.PathEscape(parameterValueToString(r.inviteUuid, "inviteUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedInvitationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesInvitationInvitationsRetrieveRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	inviteUuid string
}

func (r ApiStagesInvitationInvitationsRetrieveRequest) Execute() (*Invitation, *http.Response, error) {
	return r.ApiService.StagesInvitationInvitationsRetrieveExecute(r)
}

/*
StagesInvitationInvitationsRetrieve Method for StagesInvitationInvitationsRetrieve

Invitation Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param inviteUuid A UUID string identifying this Invitation.
	@return ApiStagesInvitationInvitationsRetrieveRequest
*/
func (a *StagesAPIService) StagesInvitationInvitationsRetrieve(ctx context.Context, inviteUuid string) ApiStagesInvitationInvitationsRetrieveRequest {
	return ApiStagesInvitationInvitationsRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		inviteUuid: inviteUuid,
	}
}

// Execute executes the request
//
//	@return Invitation
func (a *StagesAPIService) StagesInvitationInvitationsRetrieveExecute(r ApiStagesInvitationInvitationsRetrieveRequest) (*Invitation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Invitation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesInvitationInvitationsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/invitation/invitations/{invite_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"invite_uuid"+"}", url.PathEscape(parameterValueToString(r.inviteUuid, "inviteUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesInvitationInvitationsUpdateRequest struct {
	ctx               context.Context
	ApiService        *StagesAPIService
	inviteUuid        string
	invitationRequest *InvitationRequest
}

func (r ApiStagesInvitationInvitationsUpdateRequest) InvitationRequest(invitationRequest InvitationRequest) ApiStagesInvitationInvitationsUpdateRequest {
	r.invitationRequest = &invitationRequest
	return r
}

func (r ApiStagesInvitationInvitationsUpdateRequest) Execute() (*Invitation, *http.Response, error) {
	return r.ApiService.StagesInvitationInvitationsUpdateExecute(r)
}

/*
StagesInvitationInvitationsUpdate Method for StagesInvitationInvitationsUpdate

Invitation Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param inviteUuid A UUID string identifying this Invitation.
	@return ApiStagesInvitationInvitationsUpdateRequest
*/
func (a *StagesAPIService) StagesInvitationInvitationsUpdate(ctx context.Context, inviteUuid string) ApiStagesInvitationInvitationsUpdateRequest {
	return ApiStagesInvitationInvitationsUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		inviteUuid: inviteUuid,
	}
}

// Execute executes the request
//
//	@return Invitation
func (a *StagesAPIService) StagesInvitationInvitationsUpdateExecute(r ApiStagesInvitationInvitationsUpdateRequest) (*Invitation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Invitation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesInvitationInvitationsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/invitation/invitations/{invite_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"invite_uuid"+"}", url.PathEscape(parameterValueToString(r.inviteUuid, "inviteUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.invitationRequest == nil {
		return localVarReturnValue, nil, reportError("invitationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.invitationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesInvitationInvitationsUsedByListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	inviteUuid string
}

func (r ApiStagesInvitationInvitationsUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.StagesInvitationInvitationsUsedByListExecute(r)
}

/*
StagesInvitationInvitationsUsedByList Method for StagesInvitationInvitationsUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param inviteUuid A UUID string identifying this Invitation.
	@return ApiStagesInvitationInvitationsUsedByListRequest
*/
func (a *StagesAPIService) StagesInvitationInvitationsUsedByList(ctx context.Context, inviteUuid string) ApiStagesInvitationInvitationsUsedByListRequest {
	return ApiStagesInvitationInvitationsUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		inviteUuid: inviteUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *StagesAPIService) StagesInvitationInvitationsUsedByListExecute(r ApiStagesInvitationInvitationsUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesInvitationInvitationsUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/invitation/invitations/{invite_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"invite_uuid"+"}", url.PathEscape(parameterValueToString(r.inviteUuid, "inviteUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesInvitationStagesCreateRequest struct {
	ctx                    context.Context
	ApiService             *StagesAPIService
	invitationStageRequest *InvitationStageRequest
}

func (r ApiStagesInvitationStagesCreateRequest) InvitationStageRequest(invitationStageRequest InvitationStageRequest) ApiStagesInvitationStagesCreateRequest {
	r.invitationStageRequest = &invitationStageRequest
	return r
}

func (r ApiStagesInvitationStagesCreateRequest) Execute() (*InvitationStage, *http.Response, error) {
	return r.ApiService.StagesInvitationStagesCreateExecute(r)
}

/*
StagesInvitationStagesCreate Method for StagesInvitationStagesCreate

InvitationStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesInvitationStagesCreateRequest
*/
func (a *StagesAPIService) StagesInvitationStagesCreate(ctx context.Context) ApiStagesInvitationStagesCreateRequest {
	return ApiStagesInvitationStagesCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return InvitationStage
func (a *StagesAPIService) StagesInvitationStagesCreateExecute(r ApiStagesInvitationStagesCreateRequest) (*InvitationStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InvitationStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesInvitationStagesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/invitation/stages/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.invitationStageRequest == nil {
		return localVarReturnValue, nil, reportError("invitationStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.invitationStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesInvitationStagesDestroyRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesInvitationStagesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.StagesInvitationStagesDestroyExecute(r)
}

/*
StagesInvitationStagesDestroy Method for StagesInvitationStagesDestroy

InvitationStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Invitation Stage.
	@return ApiStagesInvitationStagesDestroyRequest
*/
func (a *StagesAPIService) StagesInvitationStagesDestroy(ctx context.Context, stageUuid string) ApiStagesInvitationStagesDestroyRequest {
	return ApiStagesInvitationStagesDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
func (a *StagesAPIService) StagesInvitationStagesDestroyExecute(r ApiStagesInvitationStagesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesInvitationStagesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/invitation/stages/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStagesInvitationStagesListRequest struct {
	ctx                           context.Context
	ApiService                    *StagesAPIService
	continueFlowWithoutInvitation *bool
	name                          *string
	noFlows                       *bool
	ordering                      *string
	page                          *int32
	pageSize                      *int32
	search                        *string
	stageUuid                     *string
}

func (r ApiStagesInvitationStagesListRequest) ContinueFlowWithoutInvitation(continueFlowWithoutInvitation bool) ApiStagesInvitationStagesListRequest {
	r.continueFlowWithoutInvitation = &continueFlowWithoutInvitation
	return r
}

func (r ApiStagesInvitationStagesListRequest) Name(name string) ApiStagesInvitationStagesListRequest {
	r.name = &name
	return r
}

func (r ApiStagesInvitationStagesListRequest) NoFlows(noFlows bool) ApiStagesInvitationStagesListRequest {
	r.noFlows = &noFlows
	return r
}

// Which field to use when ordering the results.
func (r ApiStagesInvitationStagesListRequest) Ordering(ordering string) ApiStagesInvitationStagesListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiStagesInvitationStagesListRequest) Page(page int32) ApiStagesInvitationStagesListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiStagesInvitationStagesListRequest) PageSize(pageSize int32) ApiStagesInvitationStagesListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiStagesInvitationStagesListRequest) Search(search string) ApiStagesInvitationStagesListRequest {
	r.search = &search
	return r
}

func (r ApiStagesInvitationStagesListRequest) StageUuid(stageUuid string) ApiStagesInvitationStagesListRequest {
	r.stageUuid = &stageUuid
	return r
}

func (r ApiStagesInvitationStagesListRequest) Execute() (*PaginatedInvitationStageList, *http.Response, error) {
	return r.ApiService.StagesInvitationStagesListExecute(r)
}

/*
StagesInvitationStagesList Method for StagesInvitationStagesList

InvitationStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesInvitationStagesListRequest
*/
func (a *StagesAPIService) StagesInvitationStagesList(ctx context.Context) ApiStagesInvitationStagesListRequest {
	return ApiStagesInvitationStagesListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedInvitationStageList
func (a *StagesAPIService) StagesInvitationStagesListExecute(r ApiStagesInvitationStagesListRequest) (*PaginatedInvitationStageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedInvitationStageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesInvitationStagesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/invitation/stages/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.continueFlowWithoutInvitation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continue_flow_without_invitation", r.continueFlowWithoutInvitation, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.noFlows != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "no_flows", r.noFlows, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.stageUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stage_uuid", r.stageUuid, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesInvitationStagesPartialUpdateRequest struct {
	ctx                           context.Context
	ApiService                    *StagesAPIService
	stageUuid                     string
	patchedInvitationStageRequest *PatchedInvitationStageRequest
}

func (r ApiStagesInvitationStagesPartialUpdateRequest) PatchedInvitationStageRequest(patchedInvitationStageRequest PatchedInvitationStageRequest) ApiStagesInvitationStagesPartialUpdateRequest {
	r.patchedInvitationStageRequest = &patchedInvitationStageRequest
	return r
}

func (r ApiStagesInvitationStagesPartialUpdateRequest) Execute() (*InvitationStage, *http.Response, error) {
	return r.ApiService.StagesInvitationStagesPartialUpdateExecute(r)
}

/*
StagesInvitationStagesPartialUpdate Method for StagesInvitationStagesPartialUpdate

InvitationStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Invitation Stage.
	@return ApiStagesInvitationStagesPartialUpdateRequest
*/
func (a *StagesAPIService) StagesInvitationStagesPartialUpdate(ctx context.Context, stageUuid string) ApiStagesInvitationStagesPartialUpdateRequest {
	return ApiStagesInvitationStagesPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return InvitationStage
func (a *StagesAPIService) StagesInvitationStagesPartialUpdateExecute(r ApiStagesInvitationStagesPartialUpdateRequest) (*InvitationStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InvitationStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesInvitationStagesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/invitation/stages/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedInvitationStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesInvitationStagesRetrieveRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesInvitationStagesRetrieveRequest) Execute() (*InvitationStage, *http.Response, error) {
	return r.ApiService.StagesInvitationStagesRetrieveExecute(r)
}

/*
StagesInvitationStagesRetrieve Method for StagesInvitationStagesRetrieve

InvitationStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Invitation Stage.
	@return ApiStagesInvitationStagesRetrieveRequest
*/
func (a *StagesAPIService) StagesInvitationStagesRetrieve(ctx context.Context, stageUuid string) ApiStagesInvitationStagesRetrieveRequest {
	return ApiStagesInvitationStagesRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return InvitationStage
func (a *StagesAPIService) StagesInvitationStagesRetrieveExecute(r ApiStagesInvitationStagesRetrieveRequest) (*InvitationStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InvitationStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesInvitationStagesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/invitation/stages/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesInvitationStagesUpdateRequest struct {
	ctx                    context.Context
	ApiService             *StagesAPIService
	stageUuid              string
	invitationStageRequest *InvitationStageRequest
}

func (r ApiStagesInvitationStagesUpdateRequest) InvitationStageRequest(invitationStageRequest InvitationStageRequest) ApiStagesInvitationStagesUpdateRequest {
	r.invitationStageRequest = &invitationStageRequest
	return r
}

func (r ApiStagesInvitationStagesUpdateRequest) Execute() (*InvitationStage, *http.Response, error) {
	return r.ApiService.StagesInvitationStagesUpdateExecute(r)
}

/*
StagesInvitationStagesUpdate Method for StagesInvitationStagesUpdate

InvitationStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Invitation Stage.
	@return ApiStagesInvitationStagesUpdateRequest
*/
func (a *StagesAPIService) StagesInvitationStagesUpdate(ctx context.Context, stageUuid string) ApiStagesInvitationStagesUpdateRequest {
	return ApiStagesInvitationStagesUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return InvitationStage
func (a *StagesAPIService) StagesInvitationStagesUpdateExecute(r ApiStagesInvitationStagesUpdateRequest) (*InvitationStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InvitationStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesInvitationStagesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/invitation/stages/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.invitationStageRequest == nil {
		return localVarReturnValue, nil, reportError("invitationStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.invitationStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesInvitationStagesUsedByListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesInvitationStagesUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.StagesInvitationStagesUsedByListExecute(r)
}

/*
StagesInvitationStagesUsedByList Method for StagesInvitationStagesUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Invitation Stage.
	@return ApiStagesInvitationStagesUsedByListRequest
*/
func (a *StagesAPIService) StagesInvitationStagesUsedByList(ctx context.Context, stageUuid string) ApiStagesInvitationStagesUsedByListRequest {
	return ApiStagesInvitationStagesUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *StagesAPIService) StagesInvitationStagesUsedByListExecute(r ApiStagesInvitationStagesUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesInvitationStagesUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/invitation/stages/{stage_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesMtlsCreateRequest struct {
	ctx                   context.Context
	ApiService            *StagesAPIService
	mutualTLSStageRequest *MutualTLSStageRequest
}

func (r ApiStagesMtlsCreateRequest) MutualTLSStageRequest(mutualTLSStageRequest MutualTLSStageRequest) ApiStagesMtlsCreateRequest {
	r.mutualTLSStageRequest = &mutualTLSStageRequest
	return r
}

func (r ApiStagesMtlsCreateRequest) Execute() (*MutualTLSStage, *http.Response, error) {
	return r.ApiService.StagesMtlsCreateExecute(r)
}

/*
StagesMtlsCreate Method for StagesMtlsCreate

MutualTLSStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesMtlsCreateRequest
*/
func (a *StagesAPIService) StagesMtlsCreate(ctx context.Context) ApiStagesMtlsCreateRequest {
	return ApiStagesMtlsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MutualTLSStage
func (a *StagesAPIService) StagesMtlsCreateExecute(r ApiStagesMtlsCreateRequest) (*MutualTLSStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MutualTLSStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesMtlsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/mtls/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mutualTLSStageRequest == nil {
		return localVarReturnValue, nil, reportError("mutualTLSStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.mutualTLSStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesMtlsDestroyRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesMtlsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.StagesMtlsDestroyExecute(r)
}

/*
StagesMtlsDestroy Method for StagesMtlsDestroy

MutualTLSStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Mutual TLS Stage.
	@return ApiStagesMtlsDestroyRequest
*/
func (a *StagesAPIService) StagesMtlsDestroy(ctx context.Context, stageUuid string) ApiStagesMtlsDestroyRequest {
	return ApiStagesMtlsDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
func (a *StagesAPIService) StagesMtlsDestroyExecute(r ApiStagesMtlsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesMtlsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/mtls/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStagesMtlsListRequest struct {
	ctx                    context.Context
	ApiService             *StagesAPIService
	certAttribute          *string
	certificateAuthorities *[]string
	mode                   *string
	name                   *string
	ordering               *string
	page                   *int32
	pageSize               *int32
	search                 *string
	stageUuid              *string
	userAttribute          *string
}

func (r ApiStagesMtlsListRequest) CertAttribute(certAttribute string) ApiStagesMtlsListRequest {
	r.certAttribute = &certAttribute
	return r
}

func (r ApiStagesMtlsListRequest) CertificateAuthorities(certificateAuthorities []string) ApiStagesMtlsListRequest {
	r.certificateAuthorities = &certificateAuthorities
	return r
}

func (r ApiStagesMtlsListRequest) Mode(mode string) ApiStagesMtlsListRequest {
	r.mode = &mode
	return r
}

func (r ApiStagesMtlsListRequest) Name(name string) ApiStagesMtlsListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiStagesMtlsListRequest) Ordering(ordering string) ApiStagesMtlsListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiStagesMtlsListRequest) Page(page int32) ApiStagesMtlsListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiStagesMtlsListRequest) PageSize(pageSize int32) ApiStagesMtlsListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiStagesMtlsListRequest) Search(search string) ApiStagesMtlsListRequest {
	r.search = &search
	return r
}

func (r ApiStagesMtlsListRequest) StageUuid(stageUuid string) ApiStagesMtlsListRequest {
	r.stageUuid = &stageUuid
	return r
}

func (r ApiStagesMtlsListRequest) UserAttribute(userAttribute string) ApiStagesMtlsListRequest {
	r.userAttribute = &userAttribute
	return r
}

func (r ApiStagesMtlsListRequest) Execute() (*PaginatedMutualTLSStageList, *http.Response, error) {
	return r.ApiService.StagesMtlsListExecute(r)
}

/*
StagesMtlsList Method for StagesMtlsList

MutualTLSStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesMtlsListRequest
*/
func (a *StagesAPIService) StagesMtlsList(ctx context.Context) ApiStagesMtlsListRequest {
	return ApiStagesMtlsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedMutualTLSStageList
func (a *StagesAPIService) StagesMtlsListExecute(r ApiStagesMtlsListRequest) (*PaginatedMutualTLSStageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedMutualTLSStageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesMtlsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/mtls/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.certAttribute != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cert_attribute", r.certAttribute, "form", "")
	}
	if r.certificateAuthorities != nil {
		t := *r.certificateAuthorities
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "certificate_authorities", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "certificate_authorities", t, "form", "multi")
		}
	}
	if r.mode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mode", r.mode, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.stageUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stage_uuid", r.stageUuid, "form", "")
	}
	if r.userAttribute != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_attribute", r.userAttribute, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesMtlsPartialUpdateRequest struct {
	ctx                          context.Context
	ApiService                   *StagesAPIService
	stageUuid                    string
	patchedMutualTLSStageRequest *PatchedMutualTLSStageRequest
}

func (r ApiStagesMtlsPartialUpdateRequest) PatchedMutualTLSStageRequest(patchedMutualTLSStageRequest PatchedMutualTLSStageRequest) ApiStagesMtlsPartialUpdateRequest {
	r.patchedMutualTLSStageRequest = &patchedMutualTLSStageRequest
	return r
}

func (r ApiStagesMtlsPartialUpdateRequest) Execute() (*MutualTLSStage, *http.Response, error) {
	return r.ApiService.StagesMtlsPartialUpdateExecute(r)
}

/*
StagesMtlsPartialUpdate Method for StagesMtlsPartialUpdate

MutualTLSStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Mutual TLS Stage.
	@return ApiStagesMtlsPartialUpdateRequest
*/
func (a *StagesAPIService) StagesMtlsPartialUpdate(ctx context.Context, stageUuid string) ApiStagesMtlsPartialUpdateRequest {
	return ApiStagesMtlsPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return MutualTLSStage
func (a *StagesAPIService) StagesMtlsPartialUpdateExecute(r ApiStagesMtlsPartialUpdateRequest) (*MutualTLSStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MutualTLSStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesMtlsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/mtls/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedMutualTLSStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesMtlsRetrieveRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesMtlsRetrieveRequest) Execute() (*MutualTLSStage, *http.Response, error) {
	return r.ApiService.StagesMtlsRetrieveExecute(r)
}

/*
StagesMtlsRetrieve Method for StagesMtlsRetrieve

MutualTLSStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Mutual TLS Stage.
	@return ApiStagesMtlsRetrieveRequest
*/
func (a *StagesAPIService) StagesMtlsRetrieve(ctx context.Context, stageUuid string) ApiStagesMtlsRetrieveRequest {
	return ApiStagesMtlsRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return MutualTLSStage
func (a *StagesAPIService) StagesMtlsRetrieveExecute(r ApiStagesMtlsRetrieveRequest) (*MutualTLSStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MutualTLSStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesMtlsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/mtls/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesMtlsUpdateRequest struct {
	ctx                   context.Context
	ApiService            *StagesAPIService
	stageUuid             string
	mutualTLSStageRequest *MutualTLSStageRequest
}

func (r ApiStagesMtlsUpdateRequest) MutualTLSStageRequest(mutualTLSStageRequest MutualTLSStageRequest) ApiStagesMtlsUpdateRequest {
	r.mutualTLSStageRequest = &mutualTLSStageRequest
	return r
}

func (r ApiStagesMtlsUpdateRequest) Execute() (*MutualTLSStage, *http.Response, error) {
	return r.ApiService.StagesMtlsUpdateExecute(r)
}

/*
StagesMtlsUpdate Method for StagesMtlsUpdate

MutualTLSStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Mutual TLS Stage.
	@return ApiStagesMtlsUpdateRequest
*/
func (a *StagesAPIService) StagesMtlsUpdate(ctx context.Context, stageUuid string) ApiStagesMtlsUpdateRequest {
	return ApiStagesMtlsUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return MutualTLSStage
func (a *StagesAPIService) StagesMtlsUpdateExecute(r ApiStagesMtlsUpdateRequest) (*MutualTLSStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MutualTLSStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesMtlsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/mtls/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mutualTLSStageRequest == nil {
		return localVarReturnValue, nil, reportError("mutualTLSStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.mutualTLSStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesMtlsUsedByListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesMtlsUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.StagesMtlsUsedByListExecute(r)
}

/*
StagesMtlsUsedByList Method for StagesMtlsUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Mutual TLS Stage.
	@return ApiStagesMtlsUsedByListRequest
*/
func (a *StagesAPIService) StagesMtlsUsedByList(ctx context.Context, stageUuid string) ApiStagesMtlsUsedByListRequest {
	return ApiStagesMtlsUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *StagesAPIService) StagesMtlsUsedByListExecute(r ApiStagesMtlsUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesMtlsUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/mtls/{stage_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesPasswordCreateRequest struct {
	ctx                  context.Context
	ApiService           *StagesAPIService
	passwordStageRequest *PasswordStageRequest
}

func (r ApiStagesPasswordCreateRequest) PasswordStageRequest(passwordStageRequest PasswordStageRequest) ApiStagesPasswordCreateRequest {
	r.passwordStageRequest = &passwordStageRequest
	return r
}

func (r ApiStagesPasswordCreateRequest) Execute() (*PasswordStage, *http.Response, error) {
	return r.ApiService.StagesPasswordCreateExecute(r)
}

/*
StagesPasswordCreate Method for StagesPasswordCreate

PasswordStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesPasswordCreateRequest
*/
func (a *StagesAPIService) StagesPasswordCreate(ctx context.Context) ApiStagesPasswordCreateRequest {
	return ApiStagesPasswordCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PasswordStage
func (a *StagesAPIService) StagesPasswordCreateExecute(r ApiStagesPasswordCreateRequest) (*PasswordStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PasswordStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesPasswordCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/password/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.passwordStageRequest == nil {
		return localVarReturnValue, nil, reportError("passwordStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.passwordStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesPasswordDestroyRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesPasswordDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.StagesPasswordDestroyExecute(r)
}

/*
StagesPasswordDestroy Method for StagesPasswordDestroy

PasswordStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Password Stage.
	@return ApiStagesPasswordDestroyRequest
*/
func (a *StagesAPIService) StagesPasswordDestroy(ctx context.Context, stageUuid string) ApiStagesPasswordDestroyRequest {
	return ApiStagesPasswordDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
func (a *StagesAPIService) StagesPasswordDestroyExecute(r ApiStagesPasswordDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesPasswordDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/password/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStagesPasswordListRequest struct {
	ctx                        context.Context
	ApiService                 *StagesAPIService
	allowShowPassword          *bool
	configureFlow              *string
	failedAttemptsBeforeCancel *int32
	name                       *string
	ordering                   *string
	page                       *int32
	pageSize                   *int32
	search                     *string
}

func (r ApiStagesPasswordListRequest) AllowShowPassword(allowShowPassword bool) ApiStagesPasswordListRequest {
	r.allowShowPassword = &allowShowPassword
	return r
}

func (r ApiStagesPasswordListRequest) ConfigureFlow(configureFlow string) ApiStagesPasswordListRequest {
	r.configureFlow = &configureFlow
	return r
}

func (r ApiStagesPasswordListRequest) FailedAttemptsBeforeCancel(failedAttemptsBeforeCancel int32) ApiStagesPasswordListRequest {
	r.failedAttemptsBeforeCancel = &failedAttemptsBeforeCancel
	return r
}

func (r ApiStagesPasswordListRequest) Name(name string) ApiStagesPasswordListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiStagesPasswordListRequest) Ordering(ordering string) ApiStagesPasswordListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiStagesPasswordListRequest) Page(page int32) ApiStagesPasswordListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiStagesPasswordListRequest) PageSize(pageSize int32) ApiStagesPasswordListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiStagesPasswordListRequest) Search(search string) ApiStagesPasswordListRequest {
	r.search = &search
	return r
}

func (r ApiStagesPasswordListRequest) Execute() (*PaginatedPasswordStageList, *http.Response, error) {
	return r.ApiService.StagesPasswordListExecute(r)
}

/*
StagesPasswordList Method for StagesPasswordList

PasswordStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesPasswordListRequest
*/
func (a *StagesAPIService) StagesPasswordList(ctx context.Context) ApiStagesPasswordListRequest {
	return ApiStagesPasswordListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedPasswordStageList
func (a *StagesAPIService) StagesPasswordListExecute(r ApiStagesPasswordListRequest) (*PaginatedPasswordStageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedPasswordStageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesPasswordList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/password/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowShowPassword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_show_password", r.allowShowPassword, "form", "")
	}
	if r.configureFlow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "configure_flow", r.configureFlow, "form", "")
	}
	if r.failedAttemptsBeforeCancel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "failed_attempts_before_cancel", r.failedAttemptsBeforeCancel, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesPasswordPartialUpdateRequest struct {
	ctx                         context.Context
	ApiService                  *StagesAPIService
	stageUuid                   string
	patchedPasswordStageRequest *PatchedPasswordStageRequest
}

func (r ApiStagesPasswordPartialUpdateRequest) PatchedPasswordStageRequest(patchedPasswordStageRequest PatchedPasswordStageRequest) ApiStagesPasswordPartialUpdateRequest {
	r.patchedPasswordStageRequest = &patchedPasswordStageRequest
	return r
}

func (r ApiStagesPasswordPartialUpdateRequest) Execute() (*PasswordStage, *http.Response, error) {
	return r.ApiService.StagesPasswordPartialUpdateExecute(r)
}

/*
StagesPasswordPartialUpdate Method for StagesPasswordPartialUpdate

PasswordStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Password Stage.
	@return ApiStagesPasswordPartialUpdateRequest
*/
func (a *StagesAPIService) StagesPasswordPartialUpdate(ctx context.Context, stageUuid string) ApiStagesPasswordPartialUpdateRequest {
	return ApiStagesPasswordPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return PasswordStage
func (a *StagesAPIService) StagesPasswordPartialUpdateExecute(r ApiStagesPasswordPartialUpdateRequest) (*PasswordStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PasswordStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesPasswordPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/password/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedPasswordStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesPasswordRetrieveRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesPasswordRetrieveRequest) Execute() (*PasswordStage, *http.Response, error) {
	return r.ApiService.StagesPasswordRetrieveExecute(r)
}

/*
StagesPasswordRetrieve Method for StagesPasswordRetrieve

PasswordStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Password Stage.
	@return ApiStagesPasswordRetrieveRequest
*/
func (a *StagesAPIService) StagesPasswordRetrieve(ctx context.Context, stageUuid string) ApiStagesPasswordRetrieveRequest {
	return ApiStagesPasswordRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return PasswordStage
func (a *StagesAPIService) StagesPasswordRetrieveExecute(r ApiStagesPasswordRetrieveRequest) (*PasswordStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PasswordStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesPasswordRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/password/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesPasswordUpdateRequest struct {
	ctx                  context.Context
	ApiService           *StagesAPIService
	stageUuid            string
	passwordStageRequest *PasswordStageRequest
}

func (r ApiStagesPasswordUpdateRequest) PasswordStageRequest(passwordStageRequest PasswordStageRequest) ApiStagesPasswordUpdateRequest {
	r.passwordStageRequest = &passwordStageRequest
	return r
}

func (r ApiStagesPasswordUpdateRequest) Execute() (*PasswordStage, *http.Response, error) {
	return r.ApiService.StagesPasswordUpdateExecute(r)
}

/*
StagesPasswordUpdate Method for StagesPasswordUpdate

PasswordStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Password Stage.
	@return ApiStagesPasswordUpdateRequest
*/
func (a *StagesAPIService) StagesPasswordUpdate(ctx context.Context, stageUuid string) ApiStagesPasswordUpdateRequest {
	return ApiStagesPasswordUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return PasswordStage
func (a *StagesAPIService) StagesPasswordUpdateExecute(r ApiStagesPasswordUpdateRequest) (*PasswordStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PasswordStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesPasswordUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/password/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.passwordStageRequest == nil {
		return localVarReturnValue, nil, reportError("passwordStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.passwordStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesPasswordUsedByListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesPasswordUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.StagesPasswordUsedByListExecute(r)
}

/*
StagesPasswordUsedByList Method for StagesPasswordUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Password Stage.
	@return ApiStagesPasswordUsedByListRequest
*/
func (a *StagesAPIService) StagesPasswordUsedByList(ctx context.Context, stageUuid string) ApiStagesPasswordUsedByListRequest {
	return ApiStagesPasswordUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *StagesAPIService) StagesPasswordUsedByListExecute(r ApiStagesPasswordUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesPasswordUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/password/{stage_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesPromptPromptsCreateRequest struct {
	ctx           context.Context
	ApiService    *StagesAPIService
	promptRequest *PromptRequest
}

func (r ApiStagesPromptPromptsCreateRequest) PromptRequest(promptRequest PromptRequest) ApiStagesPromptPromptsCreateRequest {
	r.promptRequest = &promptRequest
	return r
}

func (r ApiStagesPromptPromptsCreateRequest) Execute() (*Prompt, *http.Response, error) {
	return r.ApiService.StagesPromptPromptsCreateExecute(r)
}

/*
StagesPromptPromptsCreate Method for StagesPromptPromptsCreate

Prompt Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesPromptPromptsCreateRequest
*/
func (a *StagesAPIService) StagesPromptPromptsCreate(ctx context.Context) ApiStagesPromptPromptsCreateRequest {
	return ApiStagesPromptPromptsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Prompt
func (a *StagesAPIService) StagesPromptPromptsCreateExecute(r ApiStagesPromptPromptsCreateRequest) (*Prompt, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Prompt
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesPromptPromptsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/prompt/prompts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.promptRequest == nil {
		return localVarReturnValue, nil, reportError("promptRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.promptRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesPromptPromptsDestroyRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	promptUuid string
}

func (r ApiStagesPromptPromptsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.StagesPromptPromptsDestroyExecute(r)
}

/*
StagesPromptPromptsDestroy Method for StagesPromptPromptsDestroy

Prompt Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param promptUuid A UUID string identifying this Prompt.
	@return ApiStagesPromptPromptsDestroyRequest
*/
func (a *StagesAPIService) StagesPromptPromptsDestroy(ctx context.Context, promptUuid string) ApiStagesPromptPromptsDestroyRequest {
	return ApiStagesPromptPromptsDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		promptUuid: promptUuid,
	}
}

// Execute executes the request
func (a *StagesAPIService) StagesPromptPromptsDestroyExecute(r ApiStagesPromptPromptsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesPromptPromptsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/prompt/prompts/{prompt_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"prompt_uuid"+"}", url.PathEscape(parameterValueToString(r.promptUuid, "promptUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStagesPromptPromptsListRequest struct {
	ctx         context.Context
	ApiService  *StagesAPIService
	fieldKey    *string
	label       *string
	name        *string
	ordering    *string
	page        *int32
	pageSize    *int32
	placeholder *string
	search      *string
	type_       *string
}

func (r ApiStagesPromptPromptsListRequest) FieldKey(fieldKey string) ApiStagesPromptPromptsListRequest {
	r.fieldKey = &fieldKey
	return r
}

func (r ApiStagesPromptPromptsListRequest) Label(label string) ApiStagesPromptPromptsListRequest {
	r.label = &label
	return r
}

func (r ApiStagesPromptPromptsListRequest) Name(name string) ApiStagesPromptPromptsListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiStagesPromptPromptsListRequest) Ordering(ordering string) ApiStagesPromptPromptsListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiStagesPromptPromptsListRequest) Page(page int32) ApiStagesPromptPromptsListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiStagesPromptPromptsListRequest) PageSize(pageSize int32) ApiStagesPromptPromptsListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiStagesPromptPromptsListRequest) Placeholder(placeholder string) ApiStagesPromptPromptsListRequest {
	r.placeholder = &placeholder
	return r
}

// A search term.
func (r ApiStagesPromptPromptsListRequest) Search(search string) ApiStagesPromptPromptsListRequest {
	r.search = &search
	return r
}

func (r ApiStagesPromptPromptsListRequest) Type_(type_ string) ApiStagesPromptPromptsListRequest {
	r.type_ = &type_
	return r
}

func (r ApiStagesPromptPromptsListRequest) Execute() (*PaginatedPromptList, *http.Response, error) {
	return r.ApiService.StagesPromptPromptsListExecute(r)
}

/*
StagesPromptPromptsList Method for StagesPromptPromptsList

Prompt Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesPromptPromptsListRequest
*/
func (a *StagesAPIService) StagesPromptPromptsList(ctx context.Context) ApiStagesPromptPromptsListRequest {
	return ApiStagesPromptPromptsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedPromptList
func (a *StagesAPIService) StagesPromptPromptsListExecute(r ApiStagesPromptPromptsListRequest) (*PaginatedPromptList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedPromptList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesPromptPromptsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/prompt/prompts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "field_key", r.fieldKey, "form", "")
	}
	if r.label != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label", r.label, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.placeholder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "placeholder", r.placeholder, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesPromptPromptsPartialUpdateRequest struct {
	ctx                  context.Context
	ApiService           *StagesAPIService
	promptUuid           string
	patchedPromptRequest *PatchedPromptRequest
}

func (r ApiStagesPromptPromptsPartialUpdateRequest) PatchedPromptRequest(patchedPromptRequest PatchedPromptRequest) ApiStagesPromptPromptsPartialUpdateRequest {
	r.patchedPromptRequest = &patchedPromptRequest
	return r
}

func (r ApiStagesPromptPromptsPartialUpdateRequest) Execute() (*Prompt, *http.Response, error) {
	return r.ApiService.StagesPromptPromptsPartialUpdateExecute(r)
}

/*
StagesPromptPromptsPartialUpdate Method for StagesPromptPromptsPartialUpdate

Prompt Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param promptUuid A UUID string identifying this Prompt.
	@return ApiStagesPromptPromptsPartialUpdateRequest
*/
func (a *StagesAPIService) StagesPromptPromptsPartialUpdate(ctx context.Context, promptUuid string) ApiStagesPromptPromptsPartialUpdateRequest {
	return ApiStagesPromptPromptsPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		promptUuid: promptUuid,
	}
}

// Execute executes the request
//
//	@return Prompt
func (a *StagesAPIService) StagesPromptPromptsPartialUpdateExecute(r ApiStagesPromptPromptsPartialUpdateRequest) (*Prompt, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Prompt
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesPromptPromptsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/prompt/prompts/{prompt_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"prompt_uuid"+"}", url.PathEscape(parameterValueToString(r.promptUuid, "promptUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedPromptRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesPromptPromptsPreviewCreateRequest struct {
	ctx           context.Context
	ApiService    *StagesAPIService
	promptRequest *PromptRequest
}

func (r ApiStagesPromptPromptsPreviewCreateRequest) PromptRequest(promptRequest PromptRequest) ApiStagesPromptPromptsPreviewCreateRequest {
	r.promptRequest = &promptRequest
	return r
}

func (r ApiStagesPromptPromptsPreviewCreateRequest) Execute() (*PromptChallenge, *http.Response, error) {
	return r.ApiService.StagesPromptPromptsPreviewCreateExecute(r)
}

/*
StagesPromptPromptsPreviewCreate Method for StagesPromptPromptsPreviewCreate

Preview a prompt as a challenge, just like a flow would receive

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesPromptPromptsPreviewCreateRequest
*/
func (a *StagesAPIService) StagesPromptPromptsPreviewCreate(ctx context.Context) ApiStagesPromptPromptsPreviewCreateRequest {
	return ApiStagesPromptPromptsPreviewCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PromptChallenge
func (a *StagesAPIService) StagesPromptPromptsPreviewCreateExecute(r ApiStagesPromptPromptsPreviewCreateRequest) (*PromptChallenge, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PromptChallenge
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesPromptPromptsPreviewCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/prompt/prompts/preview/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.promptRequest == nil {
		return localVarReturnValue, nil, reportError("promptRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.promptRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesPromptPromptsRetrieveRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	promptUuid string
}

func (r ApiStagesPromptPromptsRetrieveRequest) Execute() (*Prompt, *http.Response, error) {
	return r.ApiService.StagesPromptPromptsRetrieveExecute(r)
}

/*
StagesPromptPromptsRetrieve Method for StagesPromptPromptsRetrieve

Prompt Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param promptUuid A UUID string identifying this Prompt.
	@return ApiStagesPromptPromptsRetrieveRequest
*/
func (a *StagesAPIService) StagesPromptPromptsRetrieve(ctx context.Context, promptUuid string) ApiStagesPromptPromptsRetrieveRequest {
	return ApiStagesPromptPromptsRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		promptUuid: promptUuid,
	}
}

// Execute executes the request
//
//	@return Prompt
func (a *StagesAPIService) StagesPromptPromptsRetrieveExecute(r ApiStagesPromptPromptsRetrieveRequest) (*Prompt, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Prompt
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesPromptPromptsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/prompt/prompts/{prompt_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"prompt_uuid"+"}", url.PathEscape(parameterValueToString(r.promptUuid, "promptUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesPromptPromptsUpdateRequest struct {
	ctx           context.Context
	ApiService    *StagesAPIService
	promptUuid    string
	promptRequest *PromptRequest
}

func (r ApiStagesPromptPromptsUpdateRequest) PromptRequest(promptRequest PromptRequest) ApiStagesPromptPromptsUpdateRequest {
	r.promptRequest = &promptRequest
	return r
}

func (r ApiStagesPromptPromptsUpdateRequest) Execute() (*Prompt, *http.Response, error) {
	return r.ApiService.StagesPromptPromptsUpdateExecute(r)
}

/*
StagesPromptPromptsUpdate Method for StagesPromptPromptsUpdate

Prompt Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param promptUuid A UUID string identifying this Prompt.
	@return ApiStagesPromptPromptsUpdateRequest
*/
func (a *StagesAPIService) StagesPromptPromptsUpdate(ctx context.Context, promptUuid string) ApiStagesPromptPromptsUpdateRequest {
	return ApiStagesPromptPromptsUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		promptUuid: promptUuid,
	}
}

// Execute executes the request
//
//	@return Prompt
func (a *StagesAPIService) StagesPromptPromptsUpdateExecute(r ApiStagesPromptPromptsUpdateRequest) (*Prompt, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Prompt
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesPromptPromptsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/prompt/prompts/{prompt_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"prompt_uuid"+"}", url.PathEscape(parameterValueToString(r.promptUuid, "promptUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.promptRequest == nil {
		return localVarReturnValue, nil, reportError("promptRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.promptRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesPromptPromptsUsedByListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	promptUuid string
}

func (r ApiStagesPromptPromptsUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.StagesPromptPromptsUsedByListExecute(r)
}

/*
StagesPromptPromptsUsedByList Method for StagesPromptPromptsUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param promptUuid A UUID string identifying this Prompt.
	@return ApiStagesPromptPromptsUsedByListRequest
*/
func (a *StagesAPIService) StagesPromptPromptsUsedByList(ctx context.Context, promptUuid string) ApiStagesPromptPromptsUsedByListRequest {
	return ApiStagesPromptPromptsUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		promptUuid: promptUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *StagesAPIService) StagesPromptPromptsUsedByListExecute(r ApiStagesPromptPromptsUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesPromptPromptsUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/prompt/prompts/{prompt_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"prompt_uuid"+"}", url.PathEscape(parameterValueToString(r.promptUuid, "promptUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesPromptStagesCreateRequest struct {
	ctx                context.Context
	ApiService         *StagesAPIService
	promptStageRequest *PromptStageRequest
}

func (r ApiStagesPromptStagesCreateRequest) PromptStageRequest(promptStageRequest PromptStageRequest) ApiStagesPromptStagesCreateRequest {
	r.promptStageRequest = &promptStageRequest
	return r
}

func (r ApiStagesPromptStagesCreateRequest) Execute() (*PromptStage, *http.Response, error) {
	return r.ApiService.StagesPromptStagesCreateExecute(r)
}

/*
StagesPromptStagesCreate Method for StagesPromptStagesCreate

PromptStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesPromptStagesCreateRequest
*/
func (a *StagesAPIService) StagesPromptStagesCreate(ctx context.Context) ApiStagesPromptStagesCreateRequest {
	return ApiStagesPromptStagesCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PromptStage
func (a *StagesAPIService) StagesPromptStagesCreateExecute(r ApiStagesPromptStagesCreateRequest) (*PromptStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PromptStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesPromptStagesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/prompt/stages/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.promptStageRequest == nil {
		return localVarReturnValue, nil, reportError("promptStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.promptStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesPromptStagesDestroyRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesPromptStagesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.StagesPromptStagesDestroyExecute(r)
}

/*
StagesPromptStagesDestroy Method for StagesPromptStagesDestroy

PromptStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Prompt Stage.
	@return ApiStagesPromptStagesDestroyRequest
*/
func (a *StagesAPIService) StagesPromptStagesDestroy(ctx context.Context, stageUuid string) ApiStagesPromptStagesDestroyRequest {
	return ApiStagesPromptStagesDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
func (a *StagesAPIService) StagesPromptStagesDestroyExecute(r ApiStagesPromptStagesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesPromptStagesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/prompt/stages/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStagesPromptStagesListRequest struct {
	ctx                context.Context
	ApiService         *StagesAPIService
	fields             *[]string
	name               *string
	ordering           *string
	page               *int32
	pageSize           *int32
	search             *string
	stageUuid          *string
	validationPolicies *[]string
}

func (r ApiStagesPromptStagesListRequest) Fields(fields []string) ApiStagesPromptStagesListRequest {
	r.fields = &fields
	return r
}

func (r ApiStagesPromptStagesListRequest) Name(name string) ApiStagesPromptStagesListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiStagesPromptStagesListRequest) Ordering(ordering string) ApiStagesPromptStagesListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiStagesPromptStagesListRequest) Page(page int32) ApiStagesPromptStagesListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiStagesPromptStagesListRequest) PageSize(pageSize int32) ApiStagesPromptStagesListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiStagesPromptStagesListRequest) Search(search string) ApiStagesPromptStagesListRequest {
	r.search = &search
	return r
}

func (r ApiStagesPromptStagesListRequest) StageUuid(stageUuid string) ApiStagesPromptStagesListRequest {
	r.stageUuid = &stageUuid
	return r
}

func (r ApiStagesPromptStagesListRequest) ValidationPolicies(validationPolicies []string) ApiStagesPromptStagesListRequest {
	r.validationPolicies = &validationPolicies
	return r
}

func (r ApiStagesPromptStagesListRequest) Execute() (*PaginatedPromptStageList, *http.Response, error) {
	return r.ApiService.StagesPromptStagesListExecute(r)
}

/*
StagesPromptStagesList Method for StagesPromptStagesList

PromptStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesPromptStagesListRequest
*/
func (a *StagesAPIService) StagesPromptStagesList(ctx context.Context) ApiStagesPromptStagesListRequest {
	return ApiStagesPromptStagesListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedPromptStageList
func (a *StagesAPIService) StagesPromptStagesListExecute(r ApiStagesPromptStagesListRequest) (*PaginatedPromptStageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedPromptStageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesPromptStagesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/prompt/stages/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "form", "multi")
		}
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.stageUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stage_uuid", r.stageUuid, "form", "")
	}
	if r.validationPolicies != nil {
		t := *r.validationPolicies
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "validation_policies", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "validation_policies", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesPromptStagesPartialUpdateRequest struct {
	ctx                       context.Context
	ApiService                *StagesAPIService
	stageUuid                 string
	patchedPromptStageRequest *PatchedPromptStageRequest
}

func (r ApiStagesPromptStagesPartialUpdateRequest) PatchedPromptStageRequest(patchedPromptStageRequest PatchedPromptStageRequest) ApiStagesPromptStagesPartialUpdateRequest {
	r.patchedPromptStageRequest = &patchedPromptStageRequest
	return r
}

func (r ApiStagesPromptStagesPartialUpdateRequest) Execute() (*PromptStage, *http.Response, error) {
	return r.ApiService.StagesPromptStagesPartialUpdateExecute(r)
}

/*
StagesPromptStagesPartialUpdate Method for StagesPromptStagesPartialUpdate

PromptStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Prompt Stage.
	@return ApiStagesPromptStagesPartialUpdateRequest
*/
func (a *StagesAPIService) StagesPromptStagesPartialUpdate(ctx context.Context, stageUuid string) ApiStagesPromptStagesPartialUpdateRequest {
	return ApiStagesPromptStagesPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return PromptStage
func (a *StagesAPIService) StagesPromptStagesPartialUpdateExecute(r ApiStagesPromptStagesPartialUpdateRequest) (*PromptStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PromptStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesPromptStagesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/prompt/stages/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedPromptStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesPromptStagesRetrieveRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesPromptStagesRetrieveRequest) Execute() (*PromptStage, *http.Response, error) {
	return r.ApiService.StagesPromptStagesRetrieveExecute(r)
}

/*
StagesPromptStagesRetrieve Method for StagesPromptStagesRetrieve

PromptStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Prompt Stage.
	@return ApiStagesPromptStagesRetrieveRequest
*/
func (a *StagesAPIService) StagesPromptStagesRetrieve(ctx context.Context, stageUuid string) ApiStagesPromptStagesRetrieveRequest {
	return ApiStagesPromptStagesRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return PromptStage
func (a *StagesAPIService) StagesPromptStagesRetrieveExecute(r ApiStagesPromptStagesRetrieveRequest) (*PromptStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PromptStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesPromptStagesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/prompt/stages/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesPromptStagesUpdateRequest struct {
	ctx                context.Context
	ApiService         *StagesAPIService
	stageUuid          string
	promptStageRequest *PromptStageRequest
}

func (r ApiStagesPromptStagesUpdateRequest) PromptStageRequest(promptStageRequest PromptStageRequest) ApiStagesPromptStagesUpdateRequest {
	r.promptStageRequest = &promptStageRequest
	return r
}

func (r ApiStagesPromptStagesUpdateRequest) Execute() (*PromptStage, *http.Response, error) {
	return r.ApiService.StagesPromptStagesUpdateExecute(r)
}

/*
StagesPromptStagesUpdate Method for StagesPromptStagesUpdate

PromptStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Prompt Stage.
	@return ApiStagesPromptStagesUpdateRequest
*/
func (a *StagesAPIService) StagesPromptStagesUpdate(ctx context.Context, stageUuid string) ApiStagesPromptStagesUpdateRequest {
	return ApiStagesPromptStagesUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return PromptStage
func (a *StagesAPIService) StagesPromptStagesUpdateExecute(r ApiStagesPromptStagesUpdateRequest) (*PromptStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PromptStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesPromptStagesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/prompt/stages/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.promptStageRequest == nil {
		return localVarReturnValue, nil, reportError("promptStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.promptStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesPromptStagesUsedByListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesPromptStagesUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.StagesPromptStagesUsedByListExecute(r)
}

/*
StagesPromptStagesUsedByList Method for StagesPromptStagesUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Prompt Stage.
	@return ApiStagesPromptStagesUsedByListRequest
*/
func (a *StagesAPIService) StagesPromptStagesUsedByList(ctx context.Context, stageUuid string) ApiStagesPromptStagesUsedByListRequest {
	return ApiStagesPromptStagesUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *StagesAPIService) StagesPromptStagesUsedByListExecute(r ApiStagesPromptStagesUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesPromptStagesUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/prompt/stages/{stage_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesRedirectCreateRequest struct {
	ctx                  context.Context
	ApiService           *StagesAPIService
	redirectStageRequest *RedirectStageRequest
}

func (r ApiStagesRedirectCreateRequest) RedirectStageRequest(redirectStageRequest RedirectStageRequest) ApiStagesRedirectCreateRequest {
	r.redirectStageRequest = &redirectStageRequest
	return r
}

func (r ApiStagesRedirectCreateRequest) Execute() (*RedirectStage, *http.Response, error) {
	return r.ApiService.StagesRedirectCreateExecute(r)
}

/*
StagesRedirectCreate Method for StagesRedirectCreate

RedirectStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesRedirectCreateRequest
*/
func (a *StagesAPIService) StagesRedirectCreate(ctx context.Context) ApiStagesRedirectCreateRequest {
	return ApiStagesRedirectCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return RedirectStage
func (a *StagesAPIService) StagesRedirectCreateExecute(r ApiStagesRedirectCreateRequest) (*RedirectStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RedirectStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesRedirectCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/redirect/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.redirectStageRequest == nil {
		return localVarReturnValue, nil, reportError("redirectStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.redirectStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesRedirectDestroyRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesRedirectDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.StagesRedirectDestroyExecute(r)
}

/*
StagesRedirectDestroy Method for StagesRedirectDestroy

RedirectStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Redirect Stage.
	@return ApiStagesRedirectDestroyRequest
*/
func (a *StagesAPIService) StagesRedirectDestroy(ctx context.Context, stageUuid string) ApiStagesRedirectDestroyRequest {
	return ApiStagesRedirectDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
func (a *StagesAPIService) StagesRedirectDestroyExecute(r ApiStagesRedirectDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesRedirectDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/redirect/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStagesRedirectListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	name       *string
	ordering   *string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiStagesRedirectListRequest) Name(name string) ApiStagesRedirectListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiStagesRedirectListRequest) Ordering(ordering string) ApiStagesRedirectListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiStagesRedirectListRequest) Page(page int32) ApiStagesRedirectListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiStagesRedirectListRequest) PageSize(pageSize int32) ApiStagesRedirectListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiStagesRedirectListRequest) Search(search string) ApiStagesRedirectListRequest {
	r.search = &search
	return r
}

func (r ApiStagesRedirectListRequest) Execute() (*PaginatedRedirectStageList, *http.Response, error) {
	return r.ApiService.StagesRedirectListExecute(r)
}

/*
StagesRedirectList Method for StagesRedirectList

RedirectStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesRedirectListRequest
*/
func (a *StagesAPIService) StagesRedirectList(ctx context.Context) ApiStagesRedirectListRequest {
	return ApiStagesRedirectListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedRedirectStageList
func (a *StagesAPIService) StagesRedirectListExecute(r ApiStagesRedirectListRequest) (*PaginatedRedirectStageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedRedirectStageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesRedirectList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/redirect/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesRedirectPartialUpdateRequest struct {
	ctx                         context.Context
	ApiService                  *StagesAPIService
	stageUuid                   string
	patchedRedirectStageRequest *PatchedRedirectStageRequest
}

func (r ApiStagesRedirectPartialUpdateRequest) PatchedRedirectStageRequest(patchedRedirectStageRequest PatchedRedirectStageRequest) ApiStagesRedirectPartialUpdateRequest {
	r.patchedRedirectStageRequest = &patchedRedirectStageRequest
	return r
}

func (r ApiStagesRedirectPartialUpdateRequest) Execute() (*RedirectStage, *http.Response, error) {
	return r.ApiService.StagesRedirectPartialUpdateExecute(r)
}

/*
StagesRedirectPartialUpdate Method for StagesRedirectPartialUpdate

RedirectStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Redirect Stage.
	@return ApiStagesRedirectPartialUpdateRequest
*/
func (a *StagesAPIService) StagesRedirectPartialUpdate(ctx context.Context, stageUuid string) ApiStagesRedirectPartialUpdateRequest {
	return ApiStagesRedirectPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return RedirectStage
func (a *StagesAPIService) StagesRedirectPartialUpdateExecute(r ApiStagesRedirectPartialUpdateRequest) (*RedirectStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RedirectStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesRedirectPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/redirect/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedRedirectStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesRedirectRetrieveRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesRedirectRetrieveRequest) Execute() (*RedirectStage, *http.Response, error) {
	return r.ApiService.StagesRedirectRetrieveExecute(r)
}

/*
StagesRedirectRetrieve Method for StagesRedirectRetrieve

RedirectStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Redirect Stage.
	@return ApiStagesRedirectRetrieveRequest
*/
func (a *StagesAPIService) StagesRedirectRetrieve(ctx context.Context, stageUuid string) ApiStagesRedirectRetrieveRequest {
	return ApiStagesRedirectRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return RedirectStage
func (a *StagesAPIService) StagesRedirectRetrieveExecute(r ApiStagesRedirectRetrieveRequest) (*RedirectStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RedirectStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesRedirectRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/redirect/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesRedirectUpdateRequest struct {
	ctx                  context.Context
	ApiService           *StagesAPIService
	stageUuid            string
	redirectStageRequest *RedirectStageRequest
}

func (r ApiStagesRedirectUpdateRequest) RedirectStageRequest(redirectStageRequest RedirectStageRequest) ApiStagesRedirectUpdateRequest {
	r.redirectStageRequest = &redirectStageRequest
	return r
}

func (r ApiStagesRedirectUpdateRequest) Execute() (*RedirectStage, *http.Response, error) {
	return r.ApiService.StagesRedirectUpdateExecute(r)
}

/*
StagesRedirectUpdate Method for StagesRedirectUpdate

RedirectStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Redirect Stage.
	@return ApiStagesRedirectUpdateRequest
*/
func (a *StagesAPIService) StagesRedirectUpdate(ctx context.Context, stageUuid string) ApiStagesRedirectUpdateRequest {
	return ApiStagesRedirectUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return RedirectStage
func (a *StagesAPIService) StagesRedirectUpdateExecute(r ApiStagesRedirectUpdateRequest) (*RedirectStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RedirectStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesRedirectUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/redirect/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.redirectStageRequest == nil {
		return localVarReturnValue, nil, reportError("redirectStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.redirectStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesRedirectUsedByListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesRedirectUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.StagesRedirectUsedByListExecute(r)
}

/*
StagesRedirectUsedByList Method for StagesRedirectUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Redirect Stage.
	@return ApiStagesRedirectUsedByListRequest
*/
func (a *StagesAPIService) StagesRedirectUsedByList(ctx context.Context, stageUuid string) ApiStagesRedirectUsedByListRequest {
	return ApiStagesRedirectUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *StagesAPIService) StagesRedirectUsedByListExecute(r ApiStagesRedirectUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesRedirectUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/redirect/{stage_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesSourceCreateRequest struct {
	ctx                context.Context
	ApiService         *StagesAPIService
	sourceStageRequest *SourceStageRequest
}

func (r ApiStagesSourceCreateRequest) SourceStageRequest(sourceStageRequest SourceStageRequest) ApiStagesSourceCreateRequest {
	r.sourceStageRequest = &sourceStageRequest
	return r
}

func (r ApiStagesSourceCreateRequest) Execute() (*SourceStage, *http.Response, error) {
	return r.ApiService.StagesSourceCreateExecute(r)
}

/*
StagesSourceCreate Method for StagesSourceCreate

SourceStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesSourceCreateRequest
*/
func (a *StagesAPIService) StagesSourceCreate(ctx context.Context) ApiStagesSourceCreateRequest {
	return ApiStagesSourceCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SourceStage
func (a *StagesAPIService) StagesSourceCreateExecute(r ApiStagesSourceCreateRequest) (*SourceStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SourceStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesSourceCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/source/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sourceStageRequest == nil {
		return localVarReturnValue, nil, reportError("sourceStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sourceStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesSourceDestroyRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesSourceDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.StagesSourceDestroyExecute(r)
}

/*
StagesSourceDestroy Method for StagesSourceDestroy

SourceStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Source Stage.
	@return ApiStagesSourceDestroyRequest
*/
func (a *StagesAPIService) StagesSourceDestroy(ctx context.Context, stageUuid string) ApiStagesSourceDestroyRequest {
	return ApiStagesSourceDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
func (a *StagesAPIService) StagesSourceDestroyExecute(r ApiStagesSourceDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesSourceDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/source/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStagesSourceListRequest struct {
	ctx           context.Context
	ApiService    *StagesAPIService
	name          *string
	ordering      *string
	page          *int32
	pageSize      *int32
	resumeTimeout *string
	search        *string
	source        *string
	stageUuid     *string
}

func (r ApiStagesSourceListRequest) Name(name string) ApiStagesSourceListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiStagesSourceListRequest) Ordering(ordering string) ApiStagesSourceListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiStagesSourceListRequest) Page(page int32) ApiStagesSourceListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiStagesSourceListRequest) PageSize(pageSize int32) ApiStagesSourceListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiStagesSourceListRequest) ResumeTimeout(resumeTimeout string) ApiStagesSourceListRequest {
	r.resumeTimeout = &resumeTimeout
	return r
}

// A search term.
func (r ApiStagesSourceListRequest) Search(search string) ApiStagesSourceListRequest {
	r.search = &search
	return r
}

func (r ApiStagesSourceListRequest) Source(source string) ApiStagesSourceListRequest {
	r.source = &source
	return r
}

func (r ApiStagesSourceListRequest) StageUuid(stageUuid string) ApiStagesSourceListRequest {
	r.stageUuid = &stageUuid
	return r
}

func (r ApiStagesSourceListRequest) Execute() (*PaginatedSourceStageList, *http.Response, error) {
	return r.ApiService.StagesSourceListExecute(r)
}

/*
StagesSourceList Method for StagesSourceList

SourceStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesSourceListRequest
*/
func (a *StagesAPIService) StagesSourceList(ctx context.Context) ApiStagesSourceListRequest {
	return ApiStagesSourceListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedSourceStageList
func (a *StagesAPIService) StagesSourceListExecute(r ApiStagesSourceListRequest) (*PaginatedSourceStageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedSourceStageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesSourceList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/source/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.resumeTimeout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resume_timeout", r.resumeTimeout, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.source != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "source", r.source, "form", "")
	}
	if r.stageUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stage_uuid", r.stageUuid, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesSourcePartialUpdateRequest struct {
	ctx                       context.Context
	ApiService                *StagesAPIService
	stageUuid                 string
	patchedSourceStageRequest *PatchedSourceStageRequest
}

func (r ApiStagesSourcePartialUpdateRequest) PatchedSourceStageRequest(patchedSourceStageRequest PatchedSourceStageRequest) ApiStagesSourcePartialUpdateRequest {
	r.patchedSourceStageRequest = &patchedSourceStageRequest
	return r
}

func (r ApiStagesSourcePartialUpdateRequest) Execute() (*SourceStage, *http.Response, error) {
	return r.ApiService.StagesSourcePartialUpdateExecute(r)
}

/*
StagesSourcePartialUpdate Method for StagesSourcePartialUpdate

SourceStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Source Stage.
	@return ApiStagesSourcePartialUpdateRequest
*/
func (a *StagesAPIService) StagesSourcePartialUpdate(ctx context.Context, stageUuid string) ApiStagesSourcePartialUpdateRequest {
	return ApiStagesSourcePartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return SourceStage
func (a *StagesAPIService) StagesSourcePartialUpdateExecute(r ApiStagesSourcePartialUpdateRequest) (*SourceStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SourceStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesSourcePartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/source/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedSourceStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesSourceRetrieveRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesSourceRetrieveRequest) Execute() (*SourceStage, *http.Response, error) {
	return r.ApiService.StagesSourceRetrieveExecute(r)
}

/*
StagesSourceRetrieve Method for StagesSourceRetrieve

SourceStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Source Stage.
	@return ApiStagesSourceRetrieveRequest
*/
func (a *StagesAPIService) StagesSourceRetrieve(ctx context.Context, stageUuid string) ApiStagesSourceRetrieveRequest {
	return ApiStagesSourceRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return SourceStage
func (a *StagesAPIService) StagesSourceRetrieveExecute(r ApiStagesSourceRetrieveRequest) (*SourceStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SourceStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesSourceRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/source/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesSourceUpdateRequest struct {
	ctx                context.Context
	ApiService         *StagesAPIService
	stageUuid          string
	sourceStageRequest *SourceStageRequest
}

func (r ApiStagesSourceUpdateRequest) SourceStageRequest(sourceStageRequest SourceStageRequest) ApiStagesSourceUpdateRequest {
	r.sourceStageRequest = &sourceStageRequest
	return r
}

func (r ApiStagesSourceUpdateRequest) Execute() (*SourceStage, *http.Response, error) {
	return r.ApiService.StagesSourceUpdateExecute(r)
}

/*
StagesSourceUpdate Method for StagesSourceUpdate

SourceStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Source Stage.
	@return ApiStagesSourceUpdateRequest
*/
func (a *StagesAPIService) StagesSourceUpdate(ctx context.Context, stageUuid string) ApiStagesSourceUpdateRequest {
	return ApiStagesSourceUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return SourceStage
func (a *StagesAPIService) StagesSourceUpdateExecute(r ApiStagesSourceUpdateRequest) (*SourceStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SourceStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesSourceUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/source/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sourceStageRequest == nil {
		return localVarReturnValue, nil, reportError("sourceStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sourceStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesSourceUsedByListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesSourceUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.StagesSourceUsedByListExecute(r)
}

/*
StagesSourceUsedByList Method for StagesSourceUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this Source Stage.
	@return ApiStagesSourceUsedByListRequest
*/
func (a *StagesAPIService) StagesSourceUsedByList(ctx context.Context, stageUuid string) ApiStagesSourceUsedByListRequest {
	return ApiStagesSourceUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *StagesAPIService) StagesSourceUsedByListExecute(r ApiStagesSourceUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesSourceUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/source/{stage_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesUserDeleteCreateRequest struct {
	ctx                    context.Context
	ApiService             *StagesAPIService
	userDeleteStageRequest *UserDeleteStageRequest
}

func (r ApiStagesUserDeleteCreateRequest) UserDeleteStageRequest(userDeleteStageRequest UserDeleteStageRequest) ApiStagesUserDeleteCreateRequest {
	r.userDeleteStageRequest = &userDeleteStageRequest
	return r
}

func (r ApiStagesUserDeleteCreateRequest) Execute() (*UserDeleteStage, *http.Response, error) {
	return r.ApiService.StagesUserDeleteCreateExecute(r)
}

/*
StagesUserDeleteCreate Method for StagesUserDeleteCreate

UserDeleteStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesUserDeleteCreateRequest
*/
func (a *StagesAPIService) StagesUserDeleteCreate(ctx context.Context) ApiStagesUserDeleteCreateRequest {
	return ApiStagesUserDeleteCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UserDeleteStage
func (a *StagesAPIService) StagesUserDeleteCreateExecute(r ApiStagesUserDeleteCreateRequest) (*UserDeleteStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserDeleteStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesUserDeleteCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/user_delete/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userDeleteStageRequest == nil {
		return localVarReturnValue, nil, reportError("userDeleteStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userDeleteStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesUserDeleteDestroyRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesUserDeleteDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.StagesUserDeleteDestroyExecute(r)
}

/*
StagesUserDeleteDestroy Method for StagesUserDeleteDestroy

UserDeleteStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this User Delete Stage.
	@return ApiStagesUserDeleteDestroyRequest
*/
func (a *StagesAPIService) StagesUserDeleteDestroy(ctx context.Context, stageUuid string) ApiStagesUserDeleteDestroyRequest {
	return ApiStagesUserDeleteDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
func (a *StagesAPIService) StagesUserDeleteDestroyExecute(r ApiStagesUserDeleteDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesUserDeleteDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/user_delete/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStagesUserDeleteListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	name       *string
	ordering   *string
	page       *int32
	pageSize   *int32
	search     *string
	stageUuid  *string
}

func (r ApiStagesUserDeleteListRequest) Name(name string) ApiStagesUserDeleteListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiStagesUserDeleteListRequest) Ordering(ordering string) ApiStagesUserDeleteListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiStagesUserDeleteListRequest) Page(page int32) ApiStagesUserDeleteListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiStagesUserDeleteListRequest) PageSize(pageSize int32) ApiStagesUserDeleteListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiStagesUserDeleteListRequest) Search(search string) ApiStagesUserDeleteListRequest {
	r.search = &search
	return r
}

func (r ApiStagesUserDeleteListRequest) StageUuid(stageUuid string) ApiStagesUserDeleteListRequest {
	r.stageUuid = &stageUuid
	return r
}

func (r ApiStagesUserDeleteListRequest) Execute() (*PaginatedUserDeleteStageList, *http.Response, error) {
	return r.ApiService.StagesUserDeleteListExecute(r)
}

/*
StagesUserDeleteList Method for StagesUserDeleteList

UserDeleteStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesUserDeleteListRequest
*/
func (a *StagesAPIService) StagesUserDeleteList(ctx context.Context) ApiStagesUserDeleteListRequest {
	return ApiStagesUserDeleteListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedUserDeleteStageList
func (a *StagesAPIService) StagesUserDeleteListExecute(r ApiStagesUserDeleteListRequest) (*PaginatedUserDeleteStageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedUserDeleteStageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesUserDeleteList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/user_delete/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.stageUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stage_uuid", r.stageUuid, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesUserDeletePartialUpdateRequest struct {
	ctx                           context.Context
	ApiService                    *StagesAPIService
	stageUuid                     string
	patchedUserDeleteStageRequest *PatchedUserDeleteStageRequest
}

func (r ApiStagesUserDeletePartialUpdateRequest) PatchedUserDeleteStageRequest(patchedUserDeleteStageRequest PatchedUserDeleteStageRequest) ApiStagesUserDeletePartialUpdateRequest {
	r.patchedUserDeleteStageRequest = &patchedUserDeleteStageRequest
	return r
}

func (r ApiStagesUserDeletePartialUpdateRequest) Execute() (*UserDeleteStage, *http.Response, error) {
	return r.ApiService.StagesUserDeletePartialUpdateExecute(r)
}

/*
StagesUserDeletePartialUpdate Method for StagesUserDeletePartialUpdate

UserDeleteStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this User Delete Stage.
	@return ApiStagesUserDeletePartialUpdateRequest
*/
func (a *StagesAPIService) StagesUserDeletePartialUpdate(ctx context.Context, stageUuid string) ApiStagesUserDeletePartialUpdateRequest {
	return ApiStagesUserDeletePartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return UserDeleteStage
func (a *StagesAPIService) StagesUserDeletePartialUpdateExecute(r ApiStagesUserDeletePartialUpdateRequest) (*UserDeleteStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserDeleteStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesUserDeletePartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/user_delete/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedUserDeleteStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesUserDeleteRetrieveRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesUserDeleteRetrieveRequest) Execute() (*UserDeleteStage, *http.Response, error) {
	return r.ApiService.StagesUserDeleteRetrieveExecute(r)
}

/*
StagesUserDeleteRetrieve Method for StagesUserDeleteRetrieve

UserDeleteStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this User Delete Stage.
	@return ApiStagesUserDeleteRetrieveRequest
*/
func (a *StagesAPIService) StagesUserDeleteRetrieve(ctx context.Context, stageUuid string) ApiStagesUserDeleteRetrieveRequest {
	return ApiStagesUserDeleteRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return UserDeleteStage
func (a *StagesAPIService) StagesUserDeleteRetrieveExecute(r ApiStagesUserDeleteRetrieveRequest) (*UserDeleteStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserDeleteStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesUserDeleteRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/user_delete/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesUserDeleteUpdateRequest struct {
	ctx                    context.Context
	ApiService             *StagesAPIService
	stageUuid              string
	userDeleteStageRequest *UserDeleteStageRequest
}

func (r ApiStagesUserDeleteUpdateRequest) UserDeleteStageRequest(userDeleteStageRequest UserDeleteStageRequest) ApiStagesUserDeleteUpdateRequest {
	r.userDeleteStageRequest = &userDeleteStageRequest
	return r
}

func (r ApiStagesUserDeleteUpdateRequest) Execute() (*UserDeleteStage, *http.Response, error) {
	return r.ApiService.StagesUserDeleteUpdateExecute(r)
}

/*
StagesUserDeleteUpdate Method for StagesUserDeleteUpdate

UserDeleteStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this User Delete Stage.
	@return ApiStagesUserDeleteUpdateRequest
*/
func (a *StagesAPIService) StagesUserDeleteUpdate(ctx context.Context, stageUuid string) ApiStagesUserDeleteUpdateRequest {
	return ApiStagesUserDeleteUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return UserDeleteStage
func (a *StagesAPIService) StagesUserDeleteUpdateExecute(r ApiStagesUserDeleteUpdateRequest) (*UserDeleteStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserDeleteStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesUserDeleteUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/user_delete/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userDeleteStageRequest == nil {
		return localVarReturnValue, nil, reportError("userDeleteStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userDeleteStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesUserDeleteUsedByListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesUserDeleteUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.StagesUserDeleteUsedByListExecute(r)
}

/*
StagesUserDeleteUsedByList Method for StagesUserDeleteUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this User Delete Stage.
	@return ApiStagesUserDeleteUsedByListRequest
*/
func (a *StagesAPIService) StagesUserDeleteUsedByList(ctx context.Context, stageUuid string) ApiStagesUserDeleteUsedByListRequest {
	return ApiStagesUserDeleteUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *StagesAPIService) StagesUserDeleteUsedByListExecute(r ApiStagesUserDeleteUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesUserDeleteUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/user_delete/{stage_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesUserLoginCreateRequest struct {
	ctx                   context.Context
	ApiService            *StagesAPIService
	userLoginStageRequest *UserLoginStageRequest
}

func (r ApiStagesUserLoginCreateRequest) UserLoginStageRequest(userLoginStageRequest UserLoginStageRequest) ApiStagesUserLoginCreateRequest {
	r.userLoginStageRequest = &userLoginStageRequest
	return r
}

func (r ApiStagesUserLoginCreateRequest) Execute() (*UserLoginStage, *http.Response, error) {
	return r.ApiService.StagesUserLoginCreateExecute(r)
}

/*
StagesUserLoginCreate Method for StagesUserLoginCreate

UserLoginStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesUserLoginCreateRequest
*/
func (a *StagesAPIService) StagesUserLoginCreate(ctx context.Context) ApiStagesUserLoginCreateRequest {
	return ApiStagesUserLoginCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UserLoginStage
func (a *StagesAPIService) StagesUserLoginCreateExecute(r ApiStagesUserLoginCreateRequest) (*UserLoginStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserLoginStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesUserLoginCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/user_login/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userLoginStageRequest == nil {
		return localVarReturnValue, nil, reportError("userLoginStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userLoginStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesUserLoginDestroyRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesUserLoginDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.StagesUserLoginDestroyExecute(r)
}

/*
StagesUserLoginDestroy Method for StagesUserLoginDestroy

UserLoginStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this User Login Stage.
	@return ApiStagesUserLoginDestroyRequest
*/
func (a *StagesAPIService) StagesUserLoginDestroy(ctx context.Context, stageUuid string) ApiStagesUserLoginDestroyRequest {
	return ApiStagesUserLoginDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
func (a *StagesAPIService) StagesUserLoginDestroyExecute(r ApiStagesUserLoginDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesUserLoginDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/user_login/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStagesUserLoginListRequest struct {
	ctx                    context.Context
	ApiService             *StagesAPIService
	geoipBinding           *string
	name                   *string
	networkBinding         *string
	ordering               *string
	page                   *int32
	pageSize               *int32
	rememberDevice         *string
	rememberMeOffset       *string
	search                 *string
	sessionDuration        *string
	stageUuid              *string
	terminateOtherSessions *bool
}

// Bind sessions created by this stage to the configured GeoIP location
func (r ApiStagesUserLoginListRequest) GeoipBinding(geoipBinding string) ApiStagesUserLoginListRequest {
	r.geoipBinding = &geoipBinding
	return r
}

func (r ApiStagesUserLoginListRequest) Name(name string) ApiStagesUserLoginListRequest {
	r.name = &name
	return r
}

// Bind sessions created by this stage to the configured network
func (r ApiStagesUserLoginListRequest) NetworkBinding(networkBinding string) ApiStagesUserLoginListRequest {
	r.networkBinding = &networkBinding
	return r
}

// Which field to use when ordering the results.
func (r ApiStagesUserLoginListRequest) Ordering(ordering string) ApiStagesUserLoginListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiStagesUserLoginListRequest) Page(page int32) ApiStagesUserLoginListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiStagesUserLoginListRequest) PageSize(pageSize int32) ApiStagesUserLoginListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiStagesUserLoginListRequest) RememberDevice(rememberDevice string) ApiStagesUserLoginListRequest {
	r.rememberDevice = &rememberDevice
	return r
}

func (r ApiStagesUserLoginListRequest) RememberMeOffset(rememberMeOffset string) ApiStagesUserLoginListRequest {
	r.rememberMeOffset = &rememberMeOffset
	return r
}

// A search term.
func (r ApiStagesUserLoginListRequest) Search(search string) ApiStagesUserLoginListRequest {
	r.search = &search
	return r
}

func (r ApiStagesUserLoginListRequest) SessionDuration(sessionDuration string) ApiStagesUserLoginListRequest {
	r.sessionDuration = &sessionDuration
	return r
}

func (r ApiStagesUserLoginListRequest) StageUuid(stageUuid string) ApiStagesUserLoginListRequest {
	r.stageUuid = &stageUuid
	return r
}

func (r ApiStagesUserLoginListRequest) TerminateOtherSessions(terminateOtherSessions bool) ApiStagesUserLoginListRequest {
	r.terminateOtherSessions = &terminateOtherSessions
	return r
}

func (r ApiStagesUserLoginListRequest) Execute() (*PaginatedUserLoginStageList, *http.Response, error) {
	return r.ApiService.StagesUserLoginListExecute(r)
}

/*
StagesUserLoginList Method for StagesUserLoginList

UserLoginStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesUserLoginListRequest
*/
func (a *StagesAPIService) StagesUserLoginList(ctx context.Context) ApiStagesUserLoginListRequest {
	return ApiStagesUserLoginListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedUserLoginStageList
func (a *StagesAPIService) StagesUserLoginListExecute(r ApiStagesUserLoginListRequest) (*PaginatedUserLoginStageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedUserLoginStageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesUserLoginList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/user_login/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.geoipBinding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "geoip_binding", r.geoipBinding, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.networkBinding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network_binding", r.networkBinding, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.rememberDevice != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "remember_device", r.rememberDevice, "form", "")
	}
	if r.rememberMeOffset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "remember_me_offset", r.rememberMeOffset, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.sessionDuration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "session_duration", r.sessionDuration, "form", "")
	}
	if r.stageUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stage_uuid", r.stageUuid, "form", "")
	}
	if r.terminateOtherSessions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "terminate_other_sessions", r.terminateOtherSessions, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesUserLoginPartialUpdateRequest struct {
	ctx                          context.Context
	ApiService                   *StagesAPIService
	stageUuid                    string
	patchedUserLoginStageRequest *PatchedUserLoginStageRequest
}

func (r ApiStagesUserLoginPartialUpdateRequest) PatchedUserLoginStageRequest(patchedUserLoginStageRequest PatchedUserLoginStageRequest) ApiStagesUserLoginPartialUpdateRequest {
	r.patchedUserLoginStageRequest = &patchedUserLoginStageRequest
	return r
}

func (r ApiStagesUserLoginPartialUpdateRequest) Execute() (*UserLoginStage, *http.Response, error) {
	return r.ApiService.StagesUserLoginPartialUpdateExecute(r)
}

/*
StagesUserLoginPartialUpdate Method for StagesUserLoginPartialUpdate

UserLoginStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this User Login Stage.
	@return ApiStagesUserLoginPartialUpdateRequest
*/
func (a *StagesAPIService) StagesUserLoginPartialUpdate(ctx context.Context, stageUuid string) ApiStagesUserLoginPartialUpdateRequest {
	return ApiStagesUserLoginPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return UserLoginStage
func (a *StagesAPIService) StagesUserLoginPartialUpdateExecute(r ApiStagesUserLoginPartialUpdateRequest) (*UserLoginStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserLoginStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesUserLoginPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/user_login/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedUserLoginStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesUserLoginRetrieveRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesUserLoginRetrieveRequest) Execute() (*UserLoginStage, *http.Response, error) {
	return r.ApiService.StagesUserLoginRetrieveExecute(r)
}

/*
StagesUserLoginRetrieve Method for StagesUserLoginRetrieve

UserLoginStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this User Login Stage.
	@return ApiStagesUserLoginRetrieveRequest
*/
func (a *StagesAPIService) StagesUserLoginRetrieve(ctx context.Context, stageUuid string) ApiStagesUserLoginRetrieveRequest {
	return ApiStagesUserLoginRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return UserLoginStage
func (a *StagesAPIService) StagesUserLoginRetrieveExecute(r ApiStagesUserLoginRetrieveRequest) (*UserLoginStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserLoginStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesUserLoginRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/user_login/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesUserLoginUpdateRequest struct {
	ctx                   context.Context
	ApiService            *StagesAPIService
	stageUuid             string
	userLoginStageRequest *UserLoginStageRequest
}

func (r ApiStagesUserLoginUpdateRequest) UserLoginStageRequest(userLoginStageRequest UserLoginStageRequest) ApiStagesUserLoginUpdateRequest {
	r.userLoginStageRequest = &userLoginStageRequest
	return r
}

func (r ApiStagesUserLoginUpdateRequest) Execute() (*UserLoginStage, *http.Response, error) {
	return r.ApiService.StagesUserLoginUpdateExecute(r)
}

/*
StagesUserLoginUpdate Method for StagesUserLoginUpdate

UserLoginStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this User Login Stage.
	@return ApiStagesUserLoginUpdateRequest
*/
func (a *StagesAPIService) StagesUserLoginUpdate(ctx context.Context, stageUuid string) ApiStagesUserLoginUpdateRequest {
	return ApiStagesUserLoginUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return UserLoginStage
func (a *StagesAPIService) StagesUserLoginUpdateExecute(r ApiStagesUserLoginUpdateRequest) (*UserLoginStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserLoginStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesUserLoginUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/user_login/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userLoginStageRequest == nil {
		return localVarReturnValue, nil, reportError("userLoginStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userLoginStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesUserLoginUsedByListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesUserLoginUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.StagesUserLoginUsedByListExecute(r)
}

/*
StagesUserLoginUsedByList Method for StagesUserLoginUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this User Login Stage.
	@return ApiStagesUserLoginUsedByListRequest
*/
func (a *StagesAPIService) StagesUserLoginUsedByList(ctx context.Context, stageUuid string) ApiStagesUserLoginUsedByListRequest {
	return ApiStagesUserLoginUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *StagesAPIService) StagesUserLoginUsedByListExecute(r ApiStagesUserLoginUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesUserLoginUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/user_login/{stage_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesUserLogoutCreateRequest struct {
	ctx                    context.Context
	ApiService             *StagesAPIService
	userLogoutStageRequest *UserLogoutStageRequest
}

func (r ApiStagesUserLogoutCreateRequest) UserLogoutStageRequest(userLogoutStageRequest UserLogoutStageRequest) ApiStagesUserLogoutCreateRequest {
	r.userLogoutStageRequest = &userLogoutStageRequest
	return r
}

func (r ApiStagesUserLogoutCreateRequest) Execute() (*UserLogoutStage, *http.Response, error) {
	return r.ApiService.StagesUserLogoutCreateExecute(r)
}

/*
StagesUserLogoutCreate Method for StagesUserLogoutCreate

UserLogoutStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesUserLogoutCreateRequest
*/
func (a *StagesAPIService) StagesUserLogoutCreate(ctx context.Context) ApiStagesUserLogoutCreateRequest {
	return ApiStagesUserLogoutCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UserLogoutStage
func (a *StagesAPIService) StagesUserLogoutCreateExecute(r ApiStagesUserLogoutCreateRequest) (*UserLogoutStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserLogoutStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesUserLogoutCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/user_logout/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userLogoutStageRequest == nil {
		return localVarReturnValue, nil, reportError("userLogoutStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userLogoutStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesUserLogoutDestroyRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesUserLogoutDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.StagesUserLogoutDestroyExecute(r)
}

/*
StagesUserLogoutDestroy Method for StagesUserLogoutDestroy

UserLogoutStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this User Logout Stage.
	@return ApiStagesUserLogoutDestroyRequest
*/
func (a *StagesAPIService) StagesUserLogoutDestroy(ctx context.Context, stageUuid string) ApiStagesUserLogoutDestroyRequest {
	return ApiStagesUserLogoutDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
func (a *StagesAPIService) StagesUserLogoutDestroyExecute(r ApiStagesUserLogoutDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesUserLogoutDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/user_logout/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStagesUserLogoutListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	name       *string
	ordering   *string
	page       *int32
	pageSize   *int32
	search     *string
	stageUuid  *string
}

func (r ApiStagesUserLogoutListRequest) Name(name string) ApiStagesUserLogoutListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiStagesUserLogoutListRequest) Ordering(ordering string) ApiStagesUserLogoutListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiStagesUserLogoutListRequest) Page(page int32) ApiStagesUserLogoutListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiStagesUserLogoutListRequest) PageSize(pageSize int32) ApiStagesUserLogoutListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiStagesUserLogoutListRequest) Search(search string) ApiStagesUserLogoutListRequest {
	r.search = &search
	return r
}

func (r ApiStagesUserLogoutListRequest) StageUuid(stageUuid string) ApiStagesUserLogoutListRequest {
	r.stageUuid = &stageUuid
	return r
}

func (r ApiStagesUserLogoutListRequest) Execute() (*PaginatedUserLogoutStageList, *http.Response, error) {
	return r.ApiService.StagesUserLogoutListExecute(r)
}

/*
StagesUserLogoutList Method for StagesUserLogoutList

UserLogoutStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesUserLogoutListRequest
*/
func (a *StagesAPIService) StagesUserLogoutList(ctx context.Context) ApiStagesUserLogoutListRequest {
	return ApiStagesUserLogoutListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedUserLogoutStageList
func (a *StagesAPIService) StagesUserLogoutListExecute(r ApiStagesUserLogoutListRequest) (*PaginatedUserLogoutStageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedUserLogoutStageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesUserLogoutList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/user_logout/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.stageUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stage_uuid", r.stageUuid, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesUserLogoutPartialUpdateRequest struct {
	ctx                           context.Context
	ApiService                    *StagesAPIService
	stageUuid                     string
	patchedUserLogoutStageRequest *PatchedUserLogoutStageRequest
}

func (r ApiStagesUserLogoutPartialUpdateRequest) PatchedUserLogoutStageRequest(patchedUserLogoutStageRequest PatchedUserLogoutStageRequest) ApiStagesUserLogoutPartialUpdateRequest {
	r.patchedUserLogoutStageRequest = &patchedUserLogoutStageRequest
	return r
}

func (r ApiStagesUserLogoutPartialUpdateRequest) Execute() (*UserLogoutStage, *http.Response, error) {
	return r.ApiService.StagesUserLogoutPartialUpdateExecute(r)
}

/*
StagesUserLogoutPartialUpdate Method for StagesUserLogoutPartialUpdate

UserLogoutStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this User Logout Stage.
	@return ApiStagesUserLogoutPartialUpdateRequest
*/
func (a *StagesAPIService) StagesUserLogoutPartialUpdate(ctx context.Context, stageUuid string) ApiStagesUserLogoutPartialUpdateRequest {
	return ApiStagesUserLogoutPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return UserLogoutStage
func (a *StagesAPIService) StagesUserLogoutPartialUpdateExecute(r ApiStagesUserLogoutPartialUpdateRequest) (*UserLogoutStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserLogoutStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesUserLogoutPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/user_logout/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedUserLogoutStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesUserLogoutRetrieveRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesUserLogoutRetrieveRequest) Execute() (*UserLogoutStage, *http.Response, error) {
	return r.ApiService.StagesUserLogoutRetrieveExecute(r)
}

/*
StagesUserLogoutRetrieve Method for StagesUserLogoutRetrieve

UserLogoutStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this User Logout Stage.
	@return ApiStagesUserLogoutRetrieveRequest
*/
func (a *StagesAPIService) StagesUserLogoutRetrieve(ctx context.Context, stageUuid string) ApiStagesUserLogoutRetrieveRequest {
	return ApiStagesUserLogoutRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return UserLogoutStage
func (a *StagesAPIService) StagesUserLogoutRetrieveExecute(r ApiStagesUserLogoutRetrieveRequest) (*UserLogoutStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserLogoutStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesUserLogoutRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/user_logout/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesUserLogoutUpdateRequest struct {
	ctx                    context.Context
	ApiService             *StagesAPIService
	stageUuid              string
	userLogoutStageRequest *UserLogoutStageRequest
}

func (r ApiStagesUserLogoutUpdateRequest) UserLogoutStageRequest(userLogoutStageRequest UserLogoutStageRequest) ApiStagesUserLogoutUpdateRequest {
	r.userLogoutStageRequest = &userLogoutStageRequest
	return r
}

func (r ApiStagesUserLogoutUpdateRequest) Execute() (*UserLogoutStage, *http.Response, error) {
	return r.ApiService.StagesUserLogoutUpdateExecute(r)
}

/*
StagesUserLogoutUpdate Method for StagesUserLogoutUpdate

UserLogoutStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this User Logout Stage.
	@return ApiStagesUserLogoutUpdateRequest
*/
func (a *StagesAPIService) StagesUserLogoutUpdate(ctx context.Context, stageUuid string) ApiStagesUserLogoutUpdateRequest {
	return ApiStagesUserLogoutUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return UserLogoutStage
func (a *StagesAPIService) StagesUserLogoutUpdateExecute(r ApiStagesUserLogoutUpdateRequest) (*UserLogoutStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserLogoutStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesUserLogoutUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/user_logout/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userLogoutStageRequest == nil {
		return localVarReturnValue, nil, reportError("userLogoutStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userLogoutStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesUserLogoutUsedByListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesUserLogoutUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.StagesUserLogoutUsedByListExecute(r)
}

/*
StagesUserLogoutUsedByList Method for StagesUserLogoutUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this User Logout Stage.
	@return ApiStagesUserLogoutUsedByListRequest
*/
func (a *StagesAPIService) StagesUserLogoutUsedByList(ctx context.Context, stageUuid string) ApiStagesUserLogoutUsedByListRequest {
	return ApiStagesUserLogoutUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *StagesAPIService) StagesUserLogoutUsedByListExecute(r ApiStagesUserLogoutUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesUserLogoutUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/user_logout/{stage_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesUserWriteCreateRequest struct {
	ctx                   context.Context
	ApiService            *StagesAPIService
	userWriteStageRequest *UserWriteStageRequest
}

func (r ApiStagesUserWriteCreateRequest) UserWriteStageRequest(userWriteStageRequest UserWriteStageRequest) ApiStagesUserWriteCreateRequest {
	r.userWriteStageRequest = &userWriteStageRequest
	return r
}

func (r ApiStagesUserWriteCreateRequest) Execute() (*UserWriteStage, *http.Response, error) {
	return r.ApiService.StagesUserWriteCreateExecute(r)
}

/*
StagesUserWriteCreate Method for StagesUserWriteCreate

UserWriteStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesUserWriteCreateRequest
*/
func (a *StagesAPIService) StagesUserWriteCreate(ctx context.Context) ApiStagesUserWriteCreateRequest {
	return ApiStagesUserWriteCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UserWriteStage
func (a *StagesAPIService) StagesUserWriteCreateExecute(r ApiStagesUserWriteCreateRequest) (*UserWriteStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserWriteStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesUserWriteCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/user_write/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userWriteStageRequest == nil {
		return localVarReturnValue, nil, reportError("userWriteStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userWriteStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesUserWriteDestroyRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesUserWriteDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.StagesUserWriteDestroyExecute(r)
}

/*
StagesUserWriteDestroy Method for StagesUserWriteDestroy

UserWriteStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this User Write Stage.
	@return ApiStagesUserWriteDestroyRequest
*/
func (a *StagesAPIService) StagesUserWriteDestroy(ctx context.Context, stageUuid string) ApiStagesUserWriteDestroyRequest {
	return ApiStagesUserWriteDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
func (a *StagesAPIService) StagesUserWriteDestroyExecute(r ApiStagesUserWriteDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesUserWriteDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/user_write/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStagesUserWriteListRequest struct {
	ctx                   context.Context
	ApiService            *StagesAPIService
	createUsersAsInactive *bool
	createUsersGroup      *string
	name                  *string
	ordering              *string
	page                  *int32
	pageSize              *int32
	search                *string
	stageUuid             *string
	userCreationMode      *string
	userPathTemplate      *string
	userType              *string
}

func (r ApiStagesUserWriteListRequest) CreateUsersAsInactive(createUsersAsInactive bool) ApiStagesUserWriteListRequest {
	r.createUsersAsInactive = &createUsersAsInactive
	return r
}

func (r ApiStagesUserWriteListRequest) CreateUsersGroup(createUsersGroup string) ApiStagesUserWriteListRequest {
	r.createUsersGroup = &createUsersGroup
	return r
}

func (r ApiStagesUserWriteListRequest) Name(name string) ApiStagesUserWriteListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiStagesUserWriteListRequest) Ordering(ordering string) ApiStagesUserWriteListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiStagesUserWriteListRequest) Page(page int32) ApiStagesUserWriteListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiStagesUserWriteListRequest) PageSize(pageSize int32) ApiStagesUserWriteListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiStagesUserWriteListRequest) Search(search string) ApiStagesUserWriteListRequest {
	r.search = &search
	return r
}

func (r ApiStagesUserWriteListRequest) StageUuid(stageUuid string) ApiStagesUserWriteListRequest {
	r.stageUuid = &stageUuid
	return r
}

func (r ApiStagesUserWriteListRequest) UserCreationMode(userCreationMode string) ApiStagesUserWriteListRequest {
	r.userCreationMode = &userCreationMode
	return r
}

func (r ApiStagesUserWriteListRequest) UserPathTemplate(userPathTemplate string) ApiStagesUserWriteListRequest {
	r.userPathTemplate = &userPathTemplate
	return r
}

func (r ApiStagesUserWriteListRequest) UserType(userType string) ApiStagesUserWriteListRequest {
	r.userType = &userType
	return r
}

func (r ApiStagesUserWriteListRequest) Execute() (*PaginatedUserWriteStageList, *http.Response, error) {
	return r.ApiService.StagesUserWriteListExecute(r)
}

/*
StagesUserWriteList Method for StagesUserWriteList

UserWriteStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStagesUserWriteListRequest
*/
func (a *StagesAPIService) StagesUserWriteList(ctx context.Context) ApiStagesUserWriteListRequest {
	return ApiStagesUserWriteListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedUserWriteStageList
func (a *StagesAPIService) StagesUserWriteListExecute(r ApiStagesUserWriteListRequest) (*PaginatedUserWriteStageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedUserWriteStageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesUserWriteList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/user_write/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.createUsersAsInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "create_users_as_inactive", r.createUsersAsInactive, "form", "")
	}
	if r.createUsersGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "create_users_group", r.createUsersGroup, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.stageUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stage_uuid", r.stageUuid, "form", "")
	}
	if r.userCreationMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_creation_mode", r.userCreationMode, "form", "")
	}
	if r.userPathTemplate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_path_template", r.userPathTemplate, "form", "")
	}
	if r.userType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_type", r.userType, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesUserWritePartialUpdateRequest struct {
	ctx                          context.Context
	ApiService                   *StagesAPIService
	stageUuid                    string
	patchedUserWriteStageRequest *PatchedUserWriteStageRequest
}

func (r ApiStagesUserWritePartialUpdateRequest) PatchedUserWriteStageRequest(patchedUserWriteStageRequest PatchedUserWriteStageRequest) ApiStagesUserWritePartialUpdateRequest {
	r.patchedUserWriteStageRequest = &patchedUserWriteStageRequest
	return r
}

func (r ApiStagesUserWritePartialUpdateRequest) Execute() (*UserWriteStage, *http.Response, error) {
	return r.ApiService.StagesUserWritePartialUpdateExecute(r)
}

/*
StagesUserWritePartialUpdate Method for StagesUserWritePartialUpdate

UserWriteStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this User Write Stage.
	@return ApiStagesUserWritePartialUpdateRequest
*/
func (a *StagesAPIService) StagesUserWritePartialUpdate(ctx context.Context, stageUuid string) ApiStagesUserWritePartialUpdateRequest {
	return ApiStagesUserWritePartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return UserWriteStage
func (a *StagesAPIService) StagesUserWritePartialUpdateExecute(r ApiStagesUserWritePartialUpdateRequest) (*UserWriteStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserWriteStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesUserWritePartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/user_write/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedUserWriteStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesUserWriteRetrieveRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesUserWriteRetrieveRequest) Execute() (*UserWriteStage, *http.Response, error) {
	return r.ApiService.StagesUserWriteRetrieveExecute(r)
}

/*
StagesUserWriteRetrieve Method for StagesUserWriteRetrieve

UserWriteStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this User Write Stage.
	@return ApiStagesUserWriteRetrieveRequest
*/
func (a *StagesAPIService) StagesUserWriteRetrieve(ctx context.Context, stageUuid string) ApiStagesUserWriteRetrieveRequest {
	return ApiStagesUserWriteRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return UserWriteStage
func (a *StagesAPIService) StagesUserWriteRetrieveExecute(r ApiStagesUserWriteRetrieveRequest) (*UserWriteStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserWriteStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesUserWriteRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/user_write/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesUserWriteUpdateRequest struct {
	ctx                   context.Context
	ApiService            *StagesAPIService
	stageUuid             string
	userWriteStageRequest *UserWriteStageRequest
}

func (r ApiStagesUserWriteUpdateRequest) UserWriteStageRequest(userWriteStageRequest UserWriteStageRequest) ApiStagesUserWriteUpdateRequest {
	r.userWriteStageRequest = &userWriteStageRequest
	return r
}

func (r ApiStagesUserWriteUpdateRequest) Execute() (*UserWriteStage, *http.Response, error) {
	return r.ApiService.StagesUserWriteUpdateExecute(r)
}

/*
StagesUserWriteUpdate Method for StagesUserWriteUpdate

UserWriteStage Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this User Write Stage.
	@return ApiStagesUserWriteUpdateRequest
*/
func (a *StagesAPIService) StagesUserWriteUpdate(ctx context.Context, stageUuid string) ApiStagesUserWriteUpdateRequest {
	return ApiStagesUserWriteUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return UserWriteStage
func (a *StagesAPIService) StagesUserWriteUpdateExecute(r ApiStagesUserWriteUpdateRequest) (*UserWriteStage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserWriteStage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesUserWriteUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/user_write/{stage_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userWriteStageRequest == nil {
		return localVarReturnValue, nil, reportError("userWriteStageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userWriteStageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStagesUserWriteUsedByListRequest struct {
	ctx        context.Context
	ApiService *StagesAPIService
	stageUuid  string
}

func (r ApiStagesUserWriteUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.StagesUserWriteUsedByListExecute(r)
}

/*
StagesUserWriteUsedByList Method for StagesUserWriteUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stageUuid A UUID string identifying this User Write Stage.
	@return ApiStagesUserWriteUsedByListRequest
*/
func (a *StagesAPIService) StagesUserWriteUsedByList(ctx context.Context, stageUuid string) ApiStagesUserWriteUsedByListRequest {
	return ApiStagesUserWriteUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		stageUuid:  stageUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *StagesAPIService) StagesUserWriteUsedByListExecute(r ApiStagesUserWriteUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StagesAPIService.StagesUserWriteUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stages/user_write/{stage_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"stage_uuid"+"}", url.PathEscape(parameterValueToString(r.stageUuid, "stageUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
