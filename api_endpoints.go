/*
authentik

Making authentication simple.

API version: 2025.12.0-rc1
Contact: hello@goauthentik.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// EndpointsApiService EndpointsApi service
type EndpointsApiService service

type ApiEndpointsAgentsConnectorsAgentConfigRetrieveRequest struct {
	ctx        context.Context
	ApiService *EndpointsApiService
}

func (r ApiEndpointsAgentsConnectorsAgentConfigRetrieveRequest) Execute() (*AgentConfig, *http.Response, error) {
	return r.ApiService.EndpointsAgentsConnectorsAgentConfigRetrieveExecute(r)
}

/*
EndpointsAgentsConnectorsAgentConfigRetrieve Method for EndpointsAgentsConnectorsAgentConfigRetrieve

Mixin to add a used_by endpoint to return a list of all objects using this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEndpointsAgentsConnectorsAgentConfigRetrieveRequest
*/
func (a *EndpointsApiService) EndpointsAgentsConnectorsAgentConfigRetrieve(ctx context.Context) ApiEndpointsAgentsConnectorsAgentConfigRetrieveRequest {
	return ApiEndpointsAgentsConnectorsAgentConfigRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AgentConfig
func (a *EndpointsApiService) EndpointsAgentsConnectorsAgentConfigRetrieveExecute(r ApiEndpointsAgentsConnectorsAgentConfigRetrieveRequest) (*AgentConfig, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AgentConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsAgentsConnectorsAgentConfigRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/agents/connectors/agent_config/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsAgentsConnectorsAuthFedCreateRequest struct {
	ctx        context.Context
	ApiService *EndpointsApiService
	device     *string
}

func (r ApiEndpointsAgentsConnectorsAuthFedCreateRequest) Device(device string) ApiEndpointsAgentsConnectorsAuthFedCreateRequest {
	r.device = &device
	return r
}

func (r ApiEndpointsAgentsConnectorsAuthFedCreateRequest) Execute() (*AgentTokenResponse, *http.Response, error) {
	return r.ApiService.EndpointsAgentsConnectorsAuthFedCreateExecute(r)
}

/*
EndpointsAgentsConnectorsAuthFedCreate Method for EndpointsAgentsConnectorsAuthFedCreate

Mixin to add a used_by endpoint to return a list of all objects using this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEndpointsAgentsConnectorsAuthFedCreateRequest
*/
func (a *EndpointsApiService) EndpointsAgentsConnectorsAuthFedCreate(ctx context.Context) ApiEndpointsAgentsConnectorsAuthFedCreateRequest {
	return ApiEndpointsAgentsConnectorsAuthFedCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AgentTokenResponse
func (a *EndpointsApiService) EndpointsAgentsConnectorsAuthFedCreateExecute(r ApiEndpointsAgentsConnectorsAuthFedCreateRequest) (*AgentTokenResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AgentTokenResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsAgentsConnectorsAuthFedCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/agents/connectors/auth_fed/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.device == nil {
		return localVarReturnValue, nil, reportError("device is required and must be specified")
	}

	localVarQueryParams.Add("device", parameterToString(*r.device, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsAgentsConnectorsAuthIaCreateRequest struct {
	ctx        context.Context
	ApiService *EndpointsApiService
}

func (r ApiEndpointsAgentsConnectorsAuthIaCreateRequest) Execute() (*AgentAuthenticationResponse, *http.Response, error) {
	return r.ApiService.EndpointsAgentsConnectorsAuthIaCreateExecute(r)
}

/*
EndpointsAgentsConnectorsAuthIaCreate Method for EndpointsAgentsConnectorsAuthIaCreate

Mixin to add a used_by endpoint to return a list of all objects using this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEndpointsAgentsConnectorsAuthIaCreateRequest
*/
func (a *EndpointsApiService) EndpointsAgentsConnectorsAuthIaCreate(ctx context.Context) ApiEndpointsAgentsConnectorsAuthIaCreateRequest {
	return ApiEndpointsAgentsConnectorsAuthIaCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AgentAuthenticationResponse
func (a *EndpointsApiService) EndpointsAgentsConnectorsAuthIaCreateExecute(r ApiEndpointsAgentsConnectorsAuthIaCreateRequest) (*AgentAuthenticationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AgentAuthenticationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsAgentsConnectorsAuthIaCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/agents/connectors/auth_ia/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsAgentsConnectorsCheckInCreateRequest struct {
	ctx                context.Context
	ApiService         *EndpointsApiService
	deviceFactsRequest *DeviceFactsRequest
}

func (r ApiEndpointsAgentsConnectorsCheckInCreateRequest) DeviceFactsRequest(deviceFactsRequest DeviceFactsRequest) ApiEndpointsAgentsConnectorsCheckInCreateRequest {
	r.deviceFactsRequest = &deviceFactsRequest
	return r
}

func (r ApiEndpointsAgentsConnectorsCheckInCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EndpointsAgentsConnectorsCheckInCreateExecute(r)
}

/*
EndpointsAgentsConnectorsCheckInCreate Method for EndpointsAgentsConnectorsCheckInCreate

Mixin to add a used_by endpoint to return a list of all objects using this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEndpointsAgentsConnectorsCheckInCreateRequest
*/
func (a *EndpointsApiService) EndpointsAgentsConnectorsCheckInCreate(ctx context.Context) ApiEndpointsAgentsConnectorsCheckInCreateRequest {
	return ApiEndpointsAgentsConnectorsCheckInCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *EndpointsApiService) EndpointsAgentsConnectorsCheckInCreateExecute(r ApiEndpointsAgentsConnectorsCheckInCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsAgentsConnectorsCheckInCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/agents/connectors/check_in/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deviceFactsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEndpointsAgentsConnectorsCreateRequest struct {
	ctx                   context.Context
	ApiService            *EndpointsApiService
	agentConnectorRequest *AgentConnectorRequest
}

func (r ApiEndpointsAgentsConnectorsCreateRequest) AgentConnectorRequest(agentConnectorRequest AgentConnectorRequest) ApiEndpointsAgentsConnectorsCreateRequest {
	r.agentConnectorRequest = &agentConnectorRequest
	return r
}

func (r ApiEndpointsAgentsConnectorsCreateRequest) Execute() (*AgentConnector, *http.Response, error) {
	return r.ApiService.EndpointsAgentsConnectorsCreateExecute(r)
}

/*
EndpointsAgentsConnectorsCreate Method for EndpointsAgentsConnectorsCreate

Mixin to add a used_by endpoint to return a list of all objects using this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEndpointsAgentsConnectorsCreateRequest
*/
func (a *EndpointsApiService) EndpointsAgentsConnectorsCreate(ctx context.Context) ApiEndpointsAgentsConnectorsCreateRequest {
	return ApiEndpointsAgentsConnectorsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AgentConnector
func (a *EndpointsApiService) EndpointsAgentsConnectorsCreateExecute(r ApiEndpointsAgentsConnectorsCreateRequest) (*AgentConnector, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AgentConnector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsAgentsConnectorsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/agents/connectors/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agentConnectorRequest == nil {
		return localVarReturnValue, nil, reportError("agentConnectorRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.agentConnectorRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsAgentsConnectorsDestroyRequest struct {
	ctx           context.Context
	ApiService    *EndpointsApiService
	connectorUuid string
}

func (r ApiEndpointsAgentsConnectorsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EndpointsAgentsConnectorsDestroyExecute(r)
}

/*
EndpointsAgentsConnectorsDestroy Method for EndpointsAgentsConnectorsDestroy

Mixin to add a used_by endpoint to return a list of all objects using this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectorUuid A UUID string identifying this Agent Connector.
	@return ApiEndpointsAgentsConnectorsDestroyRequest
*/
func (a *EndpointsApiService) EndpointsAgentsConnectorsDestroy(ctx context.Context, connectorUuid string) ApiEndpointsAgentsConnectorsDestroyRequest {
	return ApiEndpointsAgentsConnectorsDestroyRequest{
		ApiService:    a,
		ctx:           ctx,
		connectorUuid: connectorUuid,
	}
}

// Execute executes the request
func (a *EndpointsApiService) EndpointsAgentsConnectorsDestroyExecute(r ApiEndpointsAgentsConnectorsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsAgentsConnectorsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/agents/connectors/{connector_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"connector_uuid"+"}", url.PathEscape(parameterToString(r.connectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEndpointsAgentsConnectorsEnrollCreateRequest struct {
	ctx           context.Context
	ApiService    *EndpointsApiService
	enrollRequest *EnrollRequest
}

func (r ApiEndpointsAgentsConnectorsEnrollCreateRequest) EnrollRequest(enrollRequest EnrollRequest) ApiEndpointsAgentsConnectorsEnrollCreateRequest {
	r.enrollRequest = &enrollRequest
	return r
}

func (r ApiEndpointsAgentsConnectorsEnrollCreateRequest) Execute() (*AgentTokenResponse, *http.Response, error) {
	return r.ApiService.EndpointsAgentsConnectorsEnrollCreateExecute(r)
}

/*
EndpointsAgentsConnectorsEnrollCreate Method for EndpointsAgentsConnectorsEnrollCreate

Mixin to add a used_by endpoint to return a list of all objects using this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEndpointsAgentsConnectorsEnrollCreateRequest
*/
func (a *EndpointsApiService) EndpointsAgentsConnectorsEnrollCreate(ctx context.Context) ApiEndpointsAgentsConnectorsEnrollCreateRequest {
	return ApiEndpointsAgentsConnectorsEnrollCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AgentTokenResponse
func (a *EndpointsApiService) EndpointsAgentsConnectorsEnrollCreateExecute(r ApiEndpointsAgentsConnectorsEnrollCreateRequest) (*AgentTokenResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AgentTokenResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsAgentsConnectorsEnrollCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/agents/connectors/enroll/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.enrollRequest == nil {
		return localVarReturnValue, nil, reportError("enrollRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.enrollRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsAgentsConnectorsListRequest struct {
	ctx        context.Context
	ApiService *EndpointsApiService
	enabled    *bool
	name       *string
	ordering   *string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiEndpointsAgentsConnectorsListRequest) Enabled(enabled bool) ApiEndpointsAgentsConnectorsListRequest {
	r.enabled = &enabled
	return r
}

func (r ApiEndpointsAgentsConnectorsListRequest) Name(name string) ApiEndpointsAgentsConnectorsListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiEndpointsAgentsConnectorsListRequest) Ordering(ordering string) ApiEndpointsAgentsConnectorsListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiEndpointsAgentsConnectorsListRequest) Page(page int32) ApiEndpointsAgentsConnectorsListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiEndpointsAgentsConnectorsListRequest) PageSize(pageSize int32) ApiEndpointsAgentsConnectorsListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiEndpointsAgentsConnectorsListRequest) Search(search string) ApiEndpointsAgentsConnectorsListRequest {
	r.search = &search
	return r
}

func (r ApiEndpointsAgentsConnectorsListRequest) Execute() (*PaginatedAgentConnectorList, *http.Response, error) {
	return r.ApiService.EndpointsAgentsConnectorsListExecute(r)
}

/*
EndpointsAgentsConnectorsList Method for EndpointsAgentsConnectorsList

Mixin to add a used_by endpoint to return a list of all objects using this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEndpointsAgentsConnectorsListRequest
*/
func (a *EndpointsApiService) EndpointsAgentsConnectorsList(ctx context.Context) ApiEndpointsAgentsConnectorsListRequest {
	return ApiEndpointsAgentsConnectorsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedAgentConnectorList
func (a *EndpointsApiService) EndpointsAgentsConnectorsListExecute(r ApiEndpointsAgentsConnectorsListRequest) (*PaginatedAgentConnectorList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedAgentConnectorList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsAgentsConnectorsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/agents/connectors/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.enabled != nil {
		localVarQueryParams.Add("enabled", parameterToString(*r.enabled, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsAgentsConnectorsMdmConfigCreateRequest struct {
	ctx              context.Context
	ApiService       *EndpointsApiService
	connectorUuid    string
	mDMConfigRequest *MDMConfigRequest
}

func (r ApiEndpointsAgentsConnectorsMdmConfigCreateRequest) MDMConfigRequest(mDMConfigRequest MDMConfigRequest) ApiEndpointsAgentsConnectorsMdmConfigCreateRequest {
	r.mDMConfigRequest = &mDMConfigRequest
	return r
}

func (r ApiEndpointsAgentsConnectorsMdmConfigCreateRequest) Execute() (*MDMConfigResponse, *http.Response, error) {
	return r.ApiService.EndpointsAgentsConnectorsMdmConfigCreateExecute(r)
}

/*
EndpointsAgentsConnectorsMdmConfigCreate Method for EndpointsAgentsConnectorsMdmConfigCreate

Generate configuration for MDM systems to deploy authentik Agent

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectorUuid A UUID string identifying this Agent Connector.
	@return ApiEndpointsAgentsConnectorsMdmConfigCreateRequest
*/
func (a *EndpointsApiService) EndpointsAgentsConnectorsMdmConfigCreate(ctx context.Context, connectorUuid string) ApiEndpointsAgentsConnectorsMdmConfigCreateRequest {
	return ApiEndpointsAgentsConnectorsMdmConfigCreateRequest{
		ApiService:    a,
		ctx:           ctx,
		connectorUuid: connectorUuid,
	}
}

// Execute executes the request
//
//	@return MDMConfigResponse
func (a *EndpointsApiService) EndpointsAgentsConnectorsMdmConfigCreateExecute(r ApiEndpointsAgentsConnectorsMdmConfigCreateRequest) (*MDMConfigResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MDMConfigResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsAgentsConnectorsMdmConfigCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/agents/connectors/{connector_uuid}/mdm_config/"
	localVarPath = strings.Replace(localVarPath, "{"+"connector_uuid"+"}", url.PathEscape(parameterToString(r.connectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mDMConfigRequest == nil {
		return localVarReturnValue, nil, reportError("mDMConfigRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.mDMConfigRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsAgentsConnectorsPartialUpdateRequest struct {
	ctx                          context.Context
	ApiService                   *EndpointsApiService
	connectorUuid                string
	patchedAgentConnectorRequest *PatchedAgentConnectorRequest
}

func (r ApiEndpointsAgentsConnectorsPartialUpdateRequest) PatchedAgentConnectorRequest(patchedAgentConnectorRequest PatchedAgentConnectorRequest) ApiEndpointsAgentsConnectorsPartialUpdateRequest {
	r.patchedAgentConnectorRequest = &patchedAgentConnectorRequest
	return r
}

func (r ApiEndpointsAgentsConnectorsPartialUpdateRequest) Execute() (*AgentConnector, *http.Response, error) {
	return r.ApiService.EndpointsAgentsConnectorsPartialUpdateExecute(r)
}

/*
EndpointsAgentsConnectorsPartialUpdate Method for EndpointsAgentsConnectorsPartialUpdate

Mixin to add a used_by endpoint to return a list of all objects using this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectorUuid A UUID string identifying this Agent Connector.
	@return ApiEndpointsAgentsConnectorsPartialUpdateRequest
*/
func (a *EndpointsApiService) EndpointsAgentsConnectorsPartialUpdate(ctx context.Context, connectorUuid string) ApiEndpointsAgentsConnectorsPartialUpdateRequest {
	return ApiEndpointsAgentsConnectorsPartialUpdateRequest{
		ApiService:    a,
		ctx:           ctx,
		connectorUuid: connectorUuid,
	}
}

// Execute executes the request
//
//	@return AgentConnector
func (a *EndpointsApiService) EndpointsAgentsConnectorsPartialUpdateExecute(r ApiEndpointsAgentsConnectorsPartialUpdateRequest) (*AgentConnector, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AgentConnector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsAgentsConnectorsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/agents/connectors/{connector_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"connector_uuid"+"}", url.PathEscape(parameterToString(r.connectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedAgentConnectorRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsAgentsConnectorsRetrieveRequest struct {
	ctx           context.Context
	ApiService    *EndpointsApiService
	connectorUuid string
}

func (r ApiEndpointsAgentsConnectorsRetrieveRequest) Execute() (*AgentConnector, *http.Response, error) {
	return r.ApiService.EndpointsAgentsConnectorsRetrieveExecute(r)
}

/*
EndpointsAgentsConnectorsRetrieve Method for EndpointsAgentsConnectorsRetrieve

Mixin to add a used_by endpoint to return a list of all objects using this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectorUuid A UUID string identifying this Agent Connector.
	@return ApiEndpointsAgentsConnectorsRetrieveRequest
*/
func (a *EndpointsApiService) EndpointsAgentsConnectorsRetrieve(ctx context.Context, connectorUuid string) ApiEndpointsAgentsConnectorsRetrieveRequest {
	return ApiEndpointsAgentsConnectorsRetrieveRequest{
		ApiService:    a,
		ctx:           ctx,
		connectorUuid: connectorUuid,
	}
}

// Execute executes the request
//
//	@return AgentConnector
func (a *EndpointsApiService) EndpointsAgentsConnectorsRetrieveExecute(r ApiEndpointsAgentsConnectorsRetrieveRequest) (*AgentConnector, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AgentConnector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsAgentsConnectorsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/agents/connectors/{connector_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"connector_uuid"+"}", url.PathEscape(parameterToString(r.connectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsAgentsConnectorsUpdateRequest struct {
	ctx                   context.Context
	ApiService            *EndpointsApiService
	connectorUuid         string
	agentConnectorRequest *AgentConnectorRequest
}

func (r ApiEndpointsAgentsConnectorsUpdateRequest) AgentConnectorRequest(agentConnectorRequest AgentConnectorRequest) ApiEndpointsAgentsConnectorsUpdateRequest {
	r.agentConnectorRequest = &agentConnectorRequest
	return r
}

func (r ApiEndpointsAgentsConnectorsUpdateRequest) Execute() (*AgentConnector, *http.Response, error) {
	return r.ApiService.EndpointsAgentsConnectorsUpdateExecute(r)
}

/*
EndpointsAgentsConnectorsUpdate Method for EndpointsAgentsConnectorsUpdate

Mixin to add a used_by endpoint to return a list of all objects using this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectorUuid A UUID string identifying this Agent Connector.
	@return ApiEndpointsAgentsConnectorsUpdateRequest
*/
func (a *EndpointsApiService) EndpointsAgentsConnectorsUpdate(ctx context.Context, connectorUuid string) ApiEndpointsAgentsConnectorsUpdateRequest {
	return ApiEndpointsAgentsConnectorsUpdateRequest{
		ApiService:    a,
		ctx:           ctx,
		connectorUuid: connectorUuid,
	}
}

// Execute executes the request
//
//	@return AgentConnector
func (a *EndpointsApiService) EndpointsAgentsConnectorsUpdateExecute(r ApiEndpointsAgentsConnectorsUpdateRequest) (*AgentConnector, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AgentConnector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsAgentsConnectorsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/agents/connectors/{connector_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"connector_uuid"+"}", url.PathEscape(parameterToString(r.connectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agentConnectorRequest == nil {
		return localVarReturnValue, nil, reportError("agentConnectorRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.agentConnectorRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsAgentsConnectorsUsedByListRequest struct {
	ctx           context.Context
	ApiService    *EndpointsApiService
	connectorUuid string
}

func (r ApiEndpointsAgentsConnectorsUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.EndpointsAgentsConnectorsUsedByListExecute(r)
}

/*
EndpointsAgentsConnectorsUsedByList Method for EndpointsAgentsConnectorsUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectorUuid A UUID string identifying this Agent Connector.
	@return ApiEndpointsAgentsConnectorsUsedByListRequest
*/
func (a *EndpointsApiService) EndpointsAgentsConnectorsUsedByList(ctx context.Context, connectorUuid string) ApiEndpointsAgentsConnectorsUsedByListRequest {
	return ApiEndpointsAgentsConnectorsUsedByListRequest{
		ApiService:    a,
		ctx:           ctx,
		connectorUuid: connectorUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *EndpointsApiService) EndpointsAgentsConnectorsUsedByListExecute(r ApiEndpointsAgentsConnectorsUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsAgentsConnectorsUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/agents/connectors/{connector_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"connector_uuid"+"}", url.PathEscape(parameterToString(r.connectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsAgentsEnrollmentTokensCreateRequest struct {
	ctx                    context.Context
	ApiService             *EndpointsApiService
	enrollmentTokenRequest *EnrollmentTokenRequest
}

func (r ApiEndpointsAgentsEnrollmentTokensCreateRequest) EnrollmentTokenRequest(enrollmentTokenRequest EnrollmentTokenRequest) ApiEndpointsAgentsEnrollmentTokensCreateRequest {
	r.enrollmentTokenRequest = &enrollmentTokenRequest
	return r
}

func (r ApiEndpointsAgentsEnrollmentTokensCreateRequest) Execute() (*EnrollmentToken, *http.Response, error) {
	return r.ApiService.EndpointsAgentsEnrollmentTokensCreateExecute(r)
}

/*
EndpointsAgentsEnrollmentTokensCreate Method for EndpointsAgentsEnrollmentTokensCreate

Mixin to add a used_by endpoint to return a list of all objects using this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEndpointsAgentsEnrollmentTokensCreateRequest
*/
func (a *EndpointsApiService) EndpointsAgentsEnrollmentTokensCreate(ctx context.Context) ApiEndpointsAgentsEnrollmentTokensCreateRequest {
	return ApiEndpointsAgentsEnrollmentTokensCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return EnrollmentToken
func (a *EndpointsApiService) EndpointsAgentsEnrollmentTokensCreateExecute(r ApiEndpointsAgentsEnrollmentTokensCreateRequest) (*EnrollmentToken, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EnrollmentToken
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsAgentsEnrollmentTokensCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/agents/enrollment_tokens/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.enrollmentTokenRequest == nil {
		return localVarReturnValue, nil, reportError("enrollmentTokenRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.enrollmentTokenRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsAgentsEnrollmentTokensDestroyRequest struct {
	ctx        context.Context
	ApiService *EndpointsApiService
	tokenUuid  string
}

func (r ApiEndpointsAgentsEnrollmentTokensDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EndpointsAgentsEnrollmentTokensDestroyExecute(r)
}

/*
EndpointsAgentsEnrollmentTokensDestroy Method for EndpointsAgentsEnrollmentTokensDestroy

Mixin to add a used_by endpoint to return a list of all objects using this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tokenUuid A UUID string identifying this Enrollment Token.
	@return ApiEndpointsAgentsEnrollmentTokensDestroyRequest
*/
func (a *EndpointsApiService) EndpointsAgentsEnrollmentTokensDestroy(ctx context.Context, tokenUuid string) ApiEndpointsAgentsEnrollmentTokensDestroyRequest {
	return ApiEndpointsAgentsEnrollmentTokensDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		tokenUuid:  tokenUuid,
	}
}

// Execute executes the request
func (a *EndpointsApiService) EndpointsAgentsEnrollmentTokensDestroyExecute(r ApiEndpointsAgentsEnrollmentTokensDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsAgentsEnrollmentTokensDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/agents/enrollment_tokens/{token_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"token_uuid"+"}", url.PathEscape(parameterToString(r.tokenUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEndpointsAgentsEnrollmentTokensListRequest struct {
	ctx        context.Context
	ApiService *EndpointsApiService
	connector  *string
	ordering   *string
	page       *int32
	pageSize   *int32
	search     *string
	tokenUuid  *string
}

func (r ApiEndpointsAgentsEnrollmentTokensListRequest) Connector(connector string) ApiEndpointsAgentsEnrollmentTokensListRequest {
	r.connector = &connector
	return r
}

// Which field to use when ordering the results.
func (r ApiEndpointsAgentsEnrollmentTokensListRequest) Ordering(ordering string) ApiEndpointsAgentsEnrollmentTokensListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiEndpointsAgentsEnrollmentTokensListRequest) Page(page int32) ApiEndpointsAgentsEnrollmentTokensListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiEndpointsAgentsEnrollmentTokensListRequest) PageSize(pageSize int32) ApiEndpointsAgentsEnrollmentTokensListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiEndpointsAgentsEnrollmentTokensListRequest) Search(search string) ApiEndpointsAgentsEnrollmentTokensListRequest {
	r.search = &search
	return r
}

func (r ApiEndpointsAgentsEnrollmentTokensListRequest) TokenUuid(tokenUuid string) ApiEndpointsAgentsEnrollmentTokensListRequest {
	r.tokenUuid = &tokenUuid
	return r
}

func (r ApiEndpointsAgentsEnrollmentTokensListRequest) Execute() (*PaginatedEnrollmentTokenList, *http.Response, error) {
	return r.ApiService.EndpointsAgentsEnrollmentTokensListExecute(r)
}

/*
EndpointsAgentsEnrollmentTokensList Method for EndpointsAgentsEnrollmentTokensList

Mixin to add a used_by endpoint to return a list of all objects using this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEndpointsAgentsEnrollmentTokensListRequest
*/
func (a *EndpointsApiService) EndpointsAgentsEnrollmentTokensList(ctx context.Context) ApiEndpointsAgentsEnrollmentTokensListRequest {
	return ApiEndpointsAgentsEnrollmentTokensListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedEnrollmentTokenList
func (a *EndpointsApiService) EndpointsAgentsEnrollmentTokensListExecute(r ApiEndpointsAgentsEnrollmentTokensListRequest) (*PaginatedEnrollmentTokenList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedEnrollmentTokenList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsAgentsEnrollmentTokensList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/agents/enrollment_tokens/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.connector != nil {
		localVarQueryParams.Add("connector", parameterToString(*r.connector, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.tokenUuid != nil {
		localVarQueryParams.Add("token_uuid", parameterToString(*r.tokenUuid, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsAgentsEnrollmentTokensPartialUpdateRequest struct {
	ctx                           context.Context
	ApiService                    *EndpointsApiService
	tokenUuid                     string
	patchedEnrollmentTokenRequest *PatchedEnrollmentTokenRequest
}

func (r ApiEndpointsAgentsEnrollmentTokensPartialUpdateRequest) PatchedEnrollmentTokenRequest(patchedEnrollmentTokenRequest PatchedEnrollmentTokenRequest) ApiEndpointsAgentsEnrollmentTokensPartialUpdateRequest {
	r.patchedEnrollmentTokenRequest = &patchedEnrollmentTokenRequest
	return r
}

func (r ApiEndpointsAgentsEnrollmentTokensPartialUpdateRequest) Execute() (*EnrollmentToken, *http.Response, error) {
	return r.ApiService.EndpointsAgentsEnrollmentTokensPartialUpdateExecute(r)
}

/*
EndpointsAgentsEnrollmentTokensPartialUpdate Method for EndpointsAgentsEnrollmentTokensPartialUpdate

Mixin to add a used_by endpoint to return a list of all objects using this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tokenUuid A UUID string identifying this Enrollment Token.
	@return ApiEndpointsAgentsEnrollmentTokensPartialUpdateRequest
*/
func (a *EndpointsApiService) EndpointsAgentsEnrollmentTokensPartialUpdate(ctx context.Context, tokenUuid string) ApiEndpointsAgentsEnrollmentTokensPartialUpdateRequest {
	return ApiEndpointsAgentsEnrollmentTokensPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		tokenUuid:  tokenUuid,
	}
}

// Execute executes the request
//
//	@return EnrollmentToken
func (a *EndpointsApiService) EndpointsAgentsEnrollmentTokensPartialUpdateExecute(r ApiEndpointsAgentsEnrollmentTokensPartialUpdateRequest) (*EnrollmentToken, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EnrollmentToken
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsAgentsEnrollmentTokensPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/agents/enrollment_tokens/{token_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"token_uuid"+"}", url.PathEscape(parameterToString(r.tokenUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedEnrollmentTokenRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsAgentsEnrollmentTokensRetrieveRequest struct {
	ctx        context.Context
	ApiService *EndpointsApiService
	tokenUuid  string
}

func (r ApiEndpointsAgentsEnrollmentTokensRetrieveRequest) Execute() (*EnrollmentToken, *http.Response, error) {
	return r.ApiService.EndpointsAgentsEnrollmentTokensRetrieveExecute(r)
}

/*
EndpointsAgentsEnrollmentTokensRetrieve Method for EndpointsAgentsEnrollmentTokensRetrieve

Mixin to add a used_by endpoint to return a list of all objects using this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tokenUuid A UUID string identifying this Enrollment Token.
	@return ApiEndpointsAgentsEnrollmentTokensRetrieveRequest
*/
func (a *EndpointsApiService) EndpointsAgentsEnrollmentTokensRetrieve(ctx context.Context, tokenUuid string) ApiEndpointsAgentsEnrollmentTokensRetrieveRequest {
	return ApiEndpointsAgentsEnrollmentTokensRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		tokenUuid:  tokenUuid,
	}
}

// Execute executes the request
//
//	@return EnrollmentToken
func (a *EndpointsApiService) EndpointsAgentsEnrollmentTokensRetrieveExecute(r ApiEndpointsAgentsEnrollmentTokensRetrieveRequest) (*EnrollmentToken, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EnrollmentToken
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsAgentsEnrollmentTokensRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/agents/enrollment_tokens/{token_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"token_uuid"+"}", url.PathEscape(parameterToString(r.tokenUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsAgentsEnrollmentTokensUpdateRequest struct {
	ctx                    context.Context
	ApiService             *EndpointsApiService
	tokenUuid              string
	enrollmentTokenRequest *EnrollmentTokenRequest
}

func (r ApiEndpointsAgentsEnrollmentTokensUpdateRequest) EnrollmentTokenRequest(enrollmentTokenRequest EnrollmentTokenRequest) ApiEndpointsAgentsEnrollmentTokensUpdateRequest {
	r.enrollmentTokenRequest = &enrollmentTokenRequest
	return r
}

func (r ApiEndpointsAgentsEnrollmentTokensUpdateRequest) Execute() (*EnrollmentToken, *http.Response, error) {
	return r.ApiService.EndpointsAgentsEnrollmentTokensUpdateExecute(r)
}

/*
EndpointsAgentsEnrollmentTokensUpdate Method for EndpointsAgentsEnrollmentTokensUpdate

Mixin to add a used_by endpoint to return a list of all objects using this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tokenUuid A UUID string identifying this Enrollment Token.
	@return ApiEndpointsAgentsEnrollmentTokensUpdateRequest
*/
func (a *EndpointsApiService) EndpointsAgentsEnrollmentTokensUpdate(ctx context.Context, tokenUuid string) ApiEndpointsAgentsEnrollmentTokensUpdateRequest {
	return ApiEndpointsAgentsEnrollmentTokensUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		tokenUuid:  tokenUuid,
	}
}

// Execute executes the request
//
//	@return EnrollmentToken
func (a *EndpointsApiService) EndpointsAgentsEnrollmentTokensUpdateExecute(r ApiEndpointsAgentsEnrollmentTokensUpdateRequest) (*EnrollmentToken, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EnrollmentToken
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsAgentsEnrollmentTokensUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/agents/enrollment_tokens/{token_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"token_uuid"+"}", url.PathEscape(parameterToString(r.tokenUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.enrollmentTokenRequest == nil {
		return localVarReturnValue, nil, reportError("enrollmentTokenRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.enrollmentTokenRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsAgentsEnrollmentTokensUsedByListRequest struct {
	ctx        context.Context
	ApiService *EndpointsApiService
	tokenUuid  string
}

func (r ApiEndpointsAgentsEnrollmentTokensUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.EndpointsAgentsEnrollmentTokensUsedByListExecute(r)
}

/*
EndpointsAgentsEnrollmentTokensUsedByList Method for EndpointsAgentsEnrollmentTokensUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tokenUuid A UUID string identifying this Enrollment Token.
	@return ApiEndpointsAgentsEnrollmentTokensUsedByListRequest
*/
func (a *EndpointsApiService) EndpointsAgentsEnrollmentTokensUsedByList(ctx context.Context, tokenUuid string) ApiEndpointsAgentsEnrollmentTokensUsedByListRequest {
	return ApiEndpointsAgentsEnrollmentTokensUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		tokenUuid:  tokenUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *EndpointsApiService) EndpointsAgentsEnrollmentTokensUsedByListExecute(r ApiEndpointsAgentsEnrollmentTokensUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsAgentsEnrollmentTokensUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/agents/enrollment_tokens/{token_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"token_uuid"+"}", url.PathEscape(parameterToString(r.tokenUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsAgentsEnrollmentTokensViewKeyRetrieveRequest struct {
	ctx        context.Context
	ApiService *EndpointsApiService
	tokenUuid  string
}

func (r ApiEndpointsAgentsEnrollmentTokensViewKeyRetrieveRequest) Execute() (*TokenView, *http.Response, error) {
	return r.ApiService.EndpointsAgentsEnrollmentTokensViewKeyRetrieveExecute(r)
}

/*
EndpointsAgentsEnrollmentTokensViewKeyRetrieve Method for EndpointsAgentsEnrollmentTokensViewKeyRetrieve

Return token key and log access

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tokenUuid A UUID string identifying this Enrollment Token.
	@return ApiEndpointsAgentsEnrollmentTokensViewKeyRetrieveRequest
*/
func (a *EndpointsApiService) EndpointsAgentsEnrollmentTokensViewKeyRetrieve(ctx context.Context, tokenUuid string) ApiEndpointsAgentsEnrollmentTokensViewKeyRetrieveRequest {
	return ApiEndpointsAgentsEnrollmentTokensViewKeyRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		tokenUuid:  tokenUuid,
	}
}

// Execute executes the request
//
//	@return TokenView
func (a *EndpointsApiService) EndpointsAgentsEnrollmentTokensViewKeyRetrieveExecute(r ApiEndpointsAgentsEnrollmentTokensViewKeyRetrieveRequest) (*TokenView, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TokenView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsAgentsEnrollmentTokensViewKeyRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/agents/enrollment_tokens/{token_uuid}/view_key/"
	localVarPath = strings.Replace(localVarPath, "{"+"token_uuid"+"}", url.PathEscape(parameterToString(r.tokenUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsAgentsPssoRegisterDeviceCreateRequest struct {
	ctx                                context.Context
	ApiService                         *EndpointsApiService
	agentPSSODeviceRegistrationRequest *AgentPSSODeviceRegistrationRequest
}

func (r ApiEndpointsAgentsPssoRegisterDeviceCreateRequest) AgentPSSODeviceRegistrationRequest(agentPSSODeviceRegistrationRequest AgentPSSODeviceRegistrationRequest) ApiEndpointsAgentsPssoRegisterDeviceCreateRequest {
	r.agentPSSODeviceRegistrationRequest = &agentPSSODeviceRegistrationRequest
	return r
}

func (r ApiEndpointsAgentsPssoRegisterDeviceCreateRequest) Execute() (*AgentPSSODeviceRegistrationResponse, *http.Response, error) {
	return r.ApiService.EndpointsAgentsPssoRegisterDeviceCreateExecute(r)
}

/*
EndpointsAgentsPssoRegisterDeviceCreate Method for EndpointsAgentsPssoRegisterDeviceCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEndpointsAgentsPssoRegisterDeviceCreateRequest
*/
func (a *EndpointsApiService) EndpointsAgentsPssoRegisterDeviceCreate(ctx context.Context) ApiEndpointsAgentsPssoRegisterDeviceCreateRequest {
	return ApiEndpointsAgentsPssoRegisterDeviceCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AgentPSSODeviceRegistrationResponse
func (a *EndpointsApiService) EndpointsAgentsPssoRegisterDeviceCreateExecute(r ApiEndpointsAgentsPssoRegisterDeviceCreateRequest) (*AgentPSSODeviceRegistrationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AgentPSSODeviceRegistrationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsAgentsPssoRegisterDeviceCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/agents/psso/register/device/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agentPSSODeviceRegistrationRequest == nil {
		return localVarReturnValue, nil, reportError("agentPSSODeviceRegistrationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.agentPSSODeviceRegistrationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsAgentsPssoRegisterUserCreateRequest struct {
	ctx                              context.Context
	ApiService                       *EndpointsApiService
	agentPSSOUserRegistrationRequest *AgentPSSOUserRegistrationRequest
}

func (r ApiEndpointsAgentsPssoRegisterUserCreateRequest) AgentPSSOUserRegistrationRequest(agentPSSOUserRegistrationRequest AgentPSSOUserRegistrationRequest) ApiEndpointsAgentsPssoRegisterUserCreateRequest {
	r.agentPSSOUserRegistrationRequest = &agentPSSOUserRegistrationRequest
	return r
}

func (r ApiEndpointsAgentsPssoRegisterUserCreateRequest) Execute() (*UserSelf, *http.Response, error) {
	return r.ApiService.EndpointsAgentsPssoRegisterUserCreateExecute(r)
}

/*
EndpointsAgentsPssoRegisterUserCreate Method for EndpointsAgentsPssoRegisterUserCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEndpointsAgentsPssoRegisterUserCreateRequest
*/
func (a *EndpointsApiService) EndpointsAgentsPssoRegisterUserCreate(ctx context.Context) ApiEndpointsAgentsPssoRegisterUserCreateRequest {
	return ApiEndpointsAgentsPssoRegisterUserCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UserSelf
func (a *EndpointsApiService) EndpointsAgentsPssoRegisterUserCreateExecute(r ApiEndpointsAgentsPssoRegisterUserCreateRequest) (*UserSelf, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserSelf
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsAgentsPssoRegisterUserCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/agents/psso/register/user/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agentPSSOUserRegistrationRequest == nil {
		return localVarReturnValue, nil, reportError("agentPSSOUserRegistrationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.agentPSSOUserRegistrationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsConnectorsDestroyRequest struct {
	ctx           context.Context
	ApiService    *EndpointsApiService
	connectorUuid string
}

func (r ApiEndpointsConnectorsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EndpointsConnectorsDestroyExecute(r)
}

/*
EndpointsConnectorsDestroy Method for EndpointsConnectorsDestroy

Connector Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectorUuid A UUID string identifying this connector.
	@return ApiEndpointsConnectorsDestroyRequest
*/
func (a *EndpointsApiService) EndpointsConnectorsDestroy(ctx context.Context, connectorUuid string) ApiEndpointsConnectorsDestroyRequest {
	return ApiEndpointsConnectorsDestroyRequest{
		ApiService:    a,
		ctx:           ctx,
		connectorUuid: connectorUuid,
	}
}

// Execute executes the request
func (a *EndpointsApiService) EndpointsConnectorsDestroyExecute(r ApiEndpointsConnectorsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsConnectorsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/connectors/{connector_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"connector_uuid"+"}", url.PathEscape(parameterToString(r.connectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEndpointsConnectorsListRequest struct {
	ctx        context.Context
	ApiService *EndpointsApiService
	ordering   *string
	page       *int32
	pageSize   *int32
	search     *string
}

// Which field to use when ordering the results.
func (r ApiEndpointsConnectorsListRequest) Ordering(ordering string) ApiEndpointsConnectorsListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiEndpointsConnectorsListRequest) Page(page int32) ApiEndpointsConnectorsListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiEndpointsConnectorsListRequest) PageSize(pageSize int32) ApiEndpointsConnectorsListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiEndpointsConnectorsListRequest) Search(search string) ApiEndpointsConnectorsListRequest {
	r.search = &search
	return r
}

func (r ApiEndpointsConnectorsListRequest) Execute() (*PaginatedConnectorList, *http.Response, error) {
	return r.ApiService.EndpointsConnectorsListExecute(r)
}

/*
EndpointsConnectorsList Method for EndpointsConnectorsList

Connector Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEndpointsConnectorsListRequest
*/
func (a *EndpointsApiService) EndpointsConnectorsList(ctx context.Context) ApiEndpointsConnectorsListRequest {
	return ApiEndpointsConnectorsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedConnectorList
func (a *EndpointsApiService) EndpointsConnectorsListExecute(r ApiEndpointsConnectorsListRequest) (*PaginatedConnectorList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedConnectorList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsConnectorsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/connectors/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsConnectorsRetrieveRequest struct {
	ctx           context.Context
	ApiService    *EndpointsApiService
	connectorUuid string
}

func (r ApiEndpointsConnectorsRetrieveRequest) Execute() (*Connector, *http.Response, error) {
	return r.ApiService.EndpointsConnectorsRetrieveExecute(r)
}

/*
EndpointsConnectorsRetrieve Method for EndpointsConnectorsRetrieve

Connector Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectorUuid A UUID string identifying this connector.
	@return ApiEndpointsConnectorsRetrieveRequest
*/
func (a *EndpointsApiService) EndpointsConnectorsRetrieve(ctx context.Context, connectorUuid string) ApiEndpointsConnectorsRetrieveRequest {
	return ApiEndpointsConnectorsRetrieveRequest{
		ApiService:    a,
		ctx:           ctx,
		connectorUuid: connectorUuid,
	}
}

// Execute executes the request
//
//	@return Connector
func (a *EndpointsApiService) EndpointsConnectorsRetrieveExecute(r ApiEndpointsConnectorsRetrieveRequest) (*Connector, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Connector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsConnectorsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/connectors/{connector_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"connector_uuid"+"}", url.PathEscape(parameterToString(r.connectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsConnectorsTypesListRequest struct {
	ctx        context.Context
	ApiService *EndpointsApiService
}

func (r ApiEndpointsConnectorsTypesListRequest) Execute() ([]TypeCreate, *http.Response, error) {
	return r.ApiService.EndpointsConnectorsTypesListExecute(r)
}

/*
EndpointsConnectorsTypesList Method for EndpointsConnectorsTypesList

Get all creatable types

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEndpointsConnectorsTypesListRequest
*/
func (a *EndpointsApiService) EndpointsConnectorsTypesList(ctx context.Context) ApiEndpointsConnectorsTypesListRequest {
	return ApiEndpointsConnectorsTypesListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []TypeCreate
func (a *EndpointsApiService) EndpointsConnectorsTypesListExecute(r ApiEndpointsConnectorsTypesListRequest) ([]TypeCreate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []TypeCreate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsConnectorsTypesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/connectors/types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsConnectorsUsedByListRequest struct {
	ctx           context.Context
	ApiService    *EndpointsApiService
	connectorUuid string
}

func (r ApiEndpointsConnectorsUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.EndpointsConnectorsUsedByListExecute(r)
}

/*
EndpointsConnectorsUsedByList Method for EndpointsConnectorsUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectorUuid A UUID string identifying this connector.
	@return ApiEndpointsConnectorsUsedByListRequest
*/
func (a *EndpointsApiService) EndpointsConnectorsUsedByList(ctx context.Context, connectorUuid string) ApiEndpointsConnectorsUsedByListRequest {
	return ApiEndpointsConnectorsUsedByListRequest{
		ApiService:    a,
		ctx:           ctx,
		connectorUuid: connectorUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *EndpointsApiService) EndpointsConnectorsUsedByListExecute(r ApiEndpointsConnectorsUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsConnectorsUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/connectors/{connector_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"connector_uuid"+"}", url.PathEscape(parameterToString(r.connectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsDeviceAccessGroupsCreateRequest struct {
	ctx                      context.Context
	ApiService               *EndpointsApiService
	deviceAccessGroupRequest *DeviceAccessGroupRequest
}

func (r ApiEndpointsDeviceAccessGroupsCreateRequest) DeviceAccessGroupRequest(deviceAccessGroupRequest DeviceAccessGroupRequest) ApiEndpointsDeviceAccessGroupsCreateRequest {
	r.deviceAccessGroupRequest = &deviceAccessGroupRequest
	return r
}

func (r ApiEndpointsDeviceAccessGroupsCreateRequest) Execute() (*DeviceAccessGroup, *http.Response, error) {
	return r.ApiService.EndpointsDeviceAccessGroupsCreateExecute(r)
}

/*
EndpointsDeviceAccessGroupsCreate Method for EndpointsDeviceAccessGroupsCreate

DeviceAccessGroup Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEndpointsDeviceAccessGroupsCreateRequest
*/
func (a *EndpointsApiService) EndpointsDeviceAccessGroupsCreate(ctx context.Context) ApiEndpointsDeviceAccessGroupsCreateRequest {
	return ApiEndpointsDeviceAccessGroupsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DeviceAccessGroup
func (a *EndpointsApiService) EndpointsDeviceAccessGroupsCreateExecute(r ApiEndpointsDeviceAccessGroupsCreateRequest) (*DeviceAccessGroup, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeviceAccessGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsDeviceAccessGroupsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/device_access_groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceAccessGroupRequest == nil {
		return localVarReturnValue, nil, reportError("deviceAccessGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deviceAccessGroupRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsDeviceAccessGroupsDestroyRequest struct {
	ctx        context.Context
	ApiService *EndpointsApiService
	pbmUuid    string
}

func (r ApiEndpointsDeviceAccessGroupsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EndpointsDeviceAccessGroupsDestroyExecute(r)
}

/*
EndpointsDeviceAccessGroupsDestroy Method for EndpointsDeviceAccessGroupsDestroy

DeviceAccessGroup Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pbmUuid A UUID string identifying this Device access group.
	@return ApiEndpointsDeviceAccessGroupsDestroyRequest
*/
func (a *EndpointsApiService) EndpointsDeviceAccessGroupsDestroy(ctx context.Context, pbmUuid string) ApiEndpointsDeviceAccessGroupsDestroyRequest {
	return ApiEndpointsDeviceAccessGroupsDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		pbmUuid:    pbmUuid,
	}
}

// Execute executes the request
func (a *EndpointsApiService) EndpointsDeviceAccessGroupsDestroyExecute(r ApiEndpointsDeviceAccessGroupsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsDeviceAccessGroupsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/device_access_groups/{pbm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pbm_uuid"+"}", url.PathEscape(parameterToString(r.pbmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEndpointsDeviceAccessGroupsListRequest struct {
	ctx        context.Context
	ApiService *EndpointsApiService
	name       *string
	ordering   *string
	page       *int32
	pageSize   *int32
	pbmUuid    *string
	search     *string
}

func (r ApiEndpointsDeviceAccessGroupsListRequest) Name(name string) ApiEndpointsDeviceAccessGroupsListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiEndpointsDeviceAccessGroupsListRequest) Ordering(ordering string) ApiEndpointsDeviceAccessGroupsListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiEndpointsDeviceAccessGroupsListRequest) Page(page int32) ApiEndpointsDeviceAccessGroupsListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiEndpointsDeviceAccessGroupsListRequest) PageSize(pageSize int32) ApiEndpointsDeviceAccessGroupsListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiEndpointsDeviceAccessGroupsListRequest) PbmUuid(pbmUuid string) ApiEndpointsDeviceAccessGroupsListRequest {
	r.pbmUuid = &pbmUuid
	return r
}

// A search term.
func (r ApiEndpointsDeviceAccessGroupsListRequest) Search(search string) ApiEndpointsDeviceAccessGroupsListRequest {
	r.search = &search
	return r
}

func (r ApiEndpointsDeviceAccessGroupsListRequest) Execute() (*PaginatedDeviceAccessGroupList, *http.Response, error) {
	return r.ApiService.EndpointsDeviceAccessGroupsListExecute(r)
}

/*
EndpointsDeviceAccessGroupsList Method for EndpointsDeviceAccessGroupsList

DeviceAccessGroup Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEndpointsDeviceAccessGroupsListRequest
*/
func (a *EndpointsApiService) EndpointsDeviceAccessGroupsList(ctx context.Context) ApiEndpointsDeviceAccessGroupsListRequest {
	return ApiEndpointsDeviceAccessGroupsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedDeviceAccessGroupList
func (a *EndpointsApiService) EndpointsDeviceAccessGroupsListExecute(r ApiEndpointsDeviceAccessGroupsListRequest) (*PaginatedDeviceAccessGroupList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedDeviceAccessGroupList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsDeviceAccessGroupsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/device_access_groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pbmUuid != nil {
		localVarQueryParams.Add("pbm_uuid", parameterToString(*r.pbmUuid, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsDeviceAccessGroupsPartialUpdateRequest struct {
	ctx                             context.Context
	ApiService                      *EndpointsApiService
	pbmUuid                         string
	patchedDeviceAccessGroupRequest *PatchedDeviceAccessGroupRequest
}

func (r ApiEndpointsDeviceAccessGroupsPartialUpdateRequest) PatchedDeviceAccessGroupRequest(patchedDeviceAccessGroupRequest PatchedDeviceAccessGroupRequest) ApiEndpointsDeviceAccessGroupsPartialUpdateRequest {
	r.patchedDeviceAccessGroupRequest = &patchedDeviceAccessGroupRequest
	return r
}

func (r ApiEndpointsDeviceAccessGroupsPartialUpdateRequest) Execute() (*DeviceAccessGroup, *http.Response, error) {
	return r.ApiService.EndpointsDeviceAccessGroupsPartialUpdateExecute(r)
}

/*
EndpointsDeviceAccessGroupsPartialUpdate Method for EndpointsDeviceAccessGroupsPartialUpdate

DeviceAccessGroup Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pbmUuid A UUID string identifying this Device access group.
	@return ApiEndpointsDeviceAccessGroupsPartialUpdateRequest
*/
func (a *EndpointsApiService) EndpointsDeviceAccessGroupsPartialUpdate(ctx context.Context, pbmUuid string) ApiEndpointsDeviceAccessGroupsPartialUpdateRequest {
	return ApiEndpointsDeviceAccessGroupsPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pbmUuid:    pbmUuid,
	}
}

// Execute executes the request
//
//	@return DeviceAccessGroup
func (a *EndpointsApiService) EndpointsDeviceAccessGroupsPartialUpdateExecute(r ApiEndpointsDeviceAccessGroupsPartialUpdateRequest) (*DeviceAccessGroup, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeviceAccessGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsDeviceAccessGroupsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/device_access_groups/{pbm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pbm_uuid"+"}", url.PathEscape(parameterToString(r.pbmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedDeviceAccessGroupRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsDeviceAccessGroupsRetrieveRequest struct {
	ctx        context.Context
	ApiService *EndpointsApiService
	pbmUuid    string
}

func (r ApiEndpointsDeviceAccessGroupsRetrieveRequest) Execute() (*DeviceAccessGroup, *http.Response, error) {
	return r.ApiService.EndpointsDeviceAccessGroupsRetrieveExecute(r)
}

/*
EndpointsDeviceAccessGroupsRetrieve Method for EndpointsDeviceAccessGroupsRetrieve

DeviceAccessGroup Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pbmUuid A UUID string identifying this Device access group.
	@return ApiEndpointsDeviceAccessGroupsRetrieveRequest
*/
func (a *EndpointsApiService) EndpointsDeviceAccessGroupsRetrieve(ctx context.Context, pbmUuid string) ApiEndpointsDeviceAccessGroupsRetrieveRequest {
	return ApiEndpointsDeviceAccessGroupsRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		pbmUuid:    pbmUuid,
	}
}

// Execute executes the request
//
//	@return DeviceAccessGroup
func (a *EndpointsApiService) EndpointsDeviceAccessGroupsRetrieveExecute(r ApiEndpointsDeviceAccessGroupsRetrieveRequest) (*DeviceAccessGroup, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeviceAccessGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsDeviceAccessGroupsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/device_access_groups/{pbm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pbm_uuid"+"}", url.PathEscape(parameterToString(r.pbmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsDeviceAccessGroupsUpdateRequest struct {
	ctx                      context.Context
	ApiService               *EndpointsApiService
	pbmUuid                  string
	deviceAccessGroupRequest *DeviceAccessGroupRequest
}

func (r ApiEndpointsDeviceAccessGroupsUpdateRequest) DeviceAccessGroupRequest(deviceAccessGroupRequest DeviceAccessGroupRequest) ApiEndpointsDeviceAccessGroupsUpdateRequest {
	r.deviceAccessGroupRequest = &deviceAccessGroupRequest
	return r
}

func (r ApiEndpointsDeviceAccessGroupsUpdateRequest) Execute() (*DeviceAccessGroup, *http.Response, error) {
	return r.ApiService.EndpointsDeviceAccessGroupsUpdateExecute(r)
}

/*
EndpointsDeviceAccessGroupsUpdate Method for EndpointsDeviceAccessGroupsUpdate

DeviceAccessGroup Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pbmUuid A UUID string identifying this Device access group.
	@return ApiEndpointsDeviceAccessGroupsUpdateRequest
*/
func (a *EndpointsApiService) EndpointsDeviceAccessGroupsUpdate(ctx context.Context, pbmUuid string) ApiEndpointsDeviceAccessGroupsUpdateRequest {
	return ApiEndpointsDeviceAccessGroupsUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		pbmUuid:    pbmUuid,
	}
}

// Execute executes the request
//
//	@return DeviceAccessGroup
func (a *EndpointsApiService) EndpointsDeviceAccessGroupsUpdateExecute(r ApiEndpointsDeviceAccessGroupsUpdateRequest) (*DeviceAccessGroup, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeviceAccessGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsDeviceAccessGroupsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/device_access_groups/{pbm_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pbm_uuid"+"}", url.PathEscape(parameterToString(r.pbmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceAccessGroupRequest == nil {
		return localVarReturnValue, nil, reportError("deviceAccessGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deviceAccessGroupRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsDeviceAccessGroupsUsedByListRequest struct {
	ctx        context.Context
	ApiService *EndpointsApiService
	pbmUuid    string
}

func (r ApiEndpointsDeviceAccessGroupsUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.EndpointsDeviceAccessGroupsUsedByListExecute(r)
}

/*
EndpointsDeviceAccessGroupsUsedByList Method for EndpointsDeviceAccessGroupsUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pbmUuid A UUID string identifying this Device access group.
	@return ApiEndpointsDeviceAccessGroupsUsedByListRequest
*/
func (a *EndpointsApiService) EndpointsDeviceAccessGroupsUsedByList(ctx context.Context, pbmUuid string) ApiEndpointsDeviceAccessGroupsUsedByListRequest {
	return ApiEndpointsDeviceAccessGroupsUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		pbmUuid:    pbmUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *EndpointsApiService) EndpointsDeviceAccessGroupsUsedByListExecute(r ApiEndpointsDeviceAccessGroupsUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsDeviceAccessGroupsUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/device_access_groups/{pbm_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"pbm_uuid"+"}", url.PathEscape(parameterToString(r.pbmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsDeviceBindingsCreateRequest struct {
	ctx                  context.Context
	ApiService           *EndpointsApiService
	policyBindingRequest *PolicyBindingRequest
}

func (r ApiEndpointsDeviceBindingsCreateRequest) PolicyBindingRequest(policyBindingRequest PolicyBindingRequest) ApiEndpointsDeviceBindingsCreateRequest {
	r.policyBindingRequest = &policyBindingRequest
	return r
}

func (r ApiEndpointsDeviceBindingsCreateRequest) Execute() (*PolicyBinding, *http.Response, error) {
	return r.ApiService.EndpointsDeviceBindingsCreateExecute(r)
}

/*
EndpointsDeviceBindingsCreate Method for EndpointsDeviceBindingsCreate

PolicyBinding Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEndpointsDeviceBindingsCreateRequest
*/
func (a *EndpointsApiService) EndpointsDeviceBindingsCreate(ctx context.Context) ApiEndpointsDeviceBindingsCreateRequest {
	return ApiEndpointsDeviceBindingsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PolicyBinding
func (a *EndpointsApiService) EndpointsDeviceBindingsCreateExecute(r ApiEndpointsDeviceBindingsCreateRequest) (*PolicyBinding, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PolicyBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsDeviceBindingsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/device_bindings/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.policyBindingRequest == nil {
		return localVarReturnValue, nil, reportError("policyBindingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.policyBindingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsDeviceBindingsDestroyRequest struct {
	ctx               context.Context
	ApiService        *EndpointsApiService
	policyBindingUuid string
}

func (r ApiEndpointsDeviceBindingsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EndpointsDeviceBindingsDestroyExecute(r)
}

/*
EndpointsDeviceBindingsDestroy Method for EndpointsDeviceBindingsDestroy

PolicyBinding Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param policyBindingUuid A UUID string identifying this Device User binding.
	@return ApiEndpointsDeviceBindingsDestroyRequest
*/
func (a *EndpointsApiService) EndpointsDeviceBindingsDestroy(ctx context.Context, policyBindingUuid string) ApiEndpointsDeviceBindingsDestroyRequest {
	return ApiEndpointsDeviceBindingsDestroyRequest{
		ApiService:        a,
		ctx:               ctx,
		policyBindingUuid: policyBindingUuid,
	}
}

// Execute executes the request
func (a *EndpointsApiService) EndpointsDeviceBindingsDestroyExecute(r ApiEndpointsDeviceBindingsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsDeviceBindingsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/device_bindings/{policy_binding_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_binding_uuid"+"}", url.PathEscape(parameterToString(r.policyBindingUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEndpointsDeviceBindingsListRequest struct {
	ctx          context.Context
	ApiService   *EndpointsApiService
	enabled      *bool
	order        *int32
	ordering     *string
	page         *int32
	pageSize     *int32
	policy       *string
	policyIsnull *bool
	search       *string
	target       *string
	targetIn     *[]string
	timeout      *int32
}

func (r ApiEndpointsDeviceBindingsListRequest) Enabled(enabled bool) ApiEndpointsDeviceBindingsListRequest {
	r.enabled = &enabled
	return r
}

func (r ApiEndpointsDeviceBindingsListRequest) Order(order int32) ApiEndpointsDeviceBindingsListRequest {
	r.order = &order
	return r
}

// Which field to use when ordering the results.
func (r ApiEndpointsDeviceBindingsListRequest) Ordering(ordering string) ApiEndpointsDeviceBindingsListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiEndpointsDeviceBindingsListRequest) Page(page int32) ApiEndpointsDeviceBindingsListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiEndpointsDeviceBindingsListRequest) PageSize(pageSize int32) ApiEndpointsDeviceBindingsListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiEndpointsDeviceBindingsListRequest) Policy(policy string) ApiEndpointsDeviceBindingsListRequest {
	r.policy = &policy
	return r
}

func (r ApiEndpointsDeviceBindingsListRequest) PolicyIsnull(policyIsnull bool) ApiEndpointsDeviceBindingsListRequest {
	r.policyIsnull = &policyIsnull
	return r
}

// A search term.
func (r ApiEndpointsDeviceBindingsListRequest) Search(search string) ApiEndpointsDeviceBindingsListRequest {
	r.search = &search
	return r
}

func (r ApiEndpointsDeviceBindingsListRequest) Target(target string) ApiEndpointsDeviceBindingsListRequest {
	r.target = &target
	return r
}

func (r ApiEndpointsDeviceBindingsListRequest) TargetIn(targetIn []string) ApiEndpointsDeviceBindingsListRequest {
	r.targetIn = &targetIn
	return r
}

func (r ApiEndpointsDeviceBindingsListRequest) Timeout(timeout int32) ApiEndpointsDeviceBindingsListRequest {
	r.timeout = &timeout
	return r
}

func (r ApiEndpointsDeviceBindingsListRequest) Execute() (*PaginatedPolicyBindingList, *http.Response, error) {
	return r.ApiService.EndpointsDeviceBindingsListExecute(r)
}

/*
EndpointsDeviceBindingsList Method for EndpointsDeviceBindingsList

PolicyBinding Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEndpointsDeviceBindingsListRequest
*/
func (a *EndpointsApiService) EndpointsDeviceBindingsList(ctx context.Context) ApiEndpointsDeviceBindingsListRequest {
	return ApiEndpointsDeviceBindingsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedPolicyBindingList
func (a *EndpointsApiService) EndpointsDeviceBindingsListExecute(r ApiEndpointsDeviceBindingsListRequest) (*PaginatedPolicyBindingList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedPolicyBindingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsDeviceBindingsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/device_bindings/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.enabled != nil {
		localVarQueryParams.Add("enabled", parameterToString(*r.enabled, ""))
	}
	if r.order != nil {
		localVarQueryParams.Add("order", parameterToString(*r.order, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.policy != nil {
		localVarQueryParams.Add("policy", parameterToString(*r.policy, ""))
	}
	if r.policyIsnull != nil {
		localVarQueryParams.Add("policy__isnull", parameterToString(*r.policyIsnull, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.target != nil {
		localVarQueryParams.Add("target", parameterToString(*r.target, ""))
	}
	if r.targetIn != nil {
		t := *r.targetIn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("target_in", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("target_in", parameterToString(t, "multi"))
		}
	}
	if r.timeout != nil {
		localVarQueryParams.Add("timeout", parameterToString(*r.timeout, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsDeviceBindingsPartialUpdateRequest struct {
	ctx                         context.Context
	ApiService                  *EndpointsApiService
	policyBindingUuid           string
	patchedPolicyBindingRequest *PatchedPolicyBindingRequest
}

func (r ApiEndpointsDeviceBindingsPartialUpdateRequest) PatchedPolicyBindingRequest(patchedPolicyBindingRequest PatchedPolicyBindingRequest) ApiEndpointsDeviceBindingsPartialUpdateRequest {
	r.patchedPolicyBindingRequest = &patchedPolicyBindingRequest
	return r
}

func (r ApiEndpointsDeviceBindingsPartialUpdateRequest) Execute() (*PolicyBinding, *http.Response, error) {
	return r.ApiService.EndpointsDeviceBindingsPartialUpdateExecute(r)
}

/*
EndpointsDeviceBindingsPartialUpdate Method for EndpointsDeviceBindingsPartialUpdate

PolicyBinding Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param policyBindingUuid A UUID string identifying this Device User binding.
	@return ApiEndpointsDeviceBindingsPartialUpdateRequest
*/
func (a *EndpointsApiService) EndpointsDeviceBindingsPartialUpdate(ctx context.Context, policyBindingUuid string) ApiEndpointsDeviceBindingsPartialUpdateRequest {
	return ApiEndpointsDeviceBindingsPartialUpdateRequest{
		ApiService:        a,
		ctx:               ctx,
		policyBindingUuid: policyBindingUuid,
	}
}

// Execute executes the request
//
//	@return PolicyBinding
func (a *EndpointsApiService) EndpointsDeviceBindingsPartialUpdateExecute(r ApiEndpointsDeviceBindingsPartialUpdateRequest) (*PolicyBinding, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PolicyBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsDeviceBindingsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/device_bindings/{policy_binding_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_binding_uuid"+"}", url.PathEscape(parameterToString(r.policyBindingUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedPolicyBindingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsDeviceBindingsRetrieveRequest struct {
	ctx               context.Context
	ApiService        *EndpointsApiService
	policyBindingUuid string
}

func (r ApiEndpointsDeviceBindingsRetrieveRequest) Execute() (*PolicyBinding, *http.Response, error) {
	return r.ApiService.EndpointsDeviceBindingsRetrieveExecute(r)
}

/*
EndpointsDeviceBindingsRetrieve Method for EndpointsDeviceBindingsRetrieve

PolicyBinding Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param policyBindingUuid A UUID string identifying this Device User binding.
	@return ApiEndpointsDeviceBindingsRetrieveRequest
*/
func (a *EndpointsApiService) EndpointsDeviceBindingsRetrieve(ctx context.Context, policyBindingUuid string) ApiEndpointsDeviceBindingsRetrieveRequest {
	return ApiEndpointsDeviceBindingsRetrieveRequest{
		ApiService:        a,
		ctx:               ctx,
		policyBindingUuid: policyBindingUuid,
	}
}

// Execute executes the request
//
//	@return PolicyBinding
func (a *EndpointsApiService) EndpointsDeviceBindingsRetrieveExecute(r ApiEndpointsDeviceBindingsRetrieveRequest) (*PolicyBinding, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PolicyBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsDeviceBindingsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/device_bindings/{policy_binding_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_binding_uuid"+"}", url.PathEscape(parameterToString(r.policyBindingUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsDeviceBindingsUpdateRequest struct {
	ctx                  context.Context
	ApiService           *EndpointsApiService
	policyBindingUuid    string
	policyBindingRequest *PolicyBindingRequest
}

func (r ApiEndpointsDeviceBindingsUpdateRequest) PolicyBindingRequest(policyBindingRequest PolicyBindingRequest) ApiEndpointsDeviceBindingsUpdateRequest {
	r.policyBindingRequest = &policyBindingRequest
	return r
}

func (r ApiEndpointsDeviceBindingsUpdateRequest) Execute() (*PolicyBinding, *http.Response, error) {
	return r.ApiService.EndpointsDeviceBindingsUpdateExecute(r)
}

/*
EndpointsDeviceBindingsUpdate Method for EndpointsDeviceBindingsUpdate

PolicyBinding Viewset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param policyBindingUuid A UUID string identifying this Device User binding.
	@return ApiEndpointsDeviceBindingsUpdateRequest
*/
func (a *EndpointsApiService) EndpointsDeviceBindingsUpdate(ctx context.Context, policyBindingUuid string) ApiEndpointsDeviceBindingsUpdateRequest {
	return ApiEndpointsDeviceBindingsUpdateRequest{
		ApiService:        a,
		ctx:               ctx,
		policyBindingUuid: policyBindingUuid,
	}
}

// Execute executes the request
//
//	@return PolicyBinding
func (a *EndpointsApiService) EndpointsDeviceBindingsUpdateExecute(r ApiEndpointsDeviceBindingsUpdateRequest) (*PolicyBinding, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PolicyBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsDeviceBindingsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/device_bindings/{policy_binding_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_binding_uuid"+"}", url.PathEscape(parameterToString(r.policyBindingUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.policyBindingRequest == nil {
		return localVarReturnValue, nil, reportError("policyBindingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.policyBindingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsDeviceBindingsUsedByListRequest struct {
	ctx               context.Context
	ApiService        *EndpointsApiService
	policyBindingUuid string
}

func (r ApiEndpointsDeviceBindingsUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.EndpointsDeviceBindingsUsedByListExecute(r)
}

/*
EndpointsDeviceBindingsUsedByList Method for EndpointsDeviceBindingsUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param policyBindingUuid A UUID string identifying this Device User binding.
	@return ApiEndpointsDeviceBindingsUsedByListRequest
*/
func (a *EndpointsApiService) EndpointsDeviceBindingsUsedByList(ctx context.Context, policyBindingUuid string) ApiEndpointsDeviceBindingsUsedByListRequest {
	return ApiEndpointsDeviceBindingsUsedByListRequest{
		ApiService:        a,
		ctx:               ctx,
		policyBindingUuid: policyBindingUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *EndpointsApiService) EndpointsDeviceBindingsUsedByListExecute(r ApiEndpointsDeviceBindingsUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsDeviceBindingsUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/device_bindings/{policy_binding_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_binding_uuid"+"}", url.PathEscape(parameterToString(r.policyBindingUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsDevicesDestroyRequest struct {
	ctx        context.Context
	ApiService *EndpointsApiService
	deviceUuid string
}

func (r ApiEndpointsDevicesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EndpointsDevicesDestroyExecute(r)
}

/*
EndpointsDevicesDestroy Method for EndpointsDevicesDestroy

Mixin to add a used_by endpoint to return a list of all objects using this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceUuid A UUID string identifying this Device.
	@return ApiEndpointsDevicesDestroyRequest
*/
func (a *EndpointsApiService) EndpointsDevicesDestroy(ctx context.Context, deviceUuid string) ApiEndpointsDevicesDestroyRequest {
	return ApiEndpointsDevicesDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		deviceUuid: deviceUuid,
	}
}

// Execute executes the request
func (a *EndpointsApiService) EndpointsDevicesDestroyExecute(r ApiEndpointsDevicesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsDevicesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/devices/{device_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"device_uuid"+"}", url.PathEscape(parameterToString(r.deviceUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEndpointsDevicesListRequest struct {
	ctx        context.Context
	ApiService *EndpointsApiService
	identifier *string
	name       *string
	ordering   *string
	page       *int32
	pageSize   *int32
	search     *string
}

func (r ApiEndpointsDevicesListRequest) Identifier(identifier string) ApiEndpointsDevicesListRequest {
	r.identifier = &identifier
	return r
}

func (r ApiEndpointsDevicesListRequest) Name(name string) ApiEndpointsDevicesListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiEndpointsDevicesListRequest) Ordering(ordering string) ApiEndpointsDevicesListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiEndpointsDevicesListRequest) Page(page int32) ApiEndpointsDevicesListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiEndpointsDevicesListRequest) PageSize(pageSize int32) ApiEndpointsDevicesListRequest {
	r.pageSize = &pageSize
	return r
}

// A search term.
func (r ApiEndpointsDevicesListRequest) Search(search string) ApiEndpointsDevicesListRequest {
	r.search = &search
	return r
}

func (r ApiEndpointsDevicesListRequest) Execute() (*PaginatedEndpointDeviceList, *http.Response, error) {
	return r.ApiService.EndpointsDevicesListExecute(r)
}

/*
EndpointsDevicesList Method for EndpointsDevicesList

Mixin to add a used_by endpoint to return a list of all objects using this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEndpointsDevicesListRequest
*/
func (a *EndpointsApiService) EndpointsDevicesList(ctx context.Context) ApiEndpointsDevicesListRequest {
	return ApiEndpointsDevicesListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedEndpointDeviceList
func (a *EndpointsApiService) EndpointsDevicesListExecute(r ApiEndpointsDevicesListRequest) (*PaginatedEndpointDeviceList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedEndpointDeviceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsDevicesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/devices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.identifier != nil {
		localVarQueryParams.Add("identifier", parameterToString(*r.identifier, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsDevicesPartialUpdateRequest struct {
	ctx                          context.Context
	ApiService                   *EndpointsApiService
	deviceUuid                   string
	patchedEndpointDeviceRequest *PatchedEndpointDeviceRequest
}

func (r ApiEndpointsDevicesPartialUpdateRequest) PatchedEndpointDeviceRequest(patchedEndpointDeviceRequest PatchedEndpointDeviceRequest) ApiEndpointsDevicesPartialUpdateRequest {
	r.patchedEndpointDeviceRequest = &patchedEndpointDeviceRequest
	return r
}

func (r ApiEndpointsDevicesPartialUpdateRequest) Execute() (*EndpointDevice, *http.Response, error) {
	return r.ApiService.EndpointsDevicesPartialUpdateExecute(r)
}

/*
EndpointsDevicesPartialUpdate Method for EndpointsDevicesPartialUpdate

Mixin to add a used_by endpoint to return a list of all objects using this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceUuid A UUID string identifying this Device.
	@return ApiEndpointsDevicesPartialUpdateRequest
*/
func (a *EndpointsApiService) EndpointsDevicesPartialUpdate(ctx context.Context, deviceUuid string) ApiEndpointsDevicesPartialUpdateRequest {
	return ApiEndpointsDevicesPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		deviceUuid: deviceUuid,
	}
}

// Execute executes the request
//
//	@return EndpointDevice
func (a *EndpointsApiService) EndpointsDevicesPartialUpdateExecute(r ApiEndpointsDevicesPartialUpdateRequest) (*EndpointDevice, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EndpointDevice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsDevicesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/devices/{device_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"device_uuid"+"}", url.PathEscape(parameterToString(r.deviceUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedEndpointDeviceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsDevicesRetrieveRequest struct {
	ctx        context.Context
	ApiService *EndpointsApiService
	deviceUuid string
}

func (r ApiEndpointsDevicesRetrieveRequest) Execute() (*EndpointDeviceDetails, *http.Response, error) {
	return r.ApiService.EndpointsDevicesRetrieveExecute(r)
}

/*
EndpointsDevicesRetrieve Method for EndpointsDevicesRetrieve

Mixin to add a used_by endpoint to return a list of all objects using this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceUuid A UUID string identifying this Device.
	@return ApiEndpointsDevicesRetrieveRequest
*/
func (a *EndpointsApiService) EndpointsDevicesRetrieve(ctx context.Context, deviceUuid string) ApiEndpointsDevicesRetrieveRequest {
	return ApiEndpointsDevicesRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		deviceUuid: deviceUuid,
	}
}

// Execute executes the request
//
//	@return EndpointDeviceDetails
func (a *EndpointsApiService) EndpointsDevicesRetrieveExecute(r ApiEndpointsDevicesRetrieveRequest) (*EndpointDeviceDetails, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EndpointDeviceDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsDevicesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/devices/{device_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"device_uuid"+"}", url.PathEscape(parameterToString(r.deviceUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsDevicesUpdateRequest struct {
	ctx                   context.Context
	ApiService            *EndpointsApiService
	deviceUuid            string
	endpointDeviceRequest *EndpointDeviceRequest
}

func (r ApiEndpointsDevicesUpdateRequest) EndpointDeviceRequest(endpointDeviceRequest EndpointDeviceRequest) ApiEndpointsDevicesUpdateRequest {
	r.endpointDeviceRequest = &endpointDeviceRequest
	return r
}

func (r ApiEndpointsDevicesUpdateRequest) Execute() (*EndpointDevice, *http.Response, error) {
	return r.ApiService.EndpointsDevicesUpdateExecute(r)
}

/*
EndpointsDevicesUpdate Method for EndpointsDevicesUpdate

Mixin to add a used_by endpoint to return a list of all objects using this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceUuid A UUID string identifying this Device.
	@return ApiEndpointsDevicesUpdateRequest
*/
func (a *EndpointsApiService) EndpointsDevicesUpdate(ctx context.Context, deviceUuid string) ApiEndpointsDevicesUpdateRequest {
	return ApiEndpointsDevicesUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		deviceUuid: deviceUuid,
	}
}

// Execute executes the request
//
//	@return EndpointDevice
func (a *EndpointsApiService) EndpointsDevicesUpdateExecute(r ApiEndpointsDevicesUpdateRequest) (*EndpointDevice, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EndpointDevice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsDevicesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/devices/{device_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"device_uuid"+"}", url.PathEscape(parameterToString(r.deviceUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.endpointDeviceRequest == nil {
		return localVarReturnValue, nil, reportError("endpointDeviceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.endpointDeviceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsDevicesUsedByListRequest struct {
	ctx        context.Context
	ApiService *EndpointsApiService
	deviceUuid string
}

func (r ApiEndpointsDevicesUsedByListRequest) Execute() ([]UsedBy, *http.Response, error) {
	return r.ApiService.EndpointsDevicesUsedByListExecute(r)
}

/*
EndpointsDevicesUsedByList Method for EndpointsDevicesUsedByList

Get a list of all objects that use this object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceUuid A UUID string identifying this Device.
	@return ApiEndpointsDevicesUsedByListRequest
*/
func (a *EndpointsApiService) EndpointsDevicesUsedByList(ctx context.Context, deviceUuid string) ApiEndpointsDevicesUsedByListRequest {
	return ApiEndpointsDevicesUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		deviceUuid: deviceUuid,
	}
}

// Execute executes the request
//
//	@return []UsedBy
func (a *EndpointsApiService) EndpointsDevicesUsedByListExecute(r ApiEndpointsDevicesUsedByListRequest) ([]UsedBy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsApiService.EndpointsDevicesUsedByList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/endpoints/devices/{device_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"device_uuid"+"}", url.PathEscape(parameterToString(r.deviceUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenericError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
