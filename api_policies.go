/*
authentik

Making authentication simple.

API version: 2021.10.1
Contact: hello@beryju.org
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"reflect"
	"strings"
	"time"
)

// Linger please
var (
	_ _context.Context
)

// PoliciesApiService PoliciesApi service
type PoliciesApiService service

type ApiPoliciesAllCacheClearCreateRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
}

func (r ApiPoliciesAllCacheClearCreateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoliciesAllCacheClearCreateExecute(r)
}

/*
PoliciesAllCacheClearCreate Method for PoliciesAllCacheClearCreate

Clear policy cache

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPoliciesAllCacheClearCreateRequest
*/
func (a *PoliciesApiService) PoliciesAllCacheClearCreate(ctx _context.Context) ApiPoliciesAllCacheClearCreateRequest {
	return ApiPoliciesAllCacheClearCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PoliciesApiService) PoliciesAllCacheClearCreateExecute(r ApiPoliciesAllCacheClearCreateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesAllCacheClearCreate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/all/cache_clear/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoliciesAllCacheInfoRetrieveRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
}

func (r ApiPoliciesAllCacheInfoRetrieveRequest) Execute() (Cache, *_nethttp.Response, error) {
	return r.ApiService.PoliciesAllCacheInfoRetrieveExecute(r)
}

/*
PoliciesAllCacheInfoRetrieve Method for PoliciesAllCacheInfoRetrieve

Info about cached policies

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPoliciesAllCacheInfoRetrieveRequest
*/
func (a *PoliciesApiService) PoliciesAllCacheInfoRetrieve(ctx _context.Context) ApiPoliciesAllCacheInfoRetrieveRequest {
	return ApiPoliciesAllCacheInfoRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return Cache
func (a *PoliciesApiService) PoliciesAllCacheInfoRetrieveExecute(r ApiPoliciesAllCacheInfoRetrieveRequest) (Cache, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Cache
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesAllCacheInfoRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/all/cache_info/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesAllDestroyRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	policyUuid string
}

func (r ApiPoliciesAllDestroyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoliciesAllDestroyExecute(r)
}

/*
PoliciesAllDestroy Method for PoliciesAllDestroy

Policy Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Policy.
 @return ApiPoliciesAllDestroyRequest
*/
func (a *PoliciesApiService) PoliciesAllDestroy(ctx _context.Context, policyUuid string) ApiPoliciesAllDestroyRequest {
	return ApiPoliciesAllDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
func (a *PoliciesApiService) PoliciesAllDestroyExecute(r ApiPoliciesAllDestroyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesAllDestroy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/all/{policy_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoliciesAllListRequest struct {
	ctx               _context.Context
	ApiService        *PoliciesApiService
	bindingsIsnull    *bool
	ordering          *string
	page              *int32
	pageSize          *int32
	promptstageIsnull *bool
	search            *string
}

func (r ApiPoliciesAllListRequest) BindingsIsnull(bindingsIsnull bool) ApiPoliciesAllListRequest {
	r.bindingsIsnull = &bindingsIsnull
	return r
}

// Which field to use when ordering the results.
func (r ApiPoliciesAllListRequest) Ordering(ordering string) ApiPoliciesAllListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPoliciesAllListRequest) Page(page int32) ApiPoliciesAllListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPoliciesAllListRequest) PageSize(pageSize int32) ApiPoliciesAllListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiPoliciesAllListRequest) PromptstageIsnull(promptstageIsnull bool) ApiPoliciesAllListRequest {
	r.promptstageIsnull = &promptstageIsnull
	return r
}

// A search term.
func (r ApiPoliciesAllListRequest) Search(search string) ApiPoliciesAllListRequest {
	r.search = &search
	return r
}

func (r ApiPoliciesAllListRequest) Execute() (PaginatedPolicyList, *_nethttp.Response, error) {
	return r.ApiService.PoliciesAllListExecute(r)
}

/*
PoliciesAllList Method for PoliciesAllList

Policy Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPoliciesAllListRequest
*/
func (a *PoliciesApiService) PoliciesAllList(ctx _context.Context) ApiPoliciesAllListRequest {
	return ApiPoliciesAllListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaginatedPolicyList
func (a *PoliciesApiService) PoliciesAllListExecute(r ApiPoliciesAllListRequest) (PaginatedPolicyList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedPolicyList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesAllList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/all/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.bindingsIsnull != nil {
		localVarQueryParams.Add("bindings__isnull", parameterToString(*r.bindingsIsnull, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.promptstageIsnull != nil {
		localVarQueryParams.Add("promptstage__isnull", parameterToString(*r.promptstageIsnull, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesAllRetrieveRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	policyUuid string
}

func (r ApiPoliciesAllRetrieveRequest) Execute() (Policy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesAllRetrieveExecute(r)
}

/*
PoliciesAllRetrieve Method for PoliciesAllRetrieve

Policy Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Policy.
 @return ApiPoliciesAllRetrieveRequest
*/
func (a *PoliciesApiService) PoliciesAllRetrieve(ctx _context.Context, policyUuid string) ApiPoliciesAllRetrieveRequest {
	return ApiPoliciesAllRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return Policy
func (a *PoliciesApiService) PoliciesAllRetrieveExecute(r ApiPoliciesAllRetrieveRequest) (Policy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Policy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesAllRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/all/{policy_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesAllTestCreateRequest struct {
	ctx               _context.Context
	ApiService        *PoliciesApiService
	policyUuid        string
	policyTestRequest *PolicyTestRequest
}

func (r ApiPoliciesAllTestCreateRequest) PolicyTestRequest(policyTestRequest PolicyTestRequest) ApiPoliciesAllTestCreateRequest {
	r.policyTestRequest = &policyTestRequest
	return r
}

func (r ApiPoliciesAllTestCreateRequest) Execute() (PolicyTestResult, *_nethttp.Response, error) {
	return r.ApiService.PoliciesAllTestCreateExecute(r)
}

/*
PoliciesAllTestCreate Method for PoliciesAllTestCreate

Test policy

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Policy.
 @return ApiPoliciesAllTestCreateRequest
*/
func (a *PoliciesApiService) PoliciesAllTestCreate(ctx _context.Context, policyUuid string) ApiPoliciesAllTestCreateRequest {
	return ApiPoliciesAllTestCreateRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return PolicyTestResult
func (a *PoliciesApiService) PoliciesAllTestCreateExecute(r ApiPoliciesAllTestCreateRequest) (PolicyTestResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PolicyTestResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesAllTestCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/all/{policy_uuid}/test/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.policyTestRequest == nil {
		return localVarReturnValue, nil, reportError("policyTestRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.policyTestRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesAllTypesListRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
}

func (r ApiPoliciesAllTypesListRequest) Execute() ([]TypeCreate, *_nethttp.Response, error) {
	return r.ApiService.PoliciesAllTypesListExecute(r)
}

/*
PoliciesAllTypesList Method for PoliciesAllTypesList

Get all creatable policy types

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPoliciesAllTypesListRequest
*/
func (a *PoliciesApiService) PoliciesAllTypesList(ctx _context.Context) ApiPoliciesAllTypesListRequest {
	return ApiPoliciesAllTypesListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []TypeCreate
func (a *PoliciesApiService) PoliciesAllTypesListExecute(r ApiPoliciesAllTypesListRequest) ([]TypeCreate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []TypeCreate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesAllTypesList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/all/types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesAllUsedByListRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	policyUuid string
}

func (r ApiPoliciesAllUsedByListRequest) Execute() ([]UsedBy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesAllUsedByListExecute(r)
}

/*
PoliciesAllUsedByList Method for PoliciesAllUsedByList

Get a list of all objects that use this object

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Policy.
 @return ApiPoliciesAllUsedByListRequest
*/
func (a *PoliciesApiService) PoliciesAllUsedByList(ctx _context.Context, policyUuid string) ApiPoliciesAllUsedByListRequest {
	return ApiPoliciesAllUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return []UsedBy
func (a *PoliciesApiService) PoliciesAllUsedByListExecute(r ApiPoliciesAllUsedByListRequest) ([]UsedBy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesAllUsedByList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/all/{policy_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesBindingsCreateRequest struct {
	ctx                  _context.Context
	ApiService           *PoliciesApiService
	policyBindingRequest *PolicyBindingRequest
}

func (r ApiPoliciesBindingsCreateRequest) PolicyBindingRequest(policyBindingRequest PolicyBindingRequest) ApiPoliciesBindingsCreateRequest {
	r.policyBindingRequest = &policyBindingRequest
	return r
}

func (r ApiPoliciesBindingsCreateRequest) Execute() (PolicyBinding, *_nethttp.Response, error) {
	return r.ApiService.PoliciesBindingsCreateExecute(r)
}

/*
PoliciesBindingsCreate Method for PoliciesBindingsCreate

PolicyBinding Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPoliciesBindingsCreateRequest
*/
func (a *PoliciesApiService) PoliciesBindingsCreate(ctx _context.Context) ApiPoliciesBindingsCreateRequest {
	return ApiPoliciesBindingsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PolicyBinding
func (a *PoliciesApiService) PoliciesBindingsCreateExecute(r ApiPoliciesBindingsCreateRequest) (PolicyBinding, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PolicyBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesBindingsCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/bindings/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.policyBindingRequest == nil {
		return localVarReturnValue, nil, reportError("policyBindingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.policyBindingRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesBindingsDestroyRequest struct {
	ctx               _context.Context
	ApiService        *PoliciesApiService
	policyBindingUuid string
}

func (r ApiPoliciesBindingsDestroyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoliciesBindingsDestroyExecute(r)
}

/*
PoliciesBindingsDestroy Method for PoliciesBindingsDestroy

PolicyBinding Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyBindingUuid A UUID string identifying this Policy Binding.
 @return ApiPoliciesBindingsDestroyRequest
*/
func (a *PoliciesApiService) PoliciesBindingsDestroy(ctx _context.Context, policyBindingUuid string) ApiPoliciesBindingsDestroyRequest {
	return ApiPoliciesBindingsDestroyRequest{
		ApiService:        a,
		ctx:               ctx,
		policyBindingUuid: policyBindingUuid,
	}
}

// Execute executes the request
func (a *PoliciesApiService) PoliciesBindingsDestroyExecute(r ApiPoliciesBindingsDestroyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesBindingsDestroy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/bindings/{policy_binding_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_binding_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyBindingUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoliciesBindingsListRequest struct {
	ctx          _context.Context
	ApiService   *PoliciesApiService
	enabled      *bool
	order        *int32
	ordering     *string
	page         *int32
	pageSize     *int32
	policy       *string
	policyIsnull *bool
	search       *string
	target       *string
	targetIn     *[]string
	timeout      *int32
}

func (r ApiPoliciesBindingsListRequest) Enabled(enabled bool) ApiPoliciesBindingsListRequest {
	r.enabled = &enabled
	return r
}
func (r ApiPoliciesBindingsListRequest) Order(order int32) ApiPoliciesBindingsListRequest {
	r.order = &order
	return r
}

// Which field to use when ordering the results.
func (r ApiPoliciesBindingsListRequest) Ordering(ordering string) ApiPoliciesBindingsListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPoliciesBindingsListRequest) Page(page int32) ApiPoliciesBindingsListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPoliciesBindingsListRequest) PageSize(pageSize int32) ApiPoliciesBindingsListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiPoliciesBindingsListRequest) Policy(policy string) ApiPoliciesBindingsListRequest {
	r.policy = &policy
	return r
}
func (r ApiPoliciesBindingsListRequest) PolicyIsnull(policyIsnull bool) ApiPoliciesBindingsListRequest {
	r.policyIsnull = &policyIsnull
	return r
}

// A search term.
func (r ApiPoliciesBindingsListRequest) Search(search string) ApiPoliciesBindingsListRequest {
	r.search = &search
	return r
}
func (r ApiPoliciesBindingsListRequest) Target(target string) ApiPoliciesBindingsListRequest {
	r.target = &target
	return r
}
func (r ApiPoliciesBindingsListRequest) TargetIn(targetIn []string) ApiPoliciesBindingsListRequest {
	r.targetIn = &targetIn
	return r
}
func (r ApiPoliciesBindingsListRequest) Timeout(timeout int32) ApiPoliciesBindingsListRequest {
	r.timeout = &timeout
	return r
}

func (r ApiPoliciesBindingsListRequest) Execute() (PaginatedPolicyBindingList, *_nethttp.Response, error) {
	return r.ApiService.PoliciesBindingsListExecute(r)
}

/*
PoliciesBindingsList Method for PoliciesBindingsList

PolicyBinding Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPoliciesBindingsListRequest
*/
func (a *PoliciesApiService) PoliciesBindingsList(ctx _context.Context) ApiPoliciesBindingsListRequest {
	return ApiPoliciesBindingsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaginatedPolicyBindingList
func (a *PoliciesApiService) PoliciesBindingsListExecute(r ApiPoliciesBindingsListRequest) (PaginatedPolicyBindingList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedPolicyBindingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesBindingsList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/bindings/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.enabled != nil {
		localVarQueryParams.Add("enabled", parameterToString(*r.enabled, ""))
	}
	if r.order != nil {
		localVarQueryParams.Add("order", parameterToString(*r.order, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.policy != nil {
		localVarQueryParams.Add("policy", parameterToString(*r.policy, ""))
	}
	if r.policyIsnull != nil {
		localVarQueryParams.Add("policy__isnull", parameterToString(*r.policyIsnull, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.target != nil {
		localVarQueryParams.Add("target", parameterToString(*r.target, ""))
	}
	if r.targetIn != nil {
		t := *r.targetIn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("target_in", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("target_in", parameterToString(t, "multi"))
		}
	}
	if r.timeout != nil {
		localVarQueryParams.Add("timeout", parameterToString(*r.timeout, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesBindingsPartialUpdateRequest struct {
	ctx                         _context.Context
	ApiService                  *PoliciesApiService
	policyBindingUuid           string
	patchedPolicyBindingRequest *PatchedPolicyBindingRequest
}

func (r ApiPoliciesBindingsPartialUpdateRequest) PatchedPolicyBindingRequest(patchedPolicyBindingRequest PatchedPolicyBindingRequest) ApiPoliciesBindingsPartialUpdateRequest {
	r.patchedPolicyBindingRequest = &patchedPolicyBindingRequest
	return r
}

func (r ApiPoliciesBindingsPartialUpdateRequest) Execute() (PolicyBinding, *_nethttp.Response, error) {
	return r.ApiService.PoliciesBindingsPartialUpdateExecute(r)
}

/*
PoliciesBindingsPartialUpdate Method for PoliciesBindingsPartialUpdate

PolicyBinding Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyBindingUuid A UUID string identifying this Policy Binding.
 @return ApiPoliciesBindingsPartialUpdateRequest
*/
func (a *PoliciesApiService) PoliciesBindingsPartialUpdate(ctx _context.Context, policyBindingUuid string) ApiPoliciesBindingsPartialUpdateRequest {
	return ApiPoliciesBindingsPartialUpdateRequest{
		ApiService:        a,
		ctx:               ctx,
		policyBindingUuid: policyBindingUuid,
	}
}

// Execute executes the request
//  @return PolicyBinding
func (a *PoliciesApiService) PoliciesBindingsPartialUpdateExecute(r ApiPoliciesBindingsPartialUpdateRequest) (PolicyBinding, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PolicyBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesBindingsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/bindings/{policy_binding_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_binding_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyBindingUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedPolicyBindingRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesBindingsRetrieveRequest struct {
	ctx               _context.Context
	ApiService        *PoliciesApiService
	policyBindingUuid string
}

func (r ApiPoliciesBindingsRetrieveRequest) Execute() (PolicyBinding, *_nethttp.Response, error) {
	return r.ApiService.PoliciesBindingsRetrieveExecute(r)
}

/*
PoliciesBindingsRetrieve Method for PoliciesBindingsRetrieve

PolicyBinding Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyBindingUuid A UUID string identifying this Policy Binding.
 @return ApiPoliciesBindingsRetrieveRequest
*/
func (a *PoliciesApiService) PoliciesBindingsRetrieve(ctx _context.Context, policyBindingUuid string) ApiPoliciesBindingsRetrieveRequest {
	return ApiPoliciesBindingsRetrieveRequest{
		ApiService:        a,
		ctx:               ctx,
		policyBindingUuid: policyBindingUuid,
	}
}

// Execute executes the request
//  @return PolicyBinding
func (a *PoliciesApiService) PoliciesBindingsRetrieveExecute(r ApiPoliciesBindingsRetrieveRequest) (PolicyBinding, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PolicyBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesBindingsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/bindings/{policy_binding_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_binding_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyBindingUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesBindingsUpdateRequest struct {
	ctx                  _context.Context
	ApiService           *PoliciesApiService
	policyBindingUuid    string
	policyBindingRequest *PolicyBindingRequest
}

func (r ApiPoliciesBindingsUpdateRequest) PolicyBindingRequest(policyBindingRequest PolicyBindingRequest) ApiPoliciesBindingsUpdateRequest {
	r.policyBindingRequest = &policyBindingRequest
	return r
}

func (r ApiPoliciesBindingsUpdateRequest) Execute() (PolicyBinding, *_nethttp.Response, error) {
	return r.ApiService.PoliciesBindingsUpdateExecute(r)
}

/*
PoliciesBindingsUpdate Method for PoliciesBindingsUpdate

PolicyBinding Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyBindingUuid A UUID string identifying this Policy Binding.
 @return ApiPoliciesBindingsUpdateRequest
*/
func (a *PoliciesApiService) PoliciesBindingsUpdate(ctx _context.Context, policyBindingUuid string) ApiPoliciesBindingsUpdateRequest {
	return ApiPoliciesBindingsUpdateRequest{
		ApiService:        a,
		ctx:               ctx,
		policyBindingUuid: policyBindingUuid,
	}
}

// Execute executes the request
//  @return PolicyBinding
func (a *PoliciesApiService) PoliciesBindingsUpdateExecute(r ApiPoliciesBindingsUpdateRequest) (PolicyBinding, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PolicyBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesBindingsUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/bindings/{policy_binding_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_binding_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyBindingUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.policyBindingRequest == nil {
		return localVarReturnValue, nil, reportError("policyBindingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.policyBindingRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesBindingsUsedByListRequest struct {
	ctx               _context.Context
	ApiService        *PoliciesApiService
	policyBindingUuid string
}

func (r ApiPoliciesBindingsUsedByListRequest) Execute() ([]UsedBy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesBindingsUsedByListExecute(r)
}

/*
PoliciesBindingsUsedByList Method for PoliciesBindingsUsedByList

Get a list of all objects that use this object

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyBindingUuid A UUID string identifying this Policy Binding.
 @return ApiPoliciesBindingsUsedByListRequest
*/
func (a *PoliciesApiService) PoliciesBindingsUsedByList(ctx _context.Context, policyBindingUuid string) ApiPoliciesBindingsUsedByListRequest {
	return ApiPoliciesBindingsUsedByListRequest{
		ApiService:        a,
		ctx:               ctx,
		policyBindingUuid: policyBindingUuid,
	}
}

// Execute executes the request
//  @return []UsedBy
func (a *PoliciesApiService) PoliciesBindingsUsedByListExecute(r ApiPoliciesBindingsUsedByListRequest) ([]UsedBy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesBindingsUsedByList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/bindings/{policy_binding_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_binding_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyBindingUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesDummyCreateRequest struct {
	ctx                _context.Context
	ApiService         *PoliciesApiService
	dummyPolicyRequest *DummyPolicyRequest
}

func (r ApiPoliciesDummyCreateRequest) DummyPolicyRequest(dummyPolicyRequest DummyPolicyRequest) ApiPoliciesDummyCreateRequest {
	r.dummyPolicyRequest = &dummyPolicyRequest
	return r
}

func (r ApiPoliciesDummyCreateRequest) Execute() (DummyPolicy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesDummyCreateExecute(r)
}

/*
PoliciesDummyCreate Method for PoliciesDummyCreate

Dummy Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPoliciesDummyCreateRequest
*/
func (a *PoliciesApiService) PoliciesDummyCreate(ctx _context.Context) ApiPoliciesDummyCreateRequest {
	return ApiPoliciesDummyCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return DummyPolicy
func (a *PoliciesApiService) PoliciesDummyCreateExecute(r ApiPoliciesDummyCreateRequest) (DummyPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DummyPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesDummyCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/dummy/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dummyPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesDummyDestroyRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	policyUuid string
}

func (r ApiPoliciesDummyDestroyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoliciesDummyDestroyExecute(r)
}

/*
PoliciesDummyDestroy Method for PoliciesDummyDestroy

Dummy Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Dummy Policy.
 @return ApiPoliciesDummyDestroyRequest
*/
func (a *PoliciesApiService) PoliciesDummyDestroy(ctx _context.Context, policyUuid string) ApiPoliciesDummyDestroyRequest {
	return ApiPoliciesDummyDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
func (a *PoliciesApiService) PoliciesDummyDestroyExecute(r ApiPoliciesDummyDestroyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesDummyDestroy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/dummy/{policy_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoliciesDummyListRequest struct {
	ctx              _context.Context
	ApiService       *PoliciesApiService
	created          *time.Time
	executionLogging *bool
	lastUpdated      *time.Time
	name             *string
	ordering         *string
	page             *int32
	pageSize         *int32
	policyUuid       *string
	result           *bool
	search           *string
	waitMax          *int32
	waitMin          *int32
}

func (r ApiPoliciesDummyListRequest) Created(created time.Time) ApiPoliciesDummyListRequest {
	r.created = &created
	return r
}
func (r ApiPoliciesDummyListRequest) ExecutionLogging(executionLogging bool) ApiPoliciesDummyListRequest {
	r.executionLogging = &executionLogging
	return r
}
func (r ApiPoliciesDummyListRequest) LastUpdated(lastUpdated time.Time) ApiPoliciesDummyListRequest {
	r.lastUpdated = &lastUpdated
	return r
}
func (r ApiPoliciesDummyListRequest) Name(name string) ApiPoliciesDummyListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPoliciesDummyListRequest) Ordering(ordering string) ApiPoliciesDummyListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPoliciesDummyListRequest) Page(page int32) ApiPoliciesDummyListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPoliciesDummyListRequest) PageSize(pageSize int32) ApiPoliciesDummyListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiPoliciesDummyListRequest) PolicyUuid(policyUuid string) ApiPoliciesDummyListRequest {
	r.policyUuid = &policyUuid
	return r
}
func (r ApiPoliciesDummyListRequest) Result(result bool) ApiPoliciesDummyListRequest {
	r.result = &result
	return r
}

// A search term.
func (r ApiPoliciesDummyListRequest) Search(search string) ApiPoliciesDummyListRequest {
	r.search = &search
	return r
}
func (r ApiPoliciesDummyListRequest) WaitMax(waitMax int32) ApiPoliciesDummyListRequest {
	r.waitMax = &waitMax
	return r
}
func (r ApiPoliciesDummyListRequest) WaitMin(waitMin int32) ApiPoliciesDummyListRequest {
	r.waitMin = &waitMin
	return r
}

func (r ApiPoliciesDummyListRequest) Execute() (PaginatedDummyPolicyList, *_nethttp.Response, error) {
	return r.ApiService.PoliciesDummyListExecute(r)
}

/*
PoliciesDummyList Method for PoliciesDummyList

Dummy Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPoliciesDummyListRequest
*/
func (a *PoliciesApiService) PoliciesDummyList(ctx _context.Context) ApiPoliciesDummyListRequest {
	return ApiPoliciesDummyListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaginatedDummyPolicyList
func (a *PoliciesApiService) PoliciesDummyListExecute(r ApiPoliciesDummyListRequest) (PaginatedDummyPolicyList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedDummyPolicyList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesDummyList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/dummy/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.executionLogging != nil {
		localVarQueryParams.Add("execution_logging", parameterToString(*r.executionLogging, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.policyUuid != nil {
		localVarQueryParams.Add("policy_uuid", parameterToString(*r.policyUuid, ""))
	}
	if r.result != nil {
		localVarQueryParams.Add("result", parameterToString(*r.result, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.waitMax != nil {
		localVarQueryParams.Add("wait_max", parameterToString(*r.waitMax, ""))
	}
	if r.waitMin != nil {
		localVarQueryParams.Add("wait_min", parameterToString(*r.waitMin, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesDummyPartialUpdateRequest struct {
	ctx                       _context.Context
	ApiService                *PoliciesApiService
	policyUuid                string
	patchedDummyPolicyRequest *PatchedDummyPolicyRequest
}

func (r ApiPoliciesDummyPartialUpdateRequest) PatchedDummyPolicyRequest(patchedDummyPolicyRequest PatchedDummyPolicyRequest) ApiPoliciesDummyPartialUpdateRequest {
	r.patchedDummyPolicyRequest = &patchedDummyPolicyRequest
	return r
}

func (r ApiPoliciesDummyPartialUpdateRequest) Execute() (DummyPolicy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesDummyPartialUpdateExecute(r)
}

/*
PoliciesDummyPartialUpdate Method for PoliciesDummyPartialUpdate

Dummy Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Dummy Policy.
 @return ApiPoliciesDummyPartialUpdateRequest
*/
func (a *PoliciesApiService) PoliciesDummyPartialUpdate(ctx _context.Context, policyUuid string) ApiPoliciesDummyPartialUpdateRequest {
	return ApiPoliciesDummyPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return DummyPolicy
func (a *PoliciesApiService) PoliciesDummyPartialUpdateExecute(r ApiPoliciesDummyPartialUpdateRequest) (DummyPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DummyPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesDummyPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/dummy/{policy_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedDummyPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesDummyRetrieveRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	policyUuid string
}

func (r ApiPoliciesDummyRetrieveRequest) Execute() (DummyPolicy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesDummyRetrieveExecute(r)
}

/*
PoliciesDummyRetrieve Method for PoliciesDummyRetrieve

Dummy Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Dummy Policy.
 @return ApiPoliciesDummyRetrieveRequest
*/
func (a *PoliciesApiService) PoliciesDummyRetrieve(ctx _context.Context, policyUuid string) ApiPoliciesDummyRetrieveRequest {
	return ApiPoliciesDummyRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return DummyPolicy
func (a *PoliciesApiService) PoliciesDummyRetrieveExecute(r ApiPoliciesDummyRetrieveRequest) (DummyPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DummyPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesDummyRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/dummy/{policy_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesDummyUpdateRequest struct {
	ctx                _context.Context
	ApiService         *PoliciesApiService
	policyUuid         string
	dummyPolicyRequest *DummyPolicyRequest
}

func (r ApiPoliciesDummyUpdateRequest) DummyPolicyRequest(dummyPolicyRequest DummyPolicyRequest) ApiPoliciesDummyUpdateRequest {
	r.dummyPolicyRequest = &dummyPolicyRequest
	return r
}

func (r ApiPoliciesDummyUpdateRequest) Execute() (DummyPolicy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesDummyUpdateExecute(r)
}

/*
PoliciesDummyUpdate Method for PoliciesDummyUpdate

Dummy Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Dummy Policy.
 @return ApiPoliciesDummyUpdateRequest
*/
func (a *PoliciesApiService) PoliciesDummyUpdate(ctx _context.Context, policyUuid string) ApiPoliciesDummyUpdateRequest {
	return ApiPoliciesDummyUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return DummyPolicy
func (a *PoliciesApiService) PoliciesDummyUpdateExecute(r ApiPoliciesDummyUpdateRequest) (DummyPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DummyPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesDummyUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/dummy/{policy_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dummyPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesDummyUsedByListRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	policyUuid string
}

func (r ApiPoliciesDummyUsedByListRequest) Execute() ([]UsedBy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesDummyUsedByListExecute(r)
}

/*
PoliciesDummyUsedByList Method for PoliciesDummyUsedByList

Get a list of all objects that use this object

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Dummy Policy.
 @return ApiPoliciesDummyUsedByListRequest
*/
func (a *PoliciesApiService) PoliciesDummyUsedByList(ctx _context.Context, policyUuid string) ApiPoliciesDummyUsedByListRequest {
	return ApiPoliciesDummyUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return []UsedBy
func (a *PoliciesApiService) PoliciesDummyUsedByListExecute(r ApiPoliciesDummyUsedByListRequest) ([]UsedBy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesDummyUsedByList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/dummy/{policy_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesEventMatcherCreateRequest struct {
	ctx                       _context.Context
	ApiService                *PoliciesApiService
	eventMatcherPolicyRequest *EventMatcherPolicyRequest
}

func (r ApiPoliciesEventMatcherCreateRequest) EventMatcherPolicyRequest(eventMatcherPolicyRequest EventMatcherPolicyRequest) ApiPoliciesEventMatcherCreateRequest {
	r.eventMatcherPolicyRequest = &eventMatcherPolicyRequest
	return r
}

func (r ApiPoliciesEventMatcherCreateRequest) Execute() (EventMatcherPolicy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesEventMatcherCreateExecute(r)
}

/*
PoliciesEventMatcherCreate Method for PoliciesEventMatcherCreate

Event Matcher Policy Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPoliciesEventMatcherCreateRequest
*/
func (a *PoliciesApiService) PoliciesEventMatcherCreate(ctx _context.Context) ApiPoliciesEventMatcherCreateRequest {
	return ApiPoliciesEventMatcherCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return EventMatcherPolicy
func (a *PoliciesApiService) PoliciesEventMatcherCreateExecute(r ApiPoliciesEventMatcherCreateRequest) (EventMatcherPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  EventMatcherPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesEventMatcherCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/event_matcher/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.eventMatcherPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesEventMatcherDestroyRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	policyUuid string
}

func (r ApiPoliciesEventMatcherDestroyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoliciesEventMatcherDestroyExecute(r)
}

/*
PoliciesEventMatcherDestroy Method for PoliciesEventMatcherDestroy

Event Matcher Policy Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Event Matcher Policy.
 @return ApiPoliciesEventMatcherDestroyRequest
*/
func (a *PoliciesApiService) PoliciesEventMatcherDestroy(ctx _context.Context, policyUuid string) ApiPoliciesEventMatcherDestroyRequest {
	return ApiPoliciesEventMatcherDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
func (a *PoliciesApiService) PoliciesEventMatcherDestroyExecute(r ApiPoliciesEventMatcherDestroyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesEventMatcherDestroy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/event_matcher/{policy_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoliciesEventMatcherListRequest struct {
	ctx              _context.Context
	ApiService       *PoliciesApiService
	action           *string
	app              *string
	clientIp         *string
	created          *time.Time
	executionLogging *bool
	lastUpdated      *time.Time
	name             *string
	ordering         *string
	page             *int32
	pageSize         *int32
	policyUuid       *string
	search           *string
}

// Match created events with this action type. When left empty, all action types will be matched.
func (r ApiPoliciesEventMatcherListRequest) Action(action string) ApiPoliciesEventMatcherListRequest {
	r.action = &action
	return r
}

// Match events created by selected application. When left empty, all applications are matched.
func (r ApiPoliciesEventMatcherListRequest) App(app string) ApiPoliciesEventMatcherListRequest {
	r.app = &app
	return r
}
func (r ApiPoliciesEventMatcherListRequest) ClientIp(clientIp string) ApiPoliciesEventMatcherListRequest {
	r.clientIp = &clientIp
	return r
}
func (r ApiPoliciesEventMatcherListRequest) Created(created time.Time) ApiPoliciesEventMatcherListRequest {
	r.created = &created
	return r
}
func (r ApiPoliciesEventMatcherListRequest) ExecutionLogging(executionLogging bool) ApiPoliciesEventMatcherListRequest {
	r.executionLogging = &executionLogging
	return r
}
func (r ApiPoliciesEventMatcherListRequest) LastUpdated(lastUpdated time.Time) ApiPoliciesEventMatcherListRequest {
	r.lastUpdated = &lastUpdated
	return r
}
func (r ApiPoliciesEventMatcherListRequest) Name(name string) ApiPoliciesEventMatcherListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPoliciesEventMatcherListRequest) Ordering(ordering string) ApiPoliciesEventMatcherListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPoliciesEventMatcherListRequest) Page(page int32) ApiPoliciesEventMatcherListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPoliciesEventMatcherListRequest) PageSize(pageSize int32) ApiPoliciesEventMatcherListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiPoliciesEventMatcherListRequest) PolicyUuid(policyUuid string) ApiPoliciesEventMatcherListRequest {
	r.policyUuid = &policyUuid
	return r
}

// A search term.
func (r ApiPoliciesEventMatcherListRequest) Search(search string) ApiPoliciesEventMatcherListRequest {
	r.search = &search
	return r
}

func (r ApiPoliciesEventMatcherListRequest) Execute() (PaginatedEventMatcherPolicyList, *_nethttp.Response, error) {
	return r.ApiService.PoliciesEventMatcherListExecute(r)
}

/*
PoliciesEventMatcherList Method for PoliciesEventMatcherList

Event Matcher Policy Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPoliciesEventMatcherListRequest
*/
func (a *PoliciesApiService) PoliciesEventMatcherList(ctx _context.Context) ApiPoliciesEventMatcherListRequest {
	return ApiPoliciesEventMatcherListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaginatedEventMatcherPolicyList
func (a *PoliciesApiService) PoliciesEventMatcherListExecute(r ApiPoliciesEventMatcherListRequest) (PaginatedEventMatcherPolicyList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedEventMatcherPolicyList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesEventMatcherList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/event_matcher/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.action != nil {
		localVarQueryParams.Add("action", parameterToString(*r.action, ""))
	}
	if r.app != nil {
		localVarQueryParams.Add("app", parameterToString(*r.app, ""))
	}
	if r.clientIp != nil {
		localVarQueryParams.Add("client_ip", parameterToString(*r.clientIp, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.executionLogging != nil {
		localVarQueryParams.Add("execution_logging", parameterToString(*r.executionLogging, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.policyUuid != nil {
		localVarQueryParams.Add("policy_uuid", parameterToString(*r.policyUuid, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesEventMatcherPartialUpdateRequest struct {
	ctx                              _context.Context
	ApiService                       *PoliciesApiService
	policyUuid                       string
	patchedEventMatcherPolicyRequest *PatchedEventMatcherPolicyRequest
}

func (r ApiPoliciesEventMatcherPartialUpdateRequest) PatchedEventMatcherPolicyRequest(patchedEventMatcherPolicyRequest PatchedEventMatcherPolicyRequest) ApiPoliciesEventMatcherPartialUpdateRequest {
	r.patchedEventMatcherPolicyRequest = &patchedEventMatcherPolicyRequest
	return r
}

func (r ApiPoliciesEventMatcherPartialUpdateRequest) Execute() (EventMatcherPolicy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesEventMatcherPartialUpdateExecute(r)
}

/*
PoliciesEventMatcherPartialUpdate Method for PoliciesEventMatcherPartialUpdate

Event Matcher Policy Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Event Matcher Policy.
 @return ApiPoliciesEventMatcherPartialUpdateRequest
*/
func (a *PoliciesApiService) PoliciesEventMatcherPartialUpdate(ctx _context.Context, policyUuid string) ApiPoliciesEventMatcherPartialUpdateRequest {
	return ApiPoliciesEventMatcherPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return EventMatcherPolicy
func (a *PoliciesApiService) PoliciesEventMatcherPartialUpdateExecute(r ApiPoliciesEventMatcherPartialUpdateRequest) (EventMatcherPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  EventMatcherPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesEventMatcherPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/event_matcher/{policy_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedEventMatcherPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesEventMatcherRetrieveRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	policyUuid string
}

func (r ApiPoliciesEventMatcherRetrieveRequest) Execute() (EventMatcherPolicy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesEventMatcherRetrieveExecute(r)
}

/*
PoliciesEventMatcherRetrieve Method for PoliciesEventMatcherRetrieve

Event Matcher Policy Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Event Matcher Policy.
 @return ApiPoliciesEventMatcherRetrieveRequest
*/
func (a *PoliciesApiService) PoliciesEventMatcherRetrieve(ctx _context.Context, policyUuid string) ApiPoliciesEventMatcherRetrieveRequest {
	return ApiPoliciesEventMatcherRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return EventMatcherPolicy
func (a *PoliciesApiService) PoliciesEventMatcherRetrieveExecute(r ApiPoliciesEventMatcherRetrieveRequest) (EventMatcherPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  EventMatcherPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesEventMatcherRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/event_matcher/{policy_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesEventMatcherUpdateRequest struct {
	ctx                       _context.Context
	ApiService                *PoliciesApiService
	policyUuid                string
	eventMatcherPolicyRequest *EventMatcherPolicyRequest
}

func (r ApiPoliciesEventMatcherUpdateRequest) EventMatcherPolicyRequest(eventMatcherPolicyRequest EventMatcherPolicyRequest) ApiPoliciesEventMatcherUpdateRequest {
	r.eventMatcherPolicyRequest = &eventMatcherPolicyRequest
	return r
}

func (r ApiPoliciesEventMatcherUpdateRequest) Execute() (EventMatcherPolicy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesEventMatcherUpdateExecute(r)
}

/*
PoliciesEventMatcherUpdate Method for PoliciesEventMatcherUpdate

Event Matcher Policy Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Event Matcher Policy.
 @return ApiPoliciesEventMatcherUpdateRequest
*/
func (a *PoliciesApiService) PoliciesEventMatcherUpdate(ctx _context.Context, policyUuid string) ApiPoliciesEventMatcherUpdateRequest {
	return ApiPoliciesEventMatcherUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return EventMatcherPolicy
func (a *PoliciesApiService) PoliciesEventMatcherUpdateExecute(r ApiPoliciesEventMatcherUpdateRequest) (EventMatcherPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  EventMatcherPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesEventMatcherUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/event_matcher/{policy_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.eventMatcherPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesEventMatcherUsedByListRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	policyUuid string
}

func (r ApiPoliciesEventMatcherUsedByListRequest) Execute() ([]UsedBy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesEventMatcherUsedByListExecute(r)
}

/*
PoliciesEventMatcherUsedByList Method for PoliciesEventMatcherUsedByList

Get a list of all objects that use this object

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Event Matcher Policy.
 @return ApiPoliciesEventMatcherUsedByListRequest
*/
func (a *PoliciesApiService) PoliciesEventMatcherUsedByList(ctx _context.Context, policyUuid string) ApiPoliciesEventMatcherUsedByListRequest {
	return ApiPoliciesEventMatcherUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return []UsedBy
func (a *PoliciesApiService) PoliciesEventMatcherUsedByListExecute(r ApiPoliciesEventMatcherUsedByListRequest) ([]UsedBy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesEventMatcherUsedByList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/event_matcher/{policy_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesExpressionCreateRequest struct {
	ctx                     _context.Context
	ApiService              *PoliciesApiService
	expressionPolicyRequest *ExpressionPolicyRequest
}

func (r ApiPoliciesExpressionCreateRequest) ExpressionPolicyRequest(expressionPolicyRequest ExpressionPolicyRequest) ApiPoliciesExpressionCreateRequest {
	r.expressionPolicyRequest = &expressionPolicyRequest
	return r
}

func (r ApiPoliciesExpressionCreateRequest) Execute() (ExpressionPolicy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesExpressionCreateExecute(r)
}

/*
PoliciesExpressionCreate Method for PoliciesExpressionCreate

Source Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPoliciesExpressionCreateRequest
*/
func (a *PoliciesApiService) PoliciesExpressionCreate(ctx _context.Context) ApiPoliciesExpressionCreateRequest {
	return ApiPoliciesExpressionCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ExpressionPolicy
func (a *PoliciesApiService) PoliciesExpressionCreateExecute(r ApiPoliciesExpressionCreateRequest) (ExpressionPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ExpressionPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesExpressionCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/expression/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.expressionPolicyRequest == nil {
		return localVarReturnValue, nil, reportError("expressionPolicyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.expressionPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesExpressionDestroyRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	policyUuid string
}

func (r ApiPoliciesExpressionDestroyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoliciesExpressionDestroyExecute(r)
}

/*
PoliciesExpressionDestroy Method for PoliciesExpressionDestroy

Source Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Expression Policy.
 @return ApiPoliciesExpressionDestroyRequest
*/
func (a *PoliciesApiService) PoliciesExpressionDestroy(ctx _context.Context, policyUuid string) ApiPoliciesExpressionDestroyRequest {
	return ApiPoliciesExpressionDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
func (a *PoliciesApiService) PoliciesExpressionDestroyExecute(r ApiPoliciesExpressionDestroyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesExpressionDestroy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/expression/{policy_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoliciesExpressionListRequest struct {
	ctx              _context.Context
	ApiService       *PoliciesApiService
	created          *time.Time
	executionLogging *bool
	expression       *string
	lastUpdated      *time.Time
	name             *string
	ordering         *string
	page             *int32
	pageSize         *int32
	policyUuid       *string
	search           *string
}

func (r ApiPoliciesExpressionListRequest) Created(created time.Time) ApiPoliciesExpressionListRequest {
	r.created = &created
	return r
}
func (r ApiPoliciesExpressionListRequest) ExecutionLogging(executionLogging bool) ApiPoliciesExpressionListRequest {
	r.executionLogging = &executionLogging
	return r
}
func (r ApiPoliciesExpressionListRequest) Expression(expression string) ApiPoliciesExpressionListRequest {
	r.expression = &expression
	return r
}
func (r ApiPoliciesExpressionListRequest) LastUpdated(lastUpdated time.Time) ApiPoliciesExpressionListRequest {
	r.lastUpdated = &lastUpdated
	return r
}
func (r ApiPoliciesExpressionListRequest) Name(name string) ApiPoliciesExpressionListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPoliciesExpressionListRequest) Ordering(ordering string) ApiPoliciesExpressionListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPoliciesExpressionListRequest) Page(page int32) ApiPoliciesExpressionListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPoliciesExpressionListRequest) PageSize(pageSize int32) ApiPoliciesExpressionListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiPoliciesExpressionListRequest) PolicyUuid(policyUuid string) ApiPoliciesExpressionListRequest {
	r.policyUuid = &policyUuid
	return r
}

// A search term.
func (r ApiPoliciesExpressionListRequest) Search(search string) ApiPoliciesExpressionListRequest {
	r.search = &search
	return r
}

func (r ApiPoliciesExpressionListRequest) Execute() (PaginatedExpressionPolicyList, *_nethttp.Response, error) {
	return r.ApiService.PoliciesExpressionListExecute(r)
}

/*
PoliciesExpressionList Method for PoliciesExpressionList

Source Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPoliciesExpressionListRequest
*/
func (a *PoliciesApiService) PoliciesExpressionList(ctx _context.Context) ApiPoliciesExpressionListRequest {
	return ApiPoliciesExpressionListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaginatedExpressionPolicyList
func (a *PoliciesApiService) PoliciesExpressionListExecute(r ApiPoliciesExpressionListRequest) (PaginatedExpressionPolicyList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedExpressionPolicyList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesExpressionList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/expression/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.executionLogging != nil {
		localVarQueryParams.Add("execution_logging", parameterToString(*r.executionLogging, ""))
	}
	if r.expression != nil {
		localVarQueryParams.Add("expression", parameterToString(*r.expression, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.policyUuid != nil {
		localVarQueryParams.Add("policy_uuid", parameterToString(*r.policyUuid, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesExpressionPartialUpdateRequest struct {
	ctx                            _context.Context
	ApiService                     *PoliciesApiService
	policyUuid                     string
	patchedExpressionPolicyRequest *PatchedExpressionPolicyRequest
}

func (r ApiPoliciesExpressionPartialUpdateRequest) PatchedExpressionPolicyRequest(patchedExpressionPolicyRequest PatchedExpressionPolicyRequest) ApiPoliciesExpressionPartialUpdateRequest {
	r.patchedExpressionPolicyRequest = &patchedExpressionPolicyRequest
	return r
}

func (r ApiPoliciesExpressionPartialUpdateRequest) Execute() (ExpressionPolicy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesExpressionPartialUpdateExecute(r)
}

/*
PoliciesExpressionPartialUpdate Method for PoliciesExpressionPartialUpdate

Source Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Expression Policy.
 @return ApiPoliciesExpressionPartialUpdateRequest
*/
func (a *PoliciesApiService) PoliciesExpressionPartialUpdate(ctx _context.Context, policyUuid string) ApiPoliciesExpressionPartialUpdateRequest {
	return ApiPoliciesExpressionPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return ExpressionPolicy
func (a *PoliciesApiService) PoliciesExpressionPartialUpdateExecute(r ApiPoliciesExpressionPartialUpdateRequest) (ExpressionPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ExpressionPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesExpressionPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/expression/{policy_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedExpressionPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesExpressionRetrieveRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	policyUuid string
}

func (r ApiPoliciesExpressionRetrieveRequest) Execute() (ExpressionPolicy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesExpressionRetrieveExecute(r)
}

/*
PoliciesExpressionRetrieve Method for PoliciesExpressionRetrieve

Source Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Expression Policy.
 @return ApiPoliciesExpressionRetrieveRequest
*/
func (a *PoliciesApiService) PoliciesExpressionRetrieve(ctx _context.Context, policyUuid string) ApiPoliciesExpressionRetrieveRequest {
	return ApiPoliciesExpressionRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return ExpressionPolicy
func (a *PoliciesApiService) PoliciesExpressionRetrieveExecute(r ApiPoliciesExpressionRetrieveRequest) (ExpressionPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ExpressionPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesExpressionRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/expression/{policy_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesExpressionUpdateRequest struct {
	ctx                     _context.Context
	ApiService              *PoliciesApiService
	policyUuid              string
	expressionPolicyRequest *ExpressionPolicyRequest
}

func (r ApiPoliciesExpressionUpdateRequest) ExpressionPolicyRequest(expressionPolicyRequest ExpressionPolicyRequest) ApiPoliciesExpressionUpdateRequest {
	r.expressionPolicyRequest = &expressionPolicyRequest
	return r
}

func (r ApiPoliciesExpressionUpdateRequest) Execute() (ExpressionPolicy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesExpressionUpdateExecute(r)
}

/*
PoliciesExpressionUpdate Method for PoliciesExpressionUpdate

Source Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Expression Policy.
 @return ApiPoliciesExpressionUpdateRequest
*/
func (a *PoliciesApiService) PoliciesExpressionUpdate(ctx _context.Context, policyUuid string) ApiPoliciesExpressionUpdateRequest {
	return ApiPoliciesExpressionUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return ExpressionPolicy
func (a *PoliciesApiService) PoliciesExpressionUpdateExecute(r ApiPoliciesExpressionUpdateRequest) (ExpressionPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ExpressionPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesExpressionUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/expression/{policy_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.expressionPolicyRequest == nil {
		return localVarReturnValue, nil, reportError("expressionPolicyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.expressionPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesExpressionUsedByListRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	policyUuid string
}

func (r ApiPoliciesExpressionUsedByListRequest) Execute() ([]UsedBy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesExpressionUsedByListExecute(r)
}

/*
PoliciesExpressionUsedByList Method for PoliciesExpressionUsedByList

Get a list of all objects that use this object

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Expression Policy.
 @return ApiPoliciesExpressionUsedByListRequest
*/
func (a *PoliciesApiService) PoliciesExpressionUsedByList(ctx _context.Context, policyUuid string) ApiPoliciesExpressionUsedByListRequest {
	return ApiPoliciesExpressionUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return []UsedBy
func (a *PoliciesApiService) PoliciesExpressionUsedByListExecute(r ApiPoliciesExpressionUsedByListRequest) ([]UsedBy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesExpressionUsedByList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/expression/{policy_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesHaveibeenpwnedCreateRequest struct {
	ctx                         _context.Context
	ApiService                  *PoliciesApiService
	haveIBeenPwendPolicyRequest *HaveIBeenPwendPolicyRequest
}

func (r ApiPoliciesHaveibeenpwnedCreateRequest) HaveIBeenPwendPolicyRequest(haveIBeenPwendPolicyRequest HaveIBeenPwendPolicyRequest) ApiPoliciesHaveibeenpwnedCreateRequest {
	r.haveIBeenPwendPolicyRequest = &haveIBeenPwendPolicyRequest
	return r
}

func (r ApiPoliciesHaveibeenpwnedCreateRequest) Execute() (HaveIBeenPwendPolicy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesHaveibeenpwnedCreateExecute(r)
}

/*
PoliciesHaveibeenpwnedCreate Method for PoliciesHaveibeenpwnedCreate

Source Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPoliciesHaveibeenpwnedCreateRequest
*/
func (a *PoliciesApiService) PoliciesHaveibeenpwnedCreate(ctx _context.Context) ApiPoliciesHaveibeenpwnedCreateRequest {
	return ApiPoliciesHaveibeenpwnedCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return HaveIBeenPwendPolicy
func (a *PoliciesApiService) PoliciesHaveibeenpwnedCreateExecute(r ApiPoliciesHaveibeenpwnedCreateRequest) (HaveIBeenPwendPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  HaveIBeenPwendPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesHaveibeenpwnedCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/haveibeenpwned/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.haveIBeenPwendPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesHaveibeenpwnedDestroyRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	policyUuid string
}

func (r ApiPoliciesHaveibeenpwnedDestroyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoliciesHaveibeenpwnedDestroyExecute(r)
}

/*
PoliciesHaveibeenpwnedDestroy Method for PoliciesHaveibeenpwnedDestroy

Source Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Have I Been Pwned Policy.
 @return ApiPoliciesHaveibeenpwnedDestroyRequest
*/
func (a *PoliciesApiService) PoliciesHaveibeenpwnedDestroy(ctx _context.Context, policyUuid string) ApiPoliciesHaveibeenpwnedDestroyRequest {
	return ApiPoliciesHaveibeenpwnedDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
func (a *PoliciesApiService) PoliciesHaveibeenpwnedDestroyExecute(r ApiPoliciesHaveibeenpwnedDestroyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesHaveibeenpwnedDestroy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/haveibeenpwned/{policy_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoliciesHaveibeenpwnedListRequest struct {
	ctx              _context.Context
	ApiService       *PoliciesApiService
	allowedCount     *int32
	created          *time.Time
	executionLogging *bool
	lastUpdated      *time.Time
	name             *string
	ordering         *string
	page             *int32
	pageSize         *int32
	passwordField    *string
	policyUuid       *string
	search           *string
}

func (r ApiPoliciesHaveibeenpwnedListRequest) AllowedCount(allowedCount int32) ApiPoliciesHaveibeenpwnedListRequest {
	r.allowedCount = &allowedCount
	return r
}
func (r ApiPoliciesHaveibeenpwnedListRequest) Created(created time.Time) ApiPoliciesHaveibeenpwnedListRequest {
	r.created = &created
	return r
}
func (r ApiPoliciesHaveibeenpwnedListRequest) ExecutionLogging(executionLogging bool) ApiPoliciesHaveibeenpwnedListRequest {
	r.executionLogging = &executionLogging
	return r
}
func (r ApiPoliciesHaveibeenpwnedListRequest) LastUpdated(lastUpdated time.Time) ApiPoliciesHaveibeenpwnedListRequest {
	r.lastUpdated = &lastUpdated
	return r
}
func (r ApiPoliciesHaveibeenpwnedListRequest) Name(name string) ApiPoliciesHaveibeenpwnedListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPoliciesHaveibeenpwnedListRequest) Ordering(ordering string) ApiPoliciesHaveibeenpwnedListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPoliciesHaveibeenpwnedListRequest) Page(page int32) ApiPoliciesHaveibeenpwnedListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPoliciesHaveibeenpwnedListRequest) PageSize(pageSize int32) ApiPoliciesHaveibeenpwnedListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiPoliciesHaveibeenpwnedListRequest) PasswordField(passwordField string) ApiPoliciesHaveibeenpwnedListRequest {
	r.passwordField = &passwordField
	return r
}
func (r ApiPoliciesHaveibeenpwnedListRequest) PolicyUuid(policyUuid string) ApiPoliciesHaveibeenpwnedListRequest {
	r.policyUuid = &policyUuid
	return r
}

// A search term.
func (r ApiPoliciesHaveibeenpwnedListRequest) Search(search string) ApiPoliciesHaveibeenpwnedListRequest {
	r.search = &search
	return r
}

func (r ApiPoliciesHaveibeenpwnedListRequest) Execute() (PaginatedHaveIBeenPwendPolicyList, *_nethttp.Response, error) {
	return r.ApiService.PoliciesHaveibeenpwnedListExecute(r)
}

/*
PoliciesHaveibeenpwnedList Method for PoliciesHaveibeenpwnedList

Source Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPoliciesHaveibeenpwnedListRequest
*/
func (a *PoliciesApiService) PoliciesHaveibeenpwnedList(ctx _context.Context) ApiPoliciesHaveibeenpwnedListRequest {
	return ApiPoliciesHaveibeenpwnedListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaginatedHaveIBeenPwendPolicyList
func (a *PoliciesApiService) PoliciesHaveibeenpwnedListExecute(r ApiPoliciesHaveibeenpwnedListRequest) (PaginatedHaveIBeenPwendPolicyList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedHaveIBeenPwendPolicyList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesHaveibeenpwnedList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/haveibeenpwned/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.allowedCount != nil {
		localVarQueryParams.Add("allowed_count", parameterToString(*r.allowedCount, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.executionLogging != nil {
		localVarQueryParams.Add("execution_logging", parameterToString(*r.executionLogging, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.passwordField != nil {
		localVarQueryParams.Add("password_field", parameterToString(*r.passwordField, ""))
	}
	if r.policyUuid != nil {
		localVarQueryParams.Add("policy_uuid", parameterToString(*r.policyUuid, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesHaveibeenpwnedPartialUpdateRequest struct {
	ctx                                _context.Context
	ApiService                         *PoliciesApiService
	policyUuid                         string
	patchedHaveIBeenPwendPolicyRequest *PatchedHaveIBeenPwendPolicyRequest
}

func (r ApiPoliciesHaveibeenpwnedPartialUpdateRequest) PatchedHaveIBeenPwendPolicyRequest(patchedHaveIBeenPwendPolicyRequest PatchedHaveIBeenPwendPolicyRequest) ApiPoliciesHaveibeenpwnedPartialUpdateRequest {
	r.patchedHaveIBeenPwendPolicyRequest = &patchedHaveIBeenPwendPolicyRequest
	return r
}

func (r ApiPoliciesHaveibeenpwnedPartialUpdateRequest) Execute() (HaveIBeenPwendPolicy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesHaveibeenpwnedPartialUpdateExecute(r)
}

/*
PoliciesHaveibeenpwnedPartialUpdate Method for PoliciesHaveibeenpwnedPartialUpdate

Source Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Have I Been Pwned Policy.
 @return ApiPoliciesHaveibeenpwnedPartialUpdateRequest
*/
func (a *PoliciesApiService) PoliciesHaveibeenpwnedPartialUpdate(ctx _context.Context, policyUuid string) ApiPoliciesHaveibeenpwnedPartialUpdateRequest {
	return ApiPoliciesHaveibeenpwnedPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return HaveIBeenPwendPolicy
func (a *PoliciesApiService) PoliciesHaveibeenpwnedPartialUpdateExecute(r ApiPoliciesHaveibeenpwnedPartialUpdateRequest) (HaveIBeenPwendPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  HaveIBeenPwendPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesHaveibeenpwnedPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/haveibeenpwned/{policy_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedHaveIBeenPwendPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesHaveibeenpwnedRetrieveRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	policyUuid string
}

func (r ApiPoliciesHaveibeenpwnedRetrieveRequest) Execute() (HaveIBeenPwendPolicy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesHaveibeenpwnedRetrieveExecute(r)
}

/*
PoliciesHaveibeenpwnedRetrieve Method for PoliciesHaveibeenpwnedRetrieve

Source Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Have I Been Pwned Policy.
 @return ApiPoliciesHaveibeenpwnedRetrieveRequest
*/
func (a *PoliciesApiService) PoliciesHaveibeenpwnedRetrieve(ctx _context.Context, policyUuid string) ApiPoliciesHaveibeenpwnedRetrieveRequest {
	return ApiPoliciesHaveibeenpwnedRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return HaveIBeenPwendPolicy
func (a *PoliciesApiService) PoliciesHaveibeenpwnedRetrieveExecute(r ApiPoliciesHaveibeenpwnedRetrieveRequest) (HaveIBeenPwendPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  HaveIBeenPwendPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesHaveibeenpwnedRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/haveibeenpwned/{policy_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesHaveibeenpwnedUpdateRequest struct {
	ctx                         _context.Context
	ApiService                  *PoliciesApiService
	policyUuid                  string
	haveIBeenPwendPolicyRequest *HaveIBeenPwendPolicyRequest
}

func (r ApiPoliciesHaveibeenpwnedUpdateRequest) HaveIBeenPwendPolicyRequest(haveIBeenPwendPolicyRequest HaveIBeenPwendPolicyRequest) ApiPoliciesHaveibeenpwnedUpdateRequest {
	r.haveIBeenPwendPolicyRequest = &haveIBeenPwendPolicyRequest
	return r
}

func (r ApiPoliciesHaveibeenpwnedUpdateRequest) Execute() (HaveIBeenPwendPolicy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesHaveibeenpwnedUpdateExecute(r)
}

/*
PoliciesHaveibeenpwnedUpdate Method for PoliciesHaveibeenpwnedUpdate

Source Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Have I Been Pwned Policy.
 @return ApiPoliciesHaveibeenpwnedUpdateRequest
*/
func (a *PoliciesApiService) PoliciesHaveibeenpwnedUpdate(ctx _context.Context, policyUuid string) ApiPoliciesHaveibeenpwnedUpdateRequest {
	return ApiPoliciesHaveibeenpwnedUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return HaveIBeenPwendPolicy
func (a *PoliciesApiService) PoliciesHaveibeenpwnedUpdateExecute(r ApiPoliciesHaveibeenpwnedUpdateRequest) (HaveIBeenPwendPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  HaveIBeenPwendPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesHaveibeenpwnedUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/haveibeenpwned/{policy_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.haveIBeenPwendPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesHaveibeenpwnedUsedByListRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	policyUuid string
}

func (r ApiPoliciesHaveibeenpwnedUsedByListRequest) Execute() ([]UsedBy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesHaveibeenpwnedUsedByListExecute(r)
}

/*
PoliciesHaveibeenpwnedUsedByList Method for PoliciesHaveibeenpwnedUsedByList

Get a list of all objects that use this object

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Have I Been Pwned Policy.
 @return ApiPoliciesHaveibeenpwnedUsedByListRequest
*/
func (a *PoliciesApiService) PoliciesHaveibeenpwnedUsedByList(ctx _context.Context, policyUuid string) ApiPoliciesHaveibeenpwnedUsedByListRequest {
	return ApiPoliciesHaveibeenpwnedUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return []UsedBy
func (a *PoliciesApiService) PoliciesHaveibeenpwnedUsedByListExecute(r ApiPoliciesHaveibeenpwnedUsedByListRequest) ([]UsedBy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesHaveibeenpwnedUsedByList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/haveibeenpwned/{policy_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesPasswordCreateRequest struct {
	ctx                   _context.Context
	ApiService            *PoliciesApiService
	passwordPolicyRequest *PasswordPolicyRequest
}

func (r ApiPoliciesPasswordCreateRequest) PasswordPolicyRequest(passwordPolicyRequest PasswordPolicyRequest) ApiPoliciesPasswordCreateRequest {
	r.passwordPolicyRequest = &passwordPolicyRequest
	return r
}

func (r ApiPoliciesPasswordCreateRequest) Execute() (PasswordPolicy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesPasswordCreateExecute(r)
}

/*
PoliciesPasswordCreate Method for PoliciesPasswordCreate

Password Policy Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPoliciesPasswordCreateRequest
*/
func (a *PoliciesApiService) PoliciesPasswordCreate(ctx _context.Context) ApiPoliciesPasswordCreateRequest {
	return ApiPoliciesPasswordCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PasswordPolicy
func (a *PoliciesApiService) PoliciesPasswordCreateExecute(r ApiPoliciesPasswordCreateRequest) (PasswordPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PasswordPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesPasswordCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/password/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.passwordPolicyRequest == nil {
		return localVarReturnValue, nil, reportError("passwordPolicyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.passwordPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesPasswordDestroyRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	policyUuid string
}

func (r ApiPoliciesPasswordDestroyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoliciesPasswordDestroyExecute(r)
}

/*
PoliciesPasswordDestroy Method for PoliciesPasswordDestroy

Password Policy Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Password Policy.
 @return ApiPoliciesPasswordDestroyRequest
*/
func (a *PoliciesApiService) PoliciesPasswordDestroy(ctx _context.Context, policyUuid string) ApiPoliciesPasswordDestroyRequest {
	return ApiPoliciesPasswordDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
func (a *PoliciesApiService) PoliciesPasswordDestroyExecute(r ApiPoliciesPasswordDestroyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesPasswordDestroy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/password/{policy_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoliciesPasswordExpiryCreateRequest struct {
	ctx                         _context.Context
	ApiService                  *PoliciesApiService
	passwordExpiryPolicyRequest *PasswordExpiryPolicyRequest
}

func (r ApiPoliciesPasswordExpiryCreateRequest) PasswordExpiryPolicyRequest(passwordExpiryPolicyRequest PasswordExpiryPolicyRequest) ApiPoliciesPasswordExpiryCreateRequest {
	r.passwordExpiryPolicyRequest = &passwordExpiryPolicyRequest
	return r
}

func (r ApiPoliciesPasswordExpiryCreateRequest) Execute() (PasswordExpiryPolicy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesPasswordExpiryCreateExecute(r)
}

/*
PoliciesPasswordExpiryCreate Method for PoliciesPasswordExpiryCreate

Password Expiry Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPoliciesPasswordExpiryCreateRequest
*/
func (a *PoliciesApiService) PoliciesPasswordExpiryCreate(ctx _context.Context) ApiPoliciesPasswordExpiryCreateRequest {
	return ApiPoliciesPasswordExpiryCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PasswordExpiryPolicy
func (a *PoliciesApiService) PoliciesPasswordExpiryCreateExecute(r ApiPoliciesPasswordExpiryCreateRequest) (PasswordExpiryPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PasswordExpiryPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesPasswordExpiryCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/password_expiry/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.passwordExpiryPolicyRequest == nil {
		return localVarReturnValue, nil, reportError("passwordExpiryPolicyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.passwordExpiryPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesPasswordExpiryDestroyRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	policyUuid string
}

func (r ApiPoliciesPasswordExpiryDestroyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoliciesPasswordExpiryDestroyExecute(r)
}

/*
PoliciesPasswordExpiryDestroy Method for PoliciesPasswordExpiryDestroy

Password Expiry Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Password Expiry Policy.
 @return ApiPoliciesPasswordExpiryDestroyRequest
*/
func (a *PoliciesApiService) PoliciesPasswordExpiryDestroy(ctx _context.Context, policyUuid string) ApiPoliciesPasswordExpiryDestroyRequest {
	return ApiPoliciesPasswordExpiryDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
func (a *PoliciesApiService) PoliciesPasswordExpiryDestroyExecute(r ApiPoliciesPasswordExpiryDestroyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesPasswordExpiryDestroy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/password_expiry/{policy_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoliciesPasswordExpiryListRequest struct {
	ctx              _context.Context
	ApiService       *PoliciesApiService
	created          *time.Time
	days             *int32
	denyOnly         *bool
	executionLogging *bool
	lastUpdated      *time.Time
	name             *string
	ordering         *string
	page             *int32
	pageSize         *int32
	policyUuid       *string
	search           *string
}

func (r ApiPoliciesPasswordExpiryListRequest) Created(created time.Time) ApiPoliciesPasswordExpiryListRequest {
	r.created = &created
	return r
}
func (r ApiPoliciesPasswordExpiryListRequest) Days(days int32) ApiPoliciesPasswordExpiryListRequest {
	r.days = &days
	return r
}
func (r ApiPoliciesPasswordExpiryListRequest) DenyOnly(denyOnly bool) ApiPoliciesPasswordExpiryListRequest {
	r.denyOnly = &denyOnly
	return r
}
func (r ApiPoliciesPasswordExpiryListRequest) ExecutionLogging(executionLogging bool) ApiPoliciesPasswordExpiryListRequest {
	r.executionLogging = &executionLogging
	return r
}
func (r ApiPoliciesPasswordExpiryListRequest) LastUpdated(lastUpdated time.Time) ApiPoliciesPasswordExpiryListRequest {
	r.lastUpdated = &lastUpdated
	return r
}
func (r ApiPoliciesPasswordExpiryListRequest) Name(name string) ApiPoliciesPasswordExpiryListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPoliciesPasswordExpiryListRequest) Ordering(ordering string) ApiPoliciesPasswordExpiryListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPoliciesPasswordExpiryListRequest) Page(page int32) ApiPoliciesPasswordExpiryListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPoliciesPasswordExpiryListRequest) PageSize(pageSize int32) ApiPoliciesPasswordExpiryListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiPoliciesPasswordExpiryListRequest) PolicyUuid(policyUuid string) ApiPoliciesPasswordExpiryListRequest {
	r.policyUuid = &policyUuid
	return r
}

// A search term.
func (r ApiPoliciesPasswordExpiryListRequest) Search(search string) ApiPoliciesPasswordExpiryListRequest {
	r.search = &search
	return r
}

func (r ApiPoliciesPasswordExpiryListRequest) Execute() (PaginatedPasswordExpiryPolicyList, *_nethttp.Response, error) {
	return r.ApiService.PoliciesPasswordExpiryListExecute(r)
}

/*
PoliciesPasswordExpiryList Method for PoliciesPasswordExpiryList

Password Expiry Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPoliciesPasswordExpiryListRequest
*/
func (a *PoliciesApiService) PoliciesPasswordExpiryList(ctx _context.Context) ApiPoliciesPasswordExpiryListRequest {
	return ApiPoliciesPasswordExpiryListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaginatedPasswordExpiryPolicyList
func (a *PoliciesApiService) PoliciesPasswordExpiryListExecute(r ApiPoliciesPasswordExpiryListRequest) (PaginatedPasswordExpiryPolicyList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedPasswordExpiryPolicyList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesPasswordExpiryList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/password_expiry/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.days != nil {
		localVarQueryParams.Add("days", parameterToString(*r.days, ""))
	}
	if r.denyOnly != nil {
		localVarQueryParams.Add("deny_only", parameterToString(*r.denyOnly, ""))
	}
	if r.executionLogging != nil {
		localVarQueryParams.Add("execution_logging", parameterToString(*r.executionLogging, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.policyUuid != nil {
		localVarQueryParams.Add("policy_uuid", parameterToString(*r.policyUuid, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesPasswordExpiryPartialUpdateRequest struct {
	ctx                                _context.Context
	ApiService                         *PoliciesApiService
	policyUuid                         string
	patchedPasswordExpiryPolicyRequest *PatchedPasswordExpiryPolicyRequest
}

func (r ApiPoliciesPasswordExpiryPartialUpdateRequest) PatchedPasswordExpiryPolicyRequest(patchedPasswordExpiryPolicyRequest PatchedPasswordExpiryPolicyRequest) ApiPoliciesPasswordExpiryPartialUpdateRequest {
	r.patchedPasswordExpiryPolicyRequest = &patchedPasswordExpiryPolicyRequest
	return r
}

func (r ApiPoliciesPasswordExpiryPartialUpdateRequest) Execute() (PasswordExpiryPolicy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesPasswordExpiryPartialUpdateExecute(r)
}

/*
PoliciesPasswordExpiryPartialUpdate Method for PoliciesPasswordExpiryPartialUpdate

Password Expiry Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Password Expiry Policy.
 @return ApiPoliciesPasswordExpiryPartialUpdateRequest
*/
func (a *PoliciesApiService) PoliciesPasswordExpiryPartialUpdate(ctx _context.Context, policyUuid string) ApiPoliciesPasswordExpiryPartialUpdateRequest {
	return ApiPoliciesPasswordExpiryPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return PasswordExpiryPolicy
func (a *PoliciesApiService) PoliciesPasswordExpiryPartialUpdateExecute(r ApiPoliciesPasswordExpiryPartialUpdateRequest) (PasswordExpiryPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PasswordExpiryPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesPasswordExpiryPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/password_expiry/{policy_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedPasswordExpiryPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesPasswordExpiryRetrieveRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	policyUuid string
}

func (r ApiPoliciesPasswordExpiryRetrieveRequest) Execute() (PasswordExpiryPolicy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesPasswordExpiryRetrieveExecute(r)
}

/*
PoliciesPasswordExpiryRetrieve Method for PoliciesPasswordExpiryRetrieve

Password Expiry Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Password Expiry Policy.
 @return ApiPoliciesPasswordExpiryRetrieveRequest
*/
func (a *PoliciesApiService) PoliciesPasswordExpiryRetrieve(ctx _context.Context, policyUuid string) ApiPoliciesPasswordExpiryRetrieveRequest {
	return ApiPoliciesPasswordExpiryRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return PasswordExpiryPolicy
func (a *PoliciesApiService) PoliciesPasswordExpiryRetrieveExecute(r ApiPoliciesPasswordExpiryRetrieveRequest) (PasswordExpiryPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PasswordExpiryPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesPasswordExpiryRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/password_expiry/{policy_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesPasswordExpiryUpdateRequest struct {
	ctx                         _context.Context
	ApiService                  *PoliciesApiService
	policyUuid                  string
	passwordExpiryPolicyRequest *PasswordExpiryPolicyRequest
}

func (r ApiPoliciesPasswordExpiryUpdateRequest) PasswordExpiryPolicyRequest(passwordExpiryPolicyRequest PasswordExpiryPolicyRequest) ApiPoliciesPasswordExpiryUpdateRequest {
	r.passwordExpiryPolicyRequest = &passwordExpiryPolicyRequest
	return r
}

func (r ApiPoliciesPasswordExpiryUpdateRequest) Execute() (PasswordExpiryPolicy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesPasswordExpiryUpdateExecute(r)
}

/*
PoliciesPasswordExpiryUpdate Method for PoliciesPasswordExpiryUpdate

Password Expiry Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Password Expiry Policy.
 @return ApiPoliciesPasswordExpiryUpdateRequest
*/
func (a *PoliciesApiService) PoliciesPasswordExpiryUpdate(ctx _context.Context, policyUuid string) ApiPoliciesPasswordExpiryUpdateRequest {
	return ApiPoliciesPasswordExpiryUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return PasswordExpiryPolicy
func (a *PoliciesApiService) PoliciesPasswordExpiryUpdateExecute(r ApiPoliciesPasswordExpiryUpdateRequest) (PasswordExpiryPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PasswordExpiryPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesPasswordExpiryUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/password_expiry/{policy_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.passwordExpiryPolicyRequest == nil {
		return localVarReturnValue, nil, reportError("passwordExpiryPolicyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.passwordExpiryPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesPasswordExpiryUsedByListRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	policyUuid string
}

func (r ApiPoliciesPasswordExpiryUsedByListRequest) Execute() ([]UsedBy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesPasswordExpiryUsedByListExecute(r)
}

/*
PoliciesPasswordExpiryUsedByList Method for PoliciesPasswordExpiryUsedByList

Get a list of all objects that use this object

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Password Expiry Policy.
 @return ApiPoliciesPasswordExpiryUsedByListRequest
*/
func (a *PoliciesApiService) PoliciesPasswordExpiryUsedByList(ctx _context.Context, policyUuid string) ApiPoliciesPasswordExpiryUsedByListRequest {
	return ApiPoliciesPasswordExpiryUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return []UsedBy
func (a *PoliciesApiService) PoliciesPasswordExpiryUsedByListExecute(r ApiPoliciesPasswordExpiryUsedByListRequest) ([]UsedBy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesPasswordExpiryUsedByList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/password_expiry/{policy_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesPasswordListRequest struct {
	ctx              _context.Context
	ApiService       *PoliciesApiService
	amountLowercase  *int32
	amountSymbols    *int32
	amountUppercase  *int32
	created          *time.Time
	errorMessage     *string
	executionLogging *bool
	lastUpdated      *time.Time
	lengthMin        *int32
	name             *string
	ordering         *string
	page             *int32
	pageSize         *int32
	passwordField    *string
	policyUuid       *string
	search           *string
	symbolCharset    *string
}

func (r ApiPoliciesPasswordListRequest) AmountLowercase(amountLowercase int32) ApiPoliciesPasswordListRequest {
	r.amountLowercase = &amountLowercase
	return r
}
func (r ApiPoliciesPasswordListRequest) AmountSymbols(amountSymbols int32) ApiPoliciesPasswordListRequest {
	r.amountSymbols = &amountSymbols
	return r
}
func (r ApiPoliciesPasswordListRequest) AmountUppercase(amountUppercase int32) ApiPoliciesPasswordListRequest {
	r.amountUppercase = &amountUppercase
	return r
}
func (r ApiPoliciesPasswordListRequest) Created(created time.Time) ApiPoliciesPasswordListRequest {
	r.created = &created
	return r
}
func (r ApiPoliciesPasswordListRequest) ErrorMessage(errorMessage string) ApiPoliciesPasswordListRequest {
	r.errorMessage = &errorMessage
	return r
}
func (r ApiPoliciesPasswordListRequest) ExecutionLogging(executionLogging bool) ApiPoliciesPasswordListRequest {
	r.executionLogging = &executionLogging
	return r
}
func (r ApiPoliciesPasswordListRequest) LastUpdated(lastUpdated time.Time) ApiPoliciesPasswordListRequest {
	r.lastUpdated = &lastUpdated
	return r
}
func (r ApiPoliciesPasswordListRequest) LengthMin(lengthMin int32) ApiPoliciesPasswordListRequest {
	r.lengthMin = &lengthMin
	return r
}
func (r ApiPoliciesPasswordListRequest) Name(name string) ApiPoliciesPasswordListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPoliciesPasswordListRequest) Ordering(ordering string) ApiPoliciesPasswordListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPoliciesPasswordListRequest) Page(page int32) ApiPoliciesPasswordListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPoliciesPasswordListRequest) PageSize(pageSize int32) ApiPoliciesPasswordListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiPoliciesPasswordListRequest) PasswordField(passwordField string) ApiPoliciesPasswordListRequest {
	r.passwordField = &passwordField
	return r
}
func (r ApiPoliciesPasswordListRequest) PolicyUuid(policyUuid string) ApiPoliciesPasswordListRequest {
	r.policyUuid = &policyUuid
	return r
}

// A search term.
func (r ApiPoliciesPasswordListRequest) Search(search string) ApiPoliciesPasswordListRequest {
	r.search = &search
	return r
}
func (r ApiPoliciesPasswordListRequest) SymbolCharset(symbolCharset string) ApiPoliciesPasswordListRequest {
	r.symbolCharset = &symbolCharset
	return r
}

func (r ApiPoliciesPasswordListRequest) Execute() (PaginatedPasswordPolicyList, *_nethttp.Response, error) {
	return r.ApiService.PoliciesPasswordListExecute(r)
}

/*
PoliciesPasswordList Method for PoliciesPasswordList

Password Policy Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPoliciesPasswordListRequest
*/
func (a *PoliciesApiService) PoliciesPasswordList(ctx _context.Context) ApiPoliciesPasswordListRequest {
	return ApiPoliciesPasswordListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaginatedPasswordPolicyList
func (a *PoliciesApiService) PoliciesPasswordListExecute(r ApiPoliciesPasswordListRequest) (PaginatedPasswordPolicyList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedPasswordPolicyList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesPasswordList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/password/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.amountLowercase != nil {
		localVarQueryParams.Add("amount_lowercase", parameterToString(*r.amountLowercase, ""))
	}
	if r.amountSymbols != nil {
		localVarQueryParams.Add("amount_symbols", parameterToString(*r.amountSymbols, ""))
	}
	if r.amountUppercase != nil {
		localVarQueryParams.Add("amount_uppercase", parameterToString(*r.amountUppercase, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.errorMessage != nil {
		localVarQueryParams.Add("error_message", parameterToString(*r.errorMessage, ""))
	}
	if r.executionLogging != nil {
		localVarQueryParams.Add("execution_logging", parameterToString(*r.executionLogging, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lengthMin != nil {
		localVarQueryParams.Add("length_min", parameterToString(*r.lengthMin, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.passwordField != nil {
		localVarQueryParams.Add("password_field", parameterToString(*r.passwordField, ""))
	}
	if r.policyUuid != nil {
		localVarQueryParams.Add("policy_uuid", parameterToString(*r.policyUuid, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.symbolCharset != nil {
		localVarQueryParams.Add("symbol_charset", parameterToString(*r.symbolCharset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesPasswordPartialUpdateRequest struct {
	ctx                          _context.Context
	ApiService                   *PoliciesApiService
	policyUuid                   string
	patchedPasswordPolicyRequest *PatchedPasswordPolicyRequest
}

func (r ApiPoliciesPasswordPartialUpdateRequest) PatchedPasswordPolicyRequest(patchedPasswordPolicyRequest PatchedPasswordPolicyRequest) ApiPoliciesPasswordPartialUpdateRequest {
	r.patchedPasswordPolicyRequest = &patchedPasswordPolicyRequest
	return r
}

func (r ApiPoliciesPasswordPartialUpdateRequest) Execute() (PasswordPolicy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesPasswordPartialUpdateExecute(r)
}

/*
PoliciesPasswordPartialUpdate Method for PoliciesPasswordPartialUpdate

Password Policy Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Password Policy.
 @return ApiPoliciesPasswordPartialUpdateRequest
*/
func (a *PoliciesApiService) PoliciesPasswordPartialUpdate(ctx _context.Context, policyUuid string) ApiPoliciesPasswordPartialUpdateRequest {
	return ApiPoliciesPasswordPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return PasswordPolicy
func (a *PoliciesApiService) PoliciesPasswordPartialUpdateExecute(r ApiPoliciesPasswordPartialUpdateRequest) (PasswordPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PasswordPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesPasswordPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/password/{policy_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedPasswordPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesPasswordRetrieveRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	policyUuid string
}

func (r ApiPoliciesPasswordRetrieveRequest) Execute() (PasswordPolicy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesPasswordRetrieveExecute(r)
}

/*
PoliciesPasswordRetrieve Method for PoliciesPasswordRetrieve

Password Policy Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Password Policy.
 @return ApiPoliciesPasswordRetrieveRequest
*/
func (a *PoliciesApiService) PoliciesPasswordRetrieve(ctx _context.Context, policyUuid string) ApiPoliciesPasswordRetrieveRequest {
	return ApiPoliciesPasswordRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return PasswordPolicy
func (a *PoliciesApiService) PoliciesPasswordRetrieveExecute(r ApiPoliciesPasswordRetrieveRequest) (PasswordPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PasswordPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesPasswordRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/password/{policy_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesPasswordUpdateRequest struct {
	ctx                   _context.Context
	ApiService            *PoliciesApiService
	policyUuid            string
	passwordPolicyRequest *PasswordPolicyRequest
}

func (r ApiPoliciesPasswordUpdateRequest) PasswordPolicyRequest(passwordPolicyRequest PasswordPolicyRequest) ApiPoliciesPasswordUpdateRequest {
	r.passwordPolicyRequest = &passwordPolicyRequest
	return r
}

func (r ApiPoliciesPasswordUpdateRequest) Execute() (PasswordPolicy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesPasswordUpdateExecute(r)
}

/*
PoliciesPasswordUpdate Method for PoliciesPasswordUpdate

Password Policy Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Password Policy.
 @return ApiPoliciesPasswordUpdateRequest
*/
func (a *PoliciesApiService) PoliciesPasswordUpdate(ctx _context.Context, policyUuid string) ApiPoliciesPasswordUpdateRequest {
	return ApiPoliciesPasswordUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return PasswordPolicy
func (a *PoliciesApiService) PoliciesPasswordUpdateExecute(r ApiPoliciesPasswordUpdateRequest) (PasswordPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PasswordPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesPasswordUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/password/{policy_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.passwordPolicyRequest == nil {
		return localVarReturnValue, nil, reportError("passwordPolicyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.passwordPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesPasswordUsedByListRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	policyUuid string
}

func (r ApiPoliciesPasswordUsedByListRequest) Execute() ([]UsedBy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesPasswordUsedByListExecute(r)
}

/*
PoliciesPasswordUsedByList Method for PoliciesPasswordUsedByList

Get a list of all objects that use this object

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Password Policy.
 @return ApiPoliciesPasswordUsedByListRequest
*/
func (a *PoliciesApiService) PoliciesPasswordUsedByList(ctx _context.Context, policyUuid string) ApiPoliciesPasswordUsedByListRequest {
	return ApiPoliciesPasswordUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return []UsedBy
func (a *PoliciesApiService) PoliciesPasswordUsedByListExecute(r ApiPoliciesPasswordUsedByListRequest) ([]UsedBy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesPasswordUsedByList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/password/{policy_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesReputationCreateRequest struct {
	ctx                     _context.Context
	ApiService              *PoliciesApiService
	reputationPolicyRequest *ReputationPolicyRequest
}

func (r ApiPoliciesReputationCreateRequest) ReputationPolicyRequest(reputationPolicyRequest ReputationPolicyRequest) ApiPoliciesReputationCreateRequest {
	r.reputationPolicyRequest = &reputationPolicyRequest
	return r
}

func (r ApiPoliciesReputationCreateRequest) Execute() (ReputationPolicy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesReputationCreateExecute(r)
}

/*
PoliciesReputationCreate Method for PoliciesReputationCreate

Reputation Policy Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPoliciesReputationCreateRequest
*/
func (a *PoliciesApiService) PoliciesReputationCreate(ctx _context.Context) ApiPoliciesReputationCreateRequest {
	return ApiPoliciesReputationCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ReputationPolicy
func (a *PoliciesApiService) PoliciesReputationCreateExecute(r ApiPoliciesReputationCreateRequest) (ReputationPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ReputationPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesReputationCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/reputation/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.reputationPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesReputationDestroyRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	policyUuid string
}

func (r ApiPoliciesReputationDestroyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoliciesReputationDestroyExecute(r)
}

/*
PoliciesReputationDestroy Method for PoliciesReputationDestroy

Reputation Policy Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Reputation Policy.
 @return ApiPoliciesReputationDestroyRequest
*/
func (a *PoliciesApiService) PoliciesReputationDestroy(ctx _context.Context, policyUuid string) ApiPoliciesReputationDestroyRequest {
	return ApiPoliciesReputationDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
func (a *PoliciesApiService) PoliciesReputationDestroyExecute(r ApiPoliciesReputationDestroyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesReputationDestroy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/reputation/{policy_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoliciesReputationIpsDestroyRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	id         int32
}

func (r ApiPoliciesReputationIpsDestroyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoliciesReputationIpsDestroyExecute(r)
}

/*
PoliciesReputationIpsDestroy Method for PoliciesReputationIpsDestroy

IPReputation Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this ip reputation.
 @return ApiPoliciesReputationIpsDestroyRequest
*/
func (a *PoliciesApiService) PoliciesReputationIpsDestroy(ctx _context.Context, id int32) ApiPoliciesReputationIpsDestroyRequest {
	return ApiPoliciesReputationIpsDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *PoliciesApiService) PoliciesReputationIpsDestroyExecute(r ApiPoliciesReputationIpsDestroyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesReputationIpsDestroy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/reputation/ips/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoliciesReputationIpsListRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	ip         *string
	ordering   *string
	page       *int32
	pageSize   *int32
	score      *int32
	search     *string
}

func (r ApiPoliciesReputationIpsListRequest) Ip(ip string) ApiPoliciesReputationIpsListRequest {
	r.ip = &ip
	return r
}

// Which field to use when ordering the results.
func (r ApiPoliciesReputationIpsListRequest) Ordering(ordering string) ApiPoliciesReputationIpsListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPoliciesReputationIpsListRequest) Page(page int32) ApiPoliciesReputationIpsListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPoliciesReputationIpsListRequest) PageSize(pageSize int32) ApiPoliciesReputationIpsListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiPoliciesReputationIpsListRequest) Score(score int32) ApiPoliciesReputationIpsListRequest {
	r.score = &score
	return r
}

// A search term.
func (r ApiPoliciesReputationIpsListRequest) Search(search string) ApiPoliciesReputationIpsListRequest {
	r.search = &search
	return r
}

func (r ApiPoliciesReputationIpsListRequest) Execute() (PaginatedIPReputationList, *_nethttp.Response, error) {
	return r.ApiService.PoliciesReputationIpsListExecute(r)
}

/*
PoliciesReputationIpsList Method for PoliciesReputationIpsList

IPReputation Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPoliciesReputationIpsListRequest
*/
func (a *PoliciesApiService) PoliciesReputationIpsList(ctx _context.Context) ApiPoliciesReputationIpsListRequest {
	return ApiPoliciesReputationIpsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaginatedIPReputationList
func (a *PoliciesApiService) PoliciesReputationIpsListExecute(r ApiPoliciesReputationIpsListRequest) (PaginatedIPReputationList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedIPReputationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesReputationIpsList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/reputation/ips/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.ip != nil {
		localVarQueryParams.Add("ip", parameterToString(*r.ip, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.score != nil {
		localVarQueryParams.Add("score", parameterToString(*r.score, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesReputationIpsRetrieveRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	id         int32
}

func (r ApiPoliciesReputationIpsRetrieveRequest) Execute() (IPReputation, *_nethttp.Response, error) {
	return r.ApiService.PoliciesReputationIpsRetrieveExecute(r)
}

/*
PoliciesReputationIpsRetrieve Method for PoliciesReputationIpsRetrieve

IPReputation Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this ip reputation.
 @return ApiPoliciesReputationIpsRetrieveRequest
*/
func (a *PoliciesApiService) PoliciesReputationIpsRetrieve(ctx _context.Context, id int32) ApiPoliciesReputationIpsRetrieveRequest {
	return ApiPoliciesReputationIpsRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return IPReputation
func (a *PoliciesApiService) PoliciesReputationIpsRetrieveExecute(r ApiPoliciesReputationIpsRetrieveRequest) (IPReputation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IPReputation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesReputationIpsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/reputation/ips/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesReputationIpsUsedByListRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	id         int32
}

func (r ApiPoliciesReputationIpsUsedByListRequest) Execute() ([]UsedBy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesReputationIpsUsedByListExecute(r)
}

/*
PoliciesReputationIpsUsedByList Method for PoliciesReputationIpsUsedByList

Get a list of all objects that use this object

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this ip reputation.
 @return ApiPoliciesReputationIpsUsedByListRequest
*/
func (a *PoliciesApiService) PoliciesReputationIpsUsedByList(ctx _context.Context, id int32) ApiPoliciesReputationIpsUsedByListRequest {
	return ApiPoliciesReputationIpsUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return []UsedBy
func (a *PoliciesApiService) PoliciesReputationIpsUsedByListExecute(r ApiPoliciesReputationIpsUsedByListRequest) ([]UsedBy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesReputationIpsUsedByList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/reputation/ips/{id}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesReputationListRequest struct {
	ctx              _context.Context
	ApiService       *PoliciesApiService
	checkIp          *bool
	checkUsername    *bool
	created          *time.Time
	executionLogging *bool
	lastUpdated      *time.Time
	name             *string
	ordering         *string
	page             *int32
	pageSize         *int32
	policyUuid       *string
	search           *string
	threshold        *int32
}

func (r ApiPoliciesReputationListRequest) CheckIp(checkIp bool) ApiPoliciesReputationListRequest {
	r.checkIp = &checkIp
	return r
}
func (r ApiPoliciesReputationListRequest) CheckUsername(checkUsername bool) ApiPoliciesReputationListRequest {
	r.checkUsername = &checkUsername
	return r
}
func (r ApiPoliciesReputationListRequest) Created(created time.Time) ApiPoliciesReputationListRequest {
	r.created = &created
	return r
}
func (r ApiPoliciesReputationListRequest) ExecutionLogging(executionLogging bool) ApiPoliciesReputationListRequest {
	r.executionLogging = &executionLogging
	return r
}
func (r ApiPoliciesReputationListRequest) LastUpdated(lastUpdated time.Time) ApiPoliciesReputationListRequest {
	r.lastUpdated = &lastUpdated
	return r
}
func (r ApiPoliciesReputationListRequest) Name(name string) ApiPoliciesReputationListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiPoliciesReputationListRequest) Ordering(ordering string) ApiPoliciesReputationListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPoliciesReputationListRequest) Page(page int32) ApiPoliciesReputationListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPoliciesReputationListRequest) PageSize(pageSize int32) ApiPoliciesReputationListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiPoliciesReputationListRequest) PolicyUuid(policyUuid string) ApiPoliciesReputationListRequest {
	r.policyUuid = &policyUuid
	return r
}

// A search term.
func (r ApiPoliciesReputationListRequest) Search(search string) ApiPoliciesReputationListRequest {
	r.search = &search
	return r
}
func (r ApiPoliciesReputationListRequest) Threshold(threshold int32) ApiPoliciesReputationListRequest {
	r.threshold = &threshold
	return r
}

func (r ApiPoliciesReputationListRequest) Execute() (PaginatedReputationPolicyList, *_nethttp.Response, error) {
	return r.ApiService.PoliciesReputationListExecute(r)
}

/*
PoliciesReputationList Method for PoliciesReputationList

Reputation Policy Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPoliciesReputationListRequest
*/
func (a *PoliciesApiService) PoliciesReputationList(ctx _context.Context) ApiPoliciesReputationListRequest {
	return ApiPoliciesReputationListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaginatedReputationPolicyList
func (a *PoliciesApiService) PoliciesReputationListExecute(r ApiPoliciesReputationListRequest) (PaginatedReputationPolicyList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedReputationPolicyList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesReputationList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/reputation/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.checkIp != nil {
		localVarQueryParams.Add("check_ip", parameterToString(*r.checkIp, ""))
	}
	if r.checkUsername != nil {
		localVarQueryParams.Add("check_username", parameterToString(*r.checkUsername, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.executionLogging != nil {
		localVarQueryParams.Add("execution_logging", parameterToString(*r.executionLogging, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.policyUuid != nil {
		localVarQueryParams.Add("policy_uuid", parameterToString(*r.policyUuid, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.threshold != nil {
		localVarQueryParams.Add("threshold", parameterToString(*r.threshold, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesReputationPartialUpdateRequest struct {
	ctx                            _context.Context
	ApiService                     *PoliciesApiService
	policyUuid                     string
	patchedReputationPolicyRequest *PatchedReputationPolicyRequest
}

func (r ApiPoliciesReputationPartialUpdateRequest) PatchedReputationPolicyRequest(patchedReputationPolicyRequest PatchedReputationPolicyRequest) ApiPoliciesReputationPartialUpdateRequest {
	r.patchedReputationPolicyRequest = &patchedReputationPolicyRequest
	return r
}

func (r ApiPoliciesReputationPartialUpdateRequest) Execute() (ReputationPolicy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesReputationPartialUpdateExecute(r)
}

/*
PoliciesReputationPartialUpdate Method for PoliciesReputationPartialUpdate

Reputation Policy Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Reputation Policy.
 @return ApiPoliciesReputationPartialUpdateRequest
*/
func (a *PoliciesApiService) PoliciesReputationPartialUpdate(ctx _context.Context, policyUuid string) ApiPoliciesReputationPartialUpdateRequest {
	return ApiPoliciesReputationPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return ReputationPolicy
func (a *PoliciesApiService) PoliciesReputationPartialUpdateExecute(r ApiPoliciesReputationPartialUpdateRequest) (ReputationPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ReputationPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesReputationPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/reputation/{policy_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedReputationPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesReputationRetrieveRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	policyUuid string
}

func (r ApiPoliciesReputationRetrieveRequest) Execute() (ReputationPolicy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesReputationRetrieveExecute(r)
}

/*
PoliciesReputationRetrieve Method for PoliciesReputationRetrieve

Reputation Policy Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Reputation Policy.
 @return ApiPoliciesReputationRetrieveRequest
*/
func (a *PoliciesApiService) PoliciesReputationRetrieve(ctx _context.Context, policyUuid string) ApiPoliciesReputationRetrieveRequest {
	return ApiPoliciesReputationRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return ReputationPolicy
func (a *PoliciesApiService) PoliciesReputationRetrieveExecute(r ApiPoliciesReputationRetrieveRequest) (ReputationPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ReputationPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesReputationRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/reputation/{policy_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesReputationUpdateRequest struct {
	ctx                     _context.Context
	ApiService              *PoliciesApiService
	policyUuid              string
	reputationPolicyRequest *ReputationPolicyRequest
}

func (r ApiPoliciesReputationUpdateRequest) ReputationPolicyRequest(reputationPolicyRequest ReputationPolicyRequest) ApiPoliciesReputationUpdateRequest {
	r.reputationPolicyRequest = &reputationPolicyRequest
	return r
}

func (r ApiPoliciesReputationUpdateRequest) Execute() (ReputationPolicy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesReputationUpdateExecute(r)
}

/*
PoliciesReputationUpdate Method for PoliciesReputationUpdate

Reputation Policy Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Reputation Policy.
 @return ApiPoliciesReputationUpdateRequest
*/
func (a *PoliciesApiService) PoliciesReputationUpdate(ctx _context.Context, policyUuid string) ApiPoliciesReputationUpdateRequest {
	return ApiPoliciesReputationUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return ReputationPolicy
func (a *PoliciesApiService) PoliciesReputationUpdateExecute(r ApiPoliciesReputationUpdateRequest) (ReputationPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ReputationPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesReputationUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/reputation/{policy_uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.reputationPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesReputationUsedByListRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	policyUuid string
}

func (r ApiPoliciesReputationUsedByListRequest) Execute() ([]UsedBy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesReputationUsedByListExecute(r)
}

/*
PoliciesReputationUsedByList Method for PoliciesReputationUsedByList

Get a list of all objects that use this object

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid A UUID string identifying this Reputation Policy.
 @return ApiPoliciesReputationUsedByListRequest
*/
func (a *PoliciesApiService) PoliciesReputationUsedByList(ctx _context.Context, policyUuid string) ApiPoliciesReputationUsedByListRequest {
	return ApiPoliciesReputationUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return []UsedBy
func (a *PoliciesApiService) PoliciesReputationUsedByListExecute(r ApiPoliciesReputationUsedByListRequest) ([]UsedBy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesReputationUsedByList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/reputation/{policy_uuid}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"policy_uuid"+"}", _neturl.PathEscape(parameterToString(r.policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesReputationUsersDestroyRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	id         int32
}

func (r ApiPoliciesReputationUsersDestroyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoliciesReputationUsersDestroyExecute(r)
}

/*
PoliciesReputationUsersDestroy Method for PoliciesReputationUsersDestroy

UserReputation Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this user reputation.
 @return ApiPoliciesReputationUsersDestroyRequest
*/
func (a *PoliciesApiService) PoliciesReputationUsersDestroy(ctx _context.Context, id int32) ApiPoliciesReputationUsersDestroyRequest {
	return ApiPoliciesReputationUsersDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *PoliciesApiService) PoliciesReputationUsersDestroyExecute(r ApiPoliciesReputationUsersDestroyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesReputationUsersDestroy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/reputation/users/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoliciesReputationUsersListRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	ordering   *string
	page       *int32
	pageSize   *int32
	score      *int32
	search     *string
	username   *string
}

// Which field to use when ordering the results.
func (r ApiPoliciesReputationUsersListRequest) Ordering(ordering string) ApiPoliciesReputationUsersListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPoliciesReputationUsersListRequest) Page(page int32) ApiPoliciesReputationUsersListRequest {
	r.page = &page
	return r
}

// Number of results to return per page.
func (r ApiPoliciesReputationUsersListRequest) PageSize(pageSize int32) ApiPoliciesReputationUsersListRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiPoliciesReputationUsersListRequest) Score(score int32) ApiPoliciesReputationUsersListRequest {
	r.score = &score
	return r
}

// A search term.
func (r ApiPoliciesReputationUsersListRequest) Search(search string) ApiPoliciesReputationUsersListRequest {
	r.search = &search
	return r
}
func (r ApiPoliciesReputationUsersListRequest) Username(username string) ApiPoliciesReputationUsersListRequest {
	r.username = &username
	return r
}

func (r ApiPoliciesReputationUsersListRequest) Execute() (PaginatedUserReputationList, *_nethttp.Response, error) {
	return r.ApiService.PoliciesReputationUsersListExecute(r)
}

/*
PoliciesReputationUsersList Method for PoliciesReputationUsersList

UserReputation Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPoliciesReputationUsersListRequest
*/
func (a *PoliciesApiService) PoliciesReputationUsersList(ctx _context.Context) ApiPoliciesReputationUsersListRequest {
	return ApiPoliciesReputationUsersListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaginatedUserReputationList
func (a *PoliciesApiService) PoliciesReputationUsersListExecute(r ApiPoliciesReputationUsersListRequest) (PaginatedUserReputationList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedUserReputationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesReputationUsersList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/reputation/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.score != nil {
		localVarQueryParams.Add("score", parameterToString(*r.score, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.username != nil {
		localVarQueryParams.Add("username", parameterToString(*r.username, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesReputationUsersRetrieveRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	id         int32
}

func (r ApiPoliciesReputationUsersRetrieveRequest) Execute() (UserReputation, *_nethttp.Response, error) {
	return r.ApiService.PoliciesReputationUsersRetrieveExecute(r)
}

/*
PoliciesReputationUsersRetrieve Method for PoliciesReputationUsersRetrieve

UserReputation Viewset

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this user reputation.
 @return ApiPoliciesReputationUsersRetrieveRequest
*/
func (a *PoliciesApiService) PoliciesReputationUsersRetrieve(ctx _context.Context, id int32) ApiPoliciesReputationUsersRetrieveRequest {
	return ApiPoliciesReputationUsersRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return UserReputation
func (a *PoliciesApiService) PoliciesReputationUsersRetrieveExecute(r ApiPoliciesReputationUsersRetrieveRequest) (UserReputation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UserReputation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesReputationUsersRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/reputation/users/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPoliciesReputationUsersUsedByListRequest struct {
	ctx        _context.Context
	ApiService *PoliciesApiService
	id         int32
}

func (r ApiPoliciesReputationUsersUsedByListRequest) Execute() ([]UsedBy, *_nethttp.Response, error) {
	return r.ApiService.PoliciesReputationUsersUsedByListExecute(r)
}

/*
PoliciesReputationUsersUsedByList Method for PoliciesReputationUsersUsedByList

Get a list of all objects that use this object

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this user reputation.
 @return ApiPoliciesReputationUsersUsedByListRequest
*/
func (a *PoliciesApiService) PoliciesReputationUsersUsedByList(ctx _context.Context, id int32) ApiPoliciesReputationUsersUsedByListRequest {
	return ApiPoliciesReputationUsersUsedByListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return []UsedBy
func (a *PoliciesApiService) PoliciesReputationUsersUsedByListExecute(r ApiPoliciesReputationUsersUsedByListRequest) ([]UsedBy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []UsedBy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesApiService.PoliciesReputationUsersUsedByList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/reputation/users/{id}/used_by/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["authentik"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
